{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"OVRO-LWA Portal","text":"<p>A Python library for radio astronomy data processing and visualization for the Owens Valley Radio Observatory - Long Wavelength Array (OVRO-LWA).</p> <p>For a project overview and quick start, see the README on GitHub.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Unified Data Loading: Load OVRO-LWA data from local paths, remote URLs   (S3, HTTPS), or DOI identifiers with a single <code>open_dataset()</code> function</li> <li>FITS to Zarr Conversion: Convert OVRO-LWA FITS image files to   cloud-optimized Zarr format</li> <li>Command-Line Interface: User-friendly <code>ovro-ingest</code> CLI with progress   tracking</li> <li>WCS Coordinate Preservation: Maintain celestial coordinates (RA/Dec) for   FITS-free analysis</li> <li>Incremental Processing: Append new observations to existing Zarr stores</li> <li>Concurrent Write Protection: File locking prevents data corruption from   simultaneous processes</li> <li>Optional Workflow Orchestration: Prefect integration for production   deployments</li> </ul>"},{"location":"#technology-stack","title":"Technology Stack","text":"<ul> <li>Core: Python 3.12, xarray, dask, zarr</li> <li>Astronomy: astropy, xradio, python-casacore</li> <li>CLI: typer, rich (progress bars and formatted output)</li> <li>Workflow: prefect (optional orchestration)</li> <li>Storage: Zarr format optimized for cloud access</li> <li>Environment Management: pixi</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import ovro_lwa_portal\n\n# Load from local zarr store\nds = ovro_lwa_portal.open_dataset(\"/path/to/observation.zarr\")\n\n# Load from remote URL\nds = ovro_lwa_portal.open_dataset(\"s3://ovro-lwa-data/obs_12345.zarr\")\n\n# Load via DOI\nds = ovro_lwa_portal.open_dataset(\"doi:10.5281/zenodo.1234567\")\n</code></pre>"},{"location":"#getting-help","title":"Getting Help","text":"<ul> <li>GitHub Issues</li> <li>GitHub Discussions</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the BSD License - see the LICENSE file for details.</p>"},{"location":"api/data-loading/","title":"Data Loading","text":"<p>The <code>ovro_lwa_portal.io</code> module provides a unified interface for loading OVRO-LWA datasets from local paths, remote URLs, and DOI identifiers.</p>"},{"location":"api/data-loading/#quick-reference","title":"Quick Reference","text":"<pre><code>import ovro_lwa_portal\n\n# Local path\nds = ovro_lwa_portal.open_dataset(\"/path/to/data.zarr\")\n\n# Remote URL (S3, HTTPS, GCS)\nds = ovro_lwa_portal.open_dataset(\"s3://bucket/data.zarr\")\n\n# DOI identifier\nds = ovro_lwa_portal.open_dataset(\"doi:10.5281/zenodo.1234567\")\n\n# Custom chunking\nds = ovro_lwa_portal.open_dataset(\n    \"path/to/data.zarr\",\n    chunks={\"time\": 100, \"frequency\": 50},\n)\n</code></pre>"},{"location":"api/data-loading/#supported-protocols","title":"Supported Protocols","text":"Protocol Example Notes Local path <code>/data/obs.zarr</code> Checks existence before loading S3 <code>s3://bucket/data.zarr</code> Via fsspec HTTPS <code>https://example.com/data.zarr</code> Via fsspec GCS <code>gs://bucket/data.zarr</code> Via fsspec Azure <code>abfs://container/data.zarr</code> Via fsspec DOI <code>doi:10.5281/zenodo.1234567</code> Resolves via DataCite API"},{"location":"api/data-loading/#full-api-reference","title":"Full API Reference","text":""},{"location":"api/data-loading/#ovro_lwa_portal.io","title":"<code>io</code>","text":"<p>Data loading utilities for OVRO-LWA datasets.</p> <p>This module provides a unified interface for loading OVRO-LWA data from multiple sources including local paths, remote URLs, and DOI identifiers.</p>"},{"location":"api/data-loading/#ovro_lwa_portal.io.DataSourceError","title":"<code>DataSourceError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised for errors in data source handling.</p> Source code in <code>src/ovro_lwa_portal/io.py</code> <pre><code>class DataSourceError(Exception):\n    \"\"\"Exception raised for errors in data source handling.\"\"\"\n\n    pass\n</code></pre>"},{"location":"api/data-loading/#ovro_lwa_portal.io.resolve_source","title":"<code>resolve_source(source, production=True, storage_options=None)</code>","text":"<p>Resolve a data source to its final URL without loading data.</p> <p>Performs DOI resolution and URL normalization, returning the full resolution chain. Useful for debugging DOI\u2192URL\u2192S3 resolution without actually loading any data.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str or Path</code> <p>Data source, can be: - Local file path (e.g., \"/path/to/data.zarr\") - Remote URL (e.g., \"s3://bucket/data.zarr\", \"https://...\") - DOI string (e.g., \"doi:10.xxxx/xxxxx\" or \"10.xxxx/xxxxx\")</p> required <code>production</code> <code>bool</code> <p>Which DataCite API to use when resolving DOI identifiers.</p> <code>True</code> <code>storage_options</code> <code>dict</code> <p>Options passed to the filesystem backend (e.g., S3 credentials). Used to determine if OSN HTTPS\u2192S3 conversion should be applied.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Resolution details with keys: - <code>source_type</code>: \"local\", \"remote\", or \"doi\" - <code>original_source</code>: the source string as provided - <code>resolved_url</code>: URL after DOI resolution (or original if not a DOI) - <code>final_url</code>: final URL after OSN conversion (if applicable) - <code>s3_url</code>: S3 URL if OSN conversion was applied, else None - <code>endpoint</code>: S3 endpoint URL if applicable, else None - <code>bucket</code>: S3 bucket name if applicable, else None - <code>path</code>: path within bucket if applicable, else None</p> <p>Raises:</p> Type Description <code>DataSourceError</code> <p>If DOI resolution fails.</p> <p>Examples:</p> <p>Resolve a DOI to see the full chain:</p> <pre><code>&gt;&gt;&gt; from ovro_lwa_portal import resolve_source\n&gt;&gt;&gt; info = resolve_source(\"10.33569/9wsys-h7b71\", production=False)\n&gt;&gt;&gt; info[\"source_type\"]\n'doi'\n&gt;&gt;&gt; info[\"resolved_url\"]\n'https://caltech1.osn.mghpcc.org/...'\n</code></pre> <p>Resolve with S3 credentials to see OSN conversion:</p> <pre><code>&gt;&gt;&gt; info = resolve_source(\n...     \"10.33569/9wsys-h7b71\",\n...     production=False,\n...     storage_options={\"key\": \"ACCESS_KEY\", \"secret\": \"SECRET_KEY\"},\n... )\n&gt;&gt;&gt; info[\"s3_url\"]\n's3://...'\n</code></pre> Source code in <code>src/ovro_lwa_portal/io.py</code> <pre><code>def resolve_source(\n    source: str | Path,\n    production: bool = True,\n    storage_options: dict[str, Any] | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"Resolve a data source to its final URL without loading data.\n\n    Performs DOI resolution and URL normalization, returning the full\n    resolution chain. Useful for debugging DOI\u2192URL\u2192S3 resolution\n    without actually loading any data.\n\n    Parameters\n    ----------\n    source : str or Path\n        Data source, can be:\n        - Local file path (e.g., \"/path/to/data.zarr\")\n        - Remote URL (e.g., \"s3://bucket/data.zarr\", \"https://...\")\n        - DOI string (e.g., \"doi:10.xxxx/xxxxx\" or \"10.xxxx/xxxxx\")\n    production : bool, default True\n        Which DataCite API to use when resolving DOI identifiers.\n    storage_options : dict, optional\n        Options passed to the filesystem backend (e.g., S3 credentials).\n        Used to determine if OSN HTTPS\u2192S3 conversion should be applied.\n\n    Returns\n    -------\n    dict[str, Any]\n        Resolution details with keys:\n        - ``source_type``: \"local\", \"remote\", or \"doi\"\n        - ``original_source``: the source string as provided\n        - ``resolved_url``: URL after DOI resolution (or original if not a DOI)\n        - ``final_url``: final URL after OSN conversion (if applicable)\n        - ``s3_url``: S3 URL if OSN conversion was applied, else None\n        - ``endpoint``: S3 endpoint URL if applicable, else None\n        - ``bucket``: S3 bucket name if applicable, else None\n        - ``path``: path within bucket if applicable, else None\n\n    Raises\n    ------\n    DataSourceError\n        If DOI resolution fails.\n\n    Examples\n    --------\n    Resolve a DOI to see the full chain:\n\n    &gt;&gt;&gt; from ovro_lwa_portal import resolve_source\n    &gt;&gt;&gt; info = resolve_source(\"10.33569/9wsys-h7b71\", production=False)\n    &gt;&gt;&gt; info[\"source_type\"]\n    'doi'\n    &gt;&gt;&gt; info[\"resolved_url\"]\n    'https://caltech1.osn.mghpcc.org/...'\n\n    Resolve with S3 credentials to see OSN conversion:\n\n    &gt;&gt;&gt; info = resolve_source(\n    ...     \"10.33569/9wsys-h7b71\",\n    ...     production=False,\n    ...     storage_options={\"key\": \"ACCESS_KEY\", \"secret\": \"SECRET_KEY\"},\n    ... )\n    &gt;&gt;&gt; info[\"s3_url\"]\n    's3://...'\n    \"\"\"\n    original_source = str(source)\n    source_type, normalized = _detect_source_type(source)\n\n    result: dict[str, Any] = {\n        \"source_type\": source_type,\n        \"original_source\": original_source,\n        \"resolved_url\": None,\n        \"final_url\": None,\n        \"s3_url\": None,\n        \"endpoint\": None,\n        \"bucket\": None,\n        \"path\": None,\n    }\n\n    # Resolve DOI to actual data URL\n    if source_type == \"doi\":\n        try:\n            resolved = _resolve_doi(normalized, production=production)\n        except Exception as e:\n            msg = f\"Failed to resolve DOI {normalized}: {e}\"\n            raise DataSourceError(msg) from e\n        result[\"resolved_url\"] = resolved\n    else:\n        result[\"resolved_url\"] = normalized\n        resolved = normalized\n\n    # Check for OSN HTTPS\u2192S3 conversion\n    if storage_options and source_type in (\"doi\", \"remote\"):\n        converted_url, converted_opts = _convert_osn_https_to_s3(\n            resolved, storage_options\n        )\n        if converted_url != resolved:\n            # OSN conversion was applied\n            result[\"s3_url\"] = converted_url\n            result[\"endpoint\"] = converted_opts.get(\"client_kwargs\", {}).get(\n                \"endpoint_url\"\n            )\n            # Parse bucket and path from the S3 URL\n            parsed_s3 = urlparse(converted_url)\n            result[\"bucket\"] = parsed_s3.netloc\n            result[\"path\"] = parsed_s3.path.lstrip(\"/\") or None\n            result[\"final_url\"] = converted_url\n        else:\n            result[\"final_url\"] = resolved\n    else:\n        result[\"final_url\"] = resolved\n\n    return result\n</code></pre>"},{"location":"api/data-loading/#ovro_lwa_portal.io.open_dataset","title":"<code>open_dataset(source, chunks='auto', production=True, storage_options=None, engine='zarr', validate=True, **kwargs)</code>","text":"<p>Load OVRO-LWA data as an xarray Dataset.</p> <p>This function provides a unified interface for loading OVRO-LWA data from multiple sources including local file paths, remote URLs, and DOI identifiers.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str or Path</code> <p>Data source, can be: - Local file path (e.g., \"/path/to/data.zarr\") - Remote URL (e.g., \"s3://bucket/data.zarr\", \"https://...\") - DOI string (e.g., \"doi:10.xxxx/xxxxx\" or \"10.xxxx/xxxxx\")</p> required <code>chunks</code> <code>dict, str, or None</code> <p>Chunking strategy for lazy loading: - dict: Explicit chunk sizes per dimension, e.g., {\"time\": 100, \"frequency\": 50} - \"auto\": Let xarray/dask determine optimal chunks - None: Load entire dataset into memory (not recommended for large data)</p> <code>\"auto\"</code> <code>production</code> <code>bool</code> <p>Which DataCite API to use when resolving DOI identifiers: - True: production API (api.datacite.org) - False: test API (api.test.datacite.org)</p> <code>True</code> <code>storage_options</code> <code>dict</code> <p>Options passed to the filesystem backend (e.g., S3 credentials). Example: storage_options={\"key\": \"ACCESS_KEY\", \"secret\": \"SECRET_KEY\"}</p> <code>None</code> <code>engine</code> <code>str</code> <p>Backend engine for loading data. Currently supports \"zarr\".</p> <code>\"zarr\"</code> <code>validate</code> <code>bool</code> <p>If True, validate that loaded data conforms to OVRO-LWA data model.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to the underlying loader (xr.open_zarr, etc.)</p> <code>{}</code> <p>Returns:</p> Type Description <code>Dataset</code> <p>OVRO-LWA dataset with standardized structure.</p> <p>Raises:</p> Type Description <code>DataSourceError</code> <p>If source cannot be accessed or loaded.</p> <code>FileNotFoundError</code> <p>If local file path doesn't exist.</p> <code>ImportError</code> <p>If required dependencies for remote/DOI access are not installed.</p> <p>Examples:</p> <p>Load from local zarr store:</p> <pre><code>&gt;&gt;&gt; import ovro_lwa_portal\n&gt;&gt;&gt; ds = ovro_lwa_portal.open_dataset(\"/path/to/observation.zarr\")\n</code></pre> <p>Load from S3 bucket:</p> <pre><code>&gt;&gt;&gt; ds = ovro_lwa_portal.open_dataset(\"s3://ovro-lwa-data/obs_12345.zarr\")\n</code></pre> <p>Load from HTTP/HTTPS URL:</p> <pre><code>&gt;&gt;&gt; ds = ovro_lwa_portal.open_dataset(\"https://data.ovro.caltech.edu/obs_12345.zarr\")\n</code></pre> <p>Load via DOI (with or without prefix):</p> <pre><code>&gt;&gt;&gt; ds = ovro_lwa_portal.open_dataset(\"doi:10.5281/zenodo.1234567\")\n&gt;&gt;&gt; ds = ovro_lwa_portal.open_dataset(\"10.5281/zenodo.1234567\")\n</code></pre> <p>Load from test DataCite API with S3 credentials:</p> <pre><code>&gt;&gt;&gt; ds = ovro_lwa_portal.open_dataset(\n...     \"10.33569/4q7nb-ahq31\",\n...     production=False,\n...     storage_options={\"key\": \"ACCESS_KEY\", \"secret\": \"SECRET_KEY\"}\n... )\n</code></pre> <p>Customize chunking:</p> <pre><code>&gt;&gt;&gt; ds = ovro_lwa_portal.open_dataset(\n...     \"path/to/data.zarr\",\n...     chunks={\"time\": 100, \"frequency\": 50}\n... )\n</code></pre> Notes <p>For remote data sources (S3, GCS), authentication is handled via environment variables or configuration files specific to each cloud provider:</p> <ul> <li>AWS S3: AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, or ~/.aws/credentials</li> <li>Google Cloud Storage: GOOGLE_APPLICATION_CREDENTIALS</li> <li>Azure: AZURE_STORAGE_ACCOUNT_NAME, AZURE_STORAGE_ACCOUNT_KEY</li> </ul> <p>For large datasets, lazy loading with dask is used by default (chunks=\"auto\"). This allows working with datasets larger than memory.</p> Source code in <code>src/ovro_lwa_portal/io.py</code> <pre><code>def open_dataset(\n    source: str | Path,\n    chunks: dict[str, int] | str | None = \"auto\",\n    production: bool = True,\n    storage_options: dict[str, Any] | None = None,\n    engine: str = \"zarr\",\n    validate: bool = True,\n    **kwargs: Any,\n) -&gt; xr.Dataset:\n    \"\"\"Load OVRO-LWA data as an xarray Dataset.\n\n    This function provides a unified interface for loading OVRO-LWA data from\n    multiple sources including local file paths, remote URLs, and DOI identifiers.\n\n    Parameters\n    ----------\n    source : str or Path\n        Data source, can be:\n        - Local file path (e.g., \"/path/to/data.zarr\")\n        - Remote URL (e.g., \"s3://bucket/data.zarr\", \"https://...\")\n        - DOI string (e.g., \"doi:10.xxxx/xxxxx\" or \"10.xxxx/xxxxx\")\n    chunks : dict, str, or None, default \"auto\"\n        Chunking strategy for lazy loading:\n        - dict: Explicit chunk sizes per dimension, e.g., {\"time\": 100, \"frequency\": 50}\n        - \"auto\": Let xarray/dask determine optimal chunks\n        - None: Load entire dataset into memory (not recommended for large data)\n    production : bool, default True\n        Which DataCite API to use when resolving DOI identifiers:\n        - True: production API (api.datacite.org)\n        - False: test API (api.test.datacite.org)\n    storage_options : dict, optional\n        Options passed to the filesystem backend (e.g., S3 credentials).\n        Example: storage_options={\"key\": \"ACCESS_KEY\", \"secret\": \"SECRET_KEY\"}\n    engine : str, default \"zarr\"\n        Backend engine for loading data. Currently supports \"zarr\".\n    validate : bool, default True\n        If True, validate that loaded data conforms to OVRO-LWA data model.\n    **kwargs\n        Additional arguments passed to the underlying loader (xr.open_zarr, etc.)\n\n    Returns\n    -------\n    xr.Dataset\n        OVRO-LWA dataset with standardized structure.\n\n    Raises\n    ------\n    DataSourceError\n        If source cannot be accessed or loaded.\n    FileNotFoundError\n        If local file path doesn't exist.\n    ImportError\n        If required dependencies for remote/DOI access are not installed.\n\n    Examples\n    --------\n    Load from local zarr store:\n\n    &gt;&gt;&gt; import ovro_lwa_portal\n    &gt;&gt;&gt; ds = ovro_lwa_portal.open_dataset(\"/path/to/observation.zarr\")\n\n    Load from S3 bucket:\n\n    &gt;&gt;&gt; ds = ovro_lwa_portal.open_dataset(\"s3://ovro-lwa-data/obs_12345.zarr\")\n\n    Load from HTTP/HTTPS URL:\n\n    &gt;&gt;&gt; ds = ovro_lwa_portal.open_dataset(\"https://data.ovro.caltech.edu/obs_12345.zarr\")\n\n    Load via DOI (with or without prefix):\n\n    &gt;&gt;&gt; ds = ovro_lwa_portal.open_dataset(\"doi:10.5281/zenodo.1234567\")\n    &gt;&gt;&gt; ds = ovro_lwa_portal.open_dataset(\"10.5281/zenodo.1234567\")\n\n    Load from test DataCite API with S3 credentials:\n\n    &gt;&gt;&gt; ds = ovro_lwa_portal.open_dataset(\n    ...     \"10.33569/4q7nb-ahq31\",\n    ...     production=False,\n    ...     storage_options={\"key\": \"ACCESS_KEY\", \"secret\": \"SECRET_KEY\"}\n    ... )\n\n    Customize chunking:\n\n    &gt;&gt;&gt; ds = ovro_lwa_portal.open_dataset(\n    ...     \"path/to/data.zarr\",\n    ...     chunks={\"time\": 100, \"frequency\": 50}\n    ... )\n\n    Notes\n    -----\n    For remote data sources (S3, GCS), authentication is handled via environment\n    variables or configuration files specific to each cloud provider:\n\n    - AWS S3: AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, or ~/.aws/credentials\n    - Google Cloud Storage: GOOGLE_APPLICATION_CREDENTIALS\n    - Azure: AZURE_STORAGE_ACCOUNT_NAME, AZURE_STORAGE_ACCOUNT_KEY\n\n    For large datasets, lazy loading with dask is used by default (chunks=\"auto\").\n    This allows working with datasets larger than memory.\n    \"\"\"\n    original_source = str(source)\n    source_type, normalized_source = _detect_source_type(source)\n    resolved_url: str | None = None  # Track DOI-resolved URL for error messages\n\n    # Resolve DOI to actual data URL\n    if source_type == \"doi\":\n        try:\n            normalized_source = _resolve_doi(normalized_source, production=production)\n            resolved_url = normalized_source\n            source_type = \"remote\"  # After resolution, treat as remote URL\n        except Exception as e:\n            msg = f\"Failed to resolve DOI {normalized_source}: {e}\"\n            raise DataSourceError(msg) from e\n\n    # Convert OSN HTTPS URLs to S3 when credentials are provided\n    # OSN provides both HTTPS and S3 access to the same data\n    if source_type == \"remote\" and storage_options:\n        normalized_source, storage_options = _convert_osn_https_to_s3(\n            normalized_source, storage_options\n        )\n\n    # Load data based on engine\n    try:\n        if engine == \"zarr\":\n            # Use fsspec's universal pathlib for unified handling of local and remote paths\n            try:\n                from upath import UPath\n            except ImportError as e:\n                msg = (\n                    \"universal-pathlib is required for path handling. \"\n                    \"Install with: pip install universal-pathlib\"\n                )\n                raise ImportError(msg) from e\n\n            # Create filesystem and mapper\n            # When storage_options are provided, use fsspec directly for cloud storage\n            parsed_url = urlparse(normalized_source)\n            protocol = parsed_url.scheme if parsed_url.scheme else \"file\"\n\n            if storage_options and protocol in (\"s3\", \"gs\", \"gcs\", \"abfs\", \"az\"):\n                # Use fsspec directly for cloud storage with credentials\n                try:\n                    import fsspec\n                except ImportError as e:\n                    msg = (\n                        \"fsspec is required for remote storage access. \"\n                        \"Install with: pip install fsspec\"\n                    )\n                    raise ImportError(msg) from e\n\n                # Create filesystem with storage options\n                fs = fsspec.filesystem(protocol, **storage_options)\n\n                # Get path without protocol (e.g., s3://bucket/path -&gt; bucket/path)\n                path = f\"{parsed_url.netloc}/{parsed_url.path.lstrip('/')}\"\n                store = fs.get_mapper(path)\n\n                # Early accessibility check for cloud storage\n                _check_remote_access(\n                    fs, path, original_source, normalized_source, storage_options\n                )\n            else:\n                # For local files or HTTPS, use UPath without storage_options\n                store_path = UPath(normalized_source)\n\n                # Explicit local existence check\n                if store_path.protocol in (\"\", \"file\") and not store_path.exists():\n                    raise FileNotFoundError(f\"Local path does not exist: {store_path}\")\n\n                # Build a Zarr store (fsspec mapper) from the UPath\n                fs = store_path.fs\n                store = fs.get_mapper(store_path.path)\n\n            # Check if we need cloud storage backends for remote paths\n            if source_type == \"remote\":\n                parsed = urlparse(normalized_source)\n                if parsed.scheme == \"s3\":\n                    try:\n                        import s3fs  # noqa: F401\n                    except ImportError as e:\n                        msg = (\n                            \"s3fs is required for S3 access. \"\n                            \"Install with: pip install s3fs\"\n                        )\n                        raise ImportError(msg) from e\n                elif parsed.scheme in (\"gs\", \"gcs\"):\n                    try:\n                        import gcsfs  # noqa: F401\n                    except ImportError as e:\n                        msg = (\n                            \"gcsfs is required for Google Cloud Storage access. \"\n                            \"Install with: pip install gcsfs\"\n                        )\n                        raise ImportError(msg) from e\n\n            # Open the zarr store using the UPath\n            # xr.open_zarr can handle fsspec mappers directly\n            with warnings.catch_warnings():\n                warnings.simplefilter(\"default\")\n                ds = xr.open_zarr(store, chunks=chunks, **kwargs)\n\n        else:\n            msg = f\"Unsupported engine: {engine}. Currently only 'zarr' is supported.\"\n            raise DataSourceError(msg)\n\n    except FileNotFoundError:\n        raise\n    except ImportError:\n        raise\n    except DataSourceError:\n        raise\n    except Exception as e:\n        # Build a detailed error message including the resolution chain\n        parts = [f\"Failed to load dataset from '{original_source}'\"]\n        if resolved_url and resolved_url != original_source:\n            parts.append(f\"resolved to: {resolved_url}\")\n        if normalized_source != original_source and normalized_source != resolved_url:\n            parts.append(f\"final URL: {normalized_source}\")\n        if storage_options and \"client_kwargs\" in storage_options:\n            endpoint = storage_options[\"client_kwargs\"].get(\"endpoint_url\")\n            if endpoint:\n                parts.append(f\"S3 endpoint: {endpoint}\")\n        parts.append(str(e))\n        msg = \"\\n  \".join(parts)\n        raise DataSourceError(msg) from e\n\n    # Validate dataset structure if requested\n    if validate:\n        _validate_dataset(ds)\n\n    return ds\n</code></pre>"},{"location":"api/fits-to-zarr-xradio/","title":"FITS to Zarr (Low-Level)","text":"<p>The <code>ovro_lwa_portal.fits_to_zarr_xradio</code> module provides the low-level functions for converting OVRO-LWA FITS image files to Zarr format using xradio.</p> <p>Prefer the high-level API for most use cases</p> <p>The <code>FITSToZarrConverter</code> class in the ingest module wraps these functions with FileLock-based concurrency protection, progress callbacks, and a simpler interface. Use the low-level functions here only when you need fine-grained control over the conversion process.</p>"},{"location":"api/fits-to-zarr-xradio/#quick-reference","title":"Quick Reference","text":"<pre><code>from pathlib import Path\nfrom ovro_lwa_portal.fits_to_zarr_xradio import (\n    convert_fits_dir_to_zarr,\n    fix_fits_headers,\n)\n\n# Fix headers first (optional \u2014 convert_fits_dir_to_zarr can do this on-demand)\nfits_files = sorted(Path(\"/data/fits\").glob(\"*.fits\"))\nfixed = fix_fits_headers(fits_files, Path(\"/data/fixed_fits\"))\n\n# Convert to Zarr\nresult = convert_fits_dir_to_zarr(\n    input_dir=\"/data/fits\",\n    out_dir=\"/data/output\",\n    fixed_dir=\"/data/fixed_fits\",\n    fix_headers_on_demand=False,  # already fixed above\n)\n</code></pre>"},{"location":"api/fits-to-zarr-xradio/#api-reference","title":"API Reference","text":""},{"location":"api/fits-to-zarr-xradio/#convert_fits_dir_to_zarr","title":"convert_fits_dir_to_zarr","text":""},{"location":"api/fits-to-zarr-xradio/#ovro_lwa_portal.fits_to_zarr_xradio.convert_fits_dir_to_zarr","title":"<code>convert_fits_dir_to_zarr(input_dir, out_dir, zarr_name='ovro_lwa_full_lm_only.zarr', fixed_dir='fixed_fits', chunk_lm=1024, rebuild=False, fix_headers_on_demand=True, progress_callback=None)</code>","text":"<p>Convert all matching FITS in a directory into a single LM-only Zarr store.</p> <p>Parameters:</p> Name Type Description Default <code>input_dir</code> <code>str | Path</code> <p>Directory containing input FITS files.</p> required <code>out_dir</code> <code>str | Path</code> <p>Directory where the Zarr store will be written.</p> required <code>zarr_name</code> <code>str</code> <p>Name of the Zarr store directory (under <code>out_dir</code>).</p> <code>'ovro_lwa_full_lm_only.zarr'</code> <code>fixed_dir</code> <code>str | Path</code> <p>Directory to place generated <code>*_fixed.fits</code> files.</p> <code>'fixed_fits'</code> <code>chunk_lm</code> <code>int</code> <p>Optional LM chunk size for the in-memory xarray datasets (0 disables).</p> <code>1024</code> <code>rebuild</code> <code>bool</code> <p>If True, overwrite any existing Zarr; otherwise append to it.</p> <code>False</code> <code>fix_headers_on_demand</code> <code>bool</code> <p>If True, fix FITS headers on-demand during conversion if they don't exist. If False, assume headers are already fixed using :func:<code>fix_fits_headers</code>. Default is True.</p> <code>True</code> <code>progress_callback</code> <code>Optional[Callable[[str, int, int, str], None]]</code> <p>Optional callback function for progress reporting. Should accept (stage: str, current: int, total: int, message: str).</p> <code>None</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the resulting Zarr store directory.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If no matching FITS files are found.</p> <code>RuntimeError</code> <p>If LM grids differ across time steps.</p> Source code in <code>src/ovro_lwa_portal/fits_to_zarr_xradio.py</code> <pre><code>def convert_fits_dir_to_zarr(\n    input_dir: str | Path,\n    out_dir: str | Path,\n    zarr_name: str = \"ovro_lwa_full_lm_only.zarr\",\n    fixed_dir: str | Path = \"fixed_fits\",\n    chunk_lm: int = 1024,\n    rebuild: bool = False,\n    fix_headers_on_demand: bool = True,\n    progress_callback: Optional[Callable[[str, int, int, str], None]] = None,\n) -&gt; Path:\n    \"\"\"Convert all matching FITS in a directory into a single LM-only Zarr store.\n\n    Parameters\n    ----------\n    input_dir\n        Directory containing input FITS files.\n    out_dir\n        Directory where the Zarr store will be written.\n    zarr_name\n        Name of the Zarr store directory (under ``out_dir``).\n    fixed_dir\n        Directory to place generated ``*_fixed.fits`` files.\n    chunk_lm\n        Optional LM chunk size for the in-memory xarray datasets (0 disables).\n    rebuild\n        If True, overwrite any existing Zarr; otherwise append to it.\n    fix_headers_on_demand\n        If True, fix FITS headers on-demand during conversion if they don't exist.\n        If False, assume headers are already fixed using :func:`fix_fits_headers`.\n        Default is True.\n    progress_callback\n        Optional callback function for progress reporting. Should accept\n        (stage: str, current: int, total: int, message: str).\n\n    Returns\n    -------\n    Path\n        Path to the resulting Zarr store directory.\n\n    Raises\n    ------\n    FileNotFoundError\n        If no matching FITS files are found.\n    RuntimeError\n        If LM grids differ across time steps.\n    \"\"\"\n    input_dir = Path(input_dir)\n    out_dir = Path(out_dir)\n    out_dir.mkdir(parents=True, exist_ok=True)\n    fixed_dir = Path(fixed_dir)\n    fixed_dir.mkdir(parents=True, exist_ok=True)\n    out_zarr = out_dir / zarr_name\n\n    by_time = _discover_groups(input_dir)\n    total_files = sum(len(v) for v in by_time.values())\n    logger.info(f\"Discovered {total_files} FITS across {len(by_time)} time step(s).\")\n    for k, v in by_time.items():\n        mhz_sorted = sorted(_mhz_from_name(p) for p in v)\n        logger.info(f\"  time {k}: {len(v)} file(s), subbands (MHz): {mhz_sorted}\")\n\n    if not by_time:\n        raise FileNotFoundError(f\"No matching FITS found in {input_dir}\")\n\n    # Decide whether we write a fresh store or append to an existing one\n    first_write = not (out_zarr.exists() and not rebuild)\n    lm_reference: Tuple[NDArray[np.floating], NDArray[np.floating]] | None = None\n\n    total_time_steps = len(by_time)\n    for idx, tkey in enumerate(sorted(by_time.keys())):\n        files = by_time[tkey]\n\n        logger.info(f\"[read/combine] time {tkey}\")\n        xds_t, freqs = _combine_time_step(\n            files, fixed_dir, chunk_lm=chunk_lm, fix_headers_on_demand=fix_headers_on_demand\n        )\n        logger.info(f\"  combined dims: {dict(xds_t.dims)}\")\n        logger.info(f\"  combined freqs (Hz): {freqs[:8]}{' ...' if len(freqs) &gt; 8 else ''}\")\n\n        lm_current = (xds_t[\"l\"].values, xds_t[\"m\"].values)\n        if lm_reference is None:\n            lm_reference = (lm_current[0].copy(), lm_current[1].copy())\n            logger.info(\"  stored l/m grid as reference\")\n        else:\n            _assert_same_lm(lm_reference, lm_current)\n            logger.info(\"  l/m grid matches reference\")\n\n        logger.info(f\"[{'write new' if first_write else 'append'}] {out_zarr}\")\n        _write_or_append_zarr(xds_t, out_zarr, first_write=first_write)\n        first_write = False\n\n        # Report progress after completing this time step\n        if progress_callback:\n            progress_callback(\n                \"converting\",\n                idx + 1,\n                total_time_steps,\n                f\"Completed time step {idx + 1}/{total_time_steps}\"\n            )\n\n    logger.info(f\"[done] All times appended into: {out_zarr}\")\n    return out_zarr\n</code></pre>"},{"location":"api/fits-to-zarr-xradio/#fix_fits_headers","title":"fix_fits_headers","text":""},{"location":"api/fits-to-zarr-xradio/#ovro_lwa_portal.fits_to_zarr_xradio.fix_fits_headers","title":"<code>fix_fits_headers(files, fixed_dir, *, skip_existing=True)</code>","text":"<p>Fix FITS headers for a list of files, creating <code>*_fixed.fits</code> files.</p> <p>This function processes FITS files to ensure they have the necessary headers for xradio conversion. It can be run ahead of time before calling :func:<code>convert_fits_dir_to_zarr</code> to separate the header fixing step from the conversion process.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>List[Path]</code> <p>List of FITS file paths to process.</p> required <code>fixed_dir</code> <code>Path</code> <p>Directory where <code>*_fixed.fits</code> files will be written.</p> required <code>skip_existing</code> <code>bool</code> <p>If True, skip files that already have corresponding fixed versions. Default is True.</p> <code>True</code> <p>Returns:</p> Type Description <code>List[Path]</code> <p>List of paths to the fixed FITS files.</p> Notes <ul> <li>Files already ending with <code>_fixed.fits</code> are considered already fixed   and are returned as-is.</li> <li>The :func:<code>_fix_headers</code> function applies BSCALE/BZERO and adds minimal   WCS/spectral keywords required by xradio.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from ovro_lwa_portal.fits_to_zarr_xradio import fix_fits_headers\n&gt;&gt;&gt; input_files = list(Path(\"input\").glob(\"*.fits\"))\n&gt;&gt;&gt; fixed_dir = Path(\"fixed_fits\")\n&gt;&gt;&gt; fixed_dir.mkdir(exist_ok=True)\n&gt;&gt;&gt; fixed_paths = fix_fits_headers(input_files, fixed_dir)\n&gt;&gt;&gt; print(f\"Fixed {len(fixed_paths)} files\")\n</code></pre> Source code in <code>src/ovro_lwa_portal/fits_to_zarr_xradio.py</code> <pre><code>def fix_fits_headers(\n    files: List[Path],\n    fixed_dir: Path,\n    *,\n    skip_existing: bool = True,\n) -&gt; List[Path]:\n    \"\"\"Fix FITS headers for a list of files, creating ``*_fixed.fits`` files.\n\n    This function processes FITS files to ensure they have the necessary\n    headers for xradio conversion. It can be run ahead of time before\n    calling :func:`convert_fits_dir_to_zarr` to separate the header\n    fixing step from the conversion process.\n\n    Parameters\n    ----------\n    files : List[Path]\n        List of FITS file paths to process.\n    fixed_dir : Path\n        Directory where ``*_fixed.fits`` files will be written.\n    skip_existing : bool, optional\n        If True, skip files that already have corresponding fixed versions.\n        Default is True.\n\n    Returns\n    -------\n    List[Path]\n        List of paths to the fixed FITS files.\n\n    Notes\n    -----\n    * Files already ending with ``_fixed.fits`` are considered already fixed\n      and are returned as-is.\n    * The :func:`_fix_headers` function applies BSCALE/BZERO and adds minimal\n      WCS/spectral keywords required by xradio.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from pathlib import Path\n    &gt;&gt;&gt; from ovro_lwa_portal.fits_to_zarr_xradio import fix_fits_headers\n    &gt;&gt;&gt; input_files = list(Path(\"input\").glob(\"*.fits\"))\n    &gt;&gt;&gt; fixed_dir = Path(\"fixed_fits\")\n    &gt;&gt;&gt; fixed_dir.mkdir(exist_ok=True)\n    &gt;&gt;&gt; fixed_paths = fix_fits_headers(input_files, fixed_dir)\n    &gt;&gt;&gt; print(f\"Fixed {len(fixed_paths)} files\")\n    \"\"\"\n    fixed_dir.mkdir(parents=True, exist_ok=True)\n    fixed_paths: List[Path] = []\n\n    for f in sorted(files, key=_mhz_from_name):\n        if f.name.endswith(\"_fixed.fits\"):\n            # Already fixed, use as-is\n            fixed_paths.append(f)\n            logger.debug(f\"Skipping already-fixed file: {f.name}\")\n        else:\n            fixed = fixed_dir / (f.stem + \"_fixed.fits\")\n            if skip_existing and fixed.exists():\n                logger.debug(f\"Skipping existing fixed file: {fixed.name}\")\n            else:\n                logger.info(f\"Fixing headers: {f.name} -&gt; {fixed.name}\")\n                _fix_headers(f, fixed)\n            fixed_paths.append(fixed)\n\n    return fixed_paths\n</code></pre>"},{"location":"api/ingest/","title":"Ingest Module","text":"<p>The <code>ovro_lwa_portal.ingest</code> package provides tools for converting OVRO-LWA FITS image files to cloud-optimized Zarr format, with support for incremental processing, WCS coordinate preservation, and concurrent write protection.</p>"},{"location":"api/ingest/#cli-reference","title":"CLI Reference","text":"<p>The <code>ovro-ingest</code> command-line tool is installed automatically with the package.</p>"},{"location":"api/ingest/#ovro-ingest-convert","title":"<code>ovro-ingest convert</code>","text":"<p>Convert FITS files to a single Zarr store:</p> <pre><code>ovro-ingest convert INPUT_DIR OUTPUT_DIR [OPTIONS]\n</code></pre> Option Short Default Description <code>--zarr-name</code> <code>-z</code> <code>ovro_lwa_full_lm_only.zarr</code> Name of output Zarr store <code>--fixed-dir</code> <code>-f</code> <code>OUTPUT_DIR/fixed_fits</code> Directory for fixed FITS files <code>--chunk-lm</code> <code>-c</code> <code>1024</code> Chunk size for l/m dimensions (0 to disable) <code>--rebuild</code> <code>-r</code> <code>False</code> Overwrite existing store instead of appending <code>--skip-header-fixing</code> <code>-s</code> <code>False</code> Skip header fixing (assume pre-fixed) <code>--log-level</code> <code>-l</code> <code>info</code> Logging level (debug/info/warning/error)"},{"location":"api/ingest/#ovro-ingest-fix-headers","title":"<code>ovro-ingest fix-headers</code>","text":"<p>Fix FITS headers as a separate step before conversion:</p> <pre><code>ovro-ingest fix-headers INPUT_DIR FIXED_DIR [OPTIONS]\n</code></pre> Option Short Default Description <code>--skip-existing/--overwrite</code> <code>--skip-existing</code> Skip files with existing fixed versions <code>--log-level</code> <code>-l</code> <code>info</code> Logging level"},{"location":"api/ingest/#examples","title":"Examples","text":"<pre><code># Basic conversion (fixes headers on-demand)\novro-ingest convert /data/fits /data/output\n\n# Rebuild with verbose logging\novro-ingest convert /data/fits /data/output --rebuild --log-level debug\n\n# Custom Zarr name and chunk size\novro-ingest convert /data/fits /data/output \\\n    --zarr-name my_data.zarr --chunk-lm 2048\n\n# Two-step workflow: fix headers first, then convert\novro-ingest fix-headers /data/fits /data/fixed_fits\novro-ingest convert /data/fits /data/output \\\n    --fixed-dir /data/fixed_fits --skip-header-fixing\n</code></pre>"},{"location":"api/ingest/#python-api","title":"Python API","text":""},{"location":"api/ingest/#fitstozarrconverter","title":"FITSToZarrConverter","text":""},{"location":"api/ingest/#ovro_lwa_portal.ingest.FITSToZarrConverter","title":"<code>FITSToZarrConverter</code>","text":"<p>Orchestrates FITS to Zarr conversion with progress tracking and locking.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ConversionConfig</code> <p>Conversion configuration.</p> required <code>progress_callback</code> <code>ProgressCallback | None</code> <p>Optional callback for progress reporting.</p> <code>None</code> Source code in <code>src/ovro_lwa_portal/ingest/core.py</code> <pre><code>class FITSToZarrConverter:\n    \"\"\"Orchestrates FITS to Zarr conversion with progress tracking and locking.\n\n    Parameters\n    ----------\n    config : ConversionConfig\n        Conversion configuration.\n    progress_callback : ProgressCallback | None, optional\n        Optional callback for progress reporting.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: ConversionConfig,\n        progress_callback: ProgressCallback | None = None,\n    ) -&gt; None:\n        self.config = config\n        self.progress_callback = progress_callback\n\n        # Configure logging\n        log_level = logging.DEBUG if config.verbose else logging.INFO\n        logging.basicConfig(\n            level=log_level,\n            format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n        )\n\n    def _report_progress(self, stage: str, current: int, total: int, message: str) -&gt; None:\n        \"\"\"Report progress if callback is configured.\"\"\"\n        if self.progress_callback:\n            self.progress_callback(stage, current, total, message)\n\n    def convert(self) -&gt; Path:\n        \"\"\"Execute the FITS to Zarr conversion.\n\n        Returns\n        -------\n        Path\n            Path to the output Zarr store.\n\n        Raises\n        ------\n        FileNotFoundError\n            If no matching FITS files are found.\n        RuntimeError\n            If conversion fails or another process is writing to the same output.\n        \"\"\"\n        # Validate configuration\n        self.config.validate()\n\n        # Create output directory\n        self.config.output_dir.mkdir(parents=True, exist_ok=True)\n\n        # Acquire lock to prevent concurrent writes\n        lock_path = self.config.output_dir / f\".{self.config.zarr_name}.lock\"\n\n        with FileLock(lock_path):\n            logger.info(\"Starting FITS to Zarr conversion\")\n            logger.info(f\"  Input: {self.config.input_dir}\")\n            logger.info(f\"  Output: {self.config.zarr_path}\")\n            logger.info(f\"  Mode: {'rebuild' if self.config.rebuild else 'append'}\")\n\n            self._report_progress(\"start\", 0, 1, \"Starting conversion\")\n\n            try:\n                result = convert_fits_dir_to_zarr(\n                    input_dir=self.config.input_dir,\n                    out_dir=self.config.output_dir,\n                    zarr_name=self.config.zarr_name,\n                    fixed_dir=self.config.fixed_dir,\n                    chunk_lm=self.config.chunk_lm,\n                    rebuild=self.config.rebuild,\n                    fix_headers_on_demand=self.config.fix_headers_on_demand,\n                    progress_callback=self.progress_callback,\n                )\n\n                self._report_progress(\"complete\", 1, 1, \"Conversion complete\")\n                logger.info(f\"Conversion successful: {result}\")\n                return result\n\n            except FileNotFoundError as e:\n                logger.error(f\"No matching FITS files found in {self.config.input_dir}\")\n                self._report_progress(\"error\", 0, 1, f\"Error: {e}\")\n                raise\n            except RuntimeError as e:\n                logger.error(f\"Conversion failed: {e}\")\n                self._report_progress(\"error\", 0, 1, f\"Error: {e}\")\n                raise\n            except Exception as e:\n                logger.exception(\"Unexpected error during conversion\")\n                self._report_progress(\"error\", 0, 1, f\"Unexpected error: {e}\")\n                raise RuntimeError(f\"Conversion failed: {e}\") from e\n</code></pre>"},{"location":"api/ingest/#ovro_lwa_portal.ingest.FITSToZarrConverter.convert","title":"<code>convert()</code>","text":"<p>Execute the FITS to Zarr conversion.</p> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the output Zarr store.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If no matching FITS files are found.</p> <code>RuntimeError</code> <p>If conversion fails or another process is writing to the same output.</p> Source code in <code>src/ovro_lwa_portal/ingest/core.py</code> <pre><code>def convert(self) -&gt; Path:\n    \"\"\"Execute the FITS to Zarr conversion.\n\n    Returns\n    -------\n    Path\n        Path to the output Zarr store.\n\n    Raises\n    ------\n    FileNotFoundError\n        If no matching FITS files are found.\n    RuntimeError\n        If conversion fails or another process is writing to the same output.\n    \"\"\"\n    # Validate configuration\n    self.config.validate()\n\n    # Create output directory\n    self.config.output_dir.mkdir(parents=True, exist_ok=True)\n\n    # Acquire lock to prevent concurrent writes\n    lock_path = self.config.output_dir / f\".{self.config.zarr_name}.lock\"\n\n    with FileLock(lock_path):\n        logger.info(\"Starting FITS to Zarr conversion\")\n        logger.info(f\"  Input: {self.config.input_dir}\")\n        logger.info(f\"  Output: {self.config.zarr_path}\")\n        logger.info(f\"  Mode: {'rebuild' if self.config.rebuild else 'append'}\")\n\n        self._report_progress(\"start\", 0, 1, \"Starting conversion\")\n\n        try:\n            result = convert_fits_dir_to_zarr(\n                input_dir=self.config.input_dir,\n                out_dir=self.config.output_dir,\n                zarr_name=self.config.zarr_name,\n                fixed_dir=self.config.fixed_dir,\n                chunk_lm=self.config.chunk_lm,\n                rebuild=self.config.rebuild,\n                fix_headers_on_demand=self.config.fix_headers_on_demand,\n                progress_callback=self.progress_callback,\n            )\n\n            self._report_progress(\"complete\", 1, 1, \"Conversion complete\")\n            logger.info(f\"Conversion successful: {result}\")\n            return result\n\n        except FileNotFoundError as e:\n            logger.error(f\"No matching FITS files found in {self.config.input_dir}\")\n            self._report_progress(\"error\", 0, 1, f\"Error: {e}\")\n            raise\n        except RuntimeError as e:\n            logger.error(f\"Conversion failed: {e}\")\n            self._report_progress(\"error\", 0, 1, f\"Error: {e}\")\n            raise\n        except Exception as e:\n            logger.exception(\"Unexpected error during conversion\")\n            self._report_progress(\"error\", 0, 1, f\"Unexpected error: {e}\")\n            raise RuntimeError(f\"Conversion failed: {e}\") from e\n</code></pre>"},{"location":"api/ingest/#conversionconfig","title":"ConversionConfig","text":""},{"location":"api/ingest/#ovro_lwa_portal.ingest.ConversionConfig","title":"<code>ConversionConfig</code>","text":"<p>Configuration for FITS to Zarr conversion.</p> <p>Parameters:</p> Name Type Description Default <code>input_dir</code> <code>Path</code> <p>Directory containing input FITS files.</p> required <code>output_dir</code> <code>Path</code> <p>Directory where the Zarr store will be written.</p> required <code>zarr_name</code> <code>str</code> <p>Name of the output Zarr store. Defaults to \"ovro_lwa_full_lm_only.zarr\".</p> <code>'ovro_lwa_full_lm_only.zarr'</code> <code>fixed_dir</code> <code>Path | None</code> <p>Directory for storing fixed FITS files. If None, creates a \"fixed_fits\" subdirectory in output_dir.</p> <code>None</code> <code>chunk_lm</code> <code>int</code> <p>Chunk size for l and m spatial dimensions. Defaults to 1024.</p> <code>1024</code> <code>rebuild</code> <code>bool</code> <p>If True, overwrite existing Zarr store. If False, append new data. Defaults to False.</p> <code>False</code> <code>fix_headers_on_demand</code> <code>bool</code> <p>If True, fix headers during conversion if they don't exist. If False, assume headers are already fixed. Defaults to True.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>Enable verbose logging. Defaults to False.</p> <code>False</code> Source code in <code>src/ovro_lwa_portal/ingest/core.py</code> <pre><code>class ConversionConfig:\n    \"\"\"Configuration for FITS to Zarr conversion.\n\n    Parameters\n    ----------\n    input_dir : Path\n        Directory containing input FITS files.\n    output_dir : Path\n        Directory where the Zarr store will be written.\n    zarr_name : str, optional\n        Name of the output Zarr store. Defaults to \"ovro_lwa_full_lm_only.zarr\".\n    fixed_dir : Path | None, optional\n        Directory for storing fixed FITS files. If None, creates a \"fixed_fits\"\n        subdirectory in output_dir.\n    chunk_lm : int, optional\n        Chunk size for l and m spatial dimensions. Defaults to 1024.\n    rebuild : bool, optional\n        If True, overwrite existing Zarr store. If False, append new data. Defaults to False.\n    fix_headers_on_demand : bool, optional\n        If True, fix headers during conversion if they don't exist. If False, assume\n        headers are already fixed. Defaults to True.\n    verbose : bool, optional\n        Enable verbose logging. Defaults to False.\n    \"\"\"\n\n    def __init__(\n        self,\n        input_dir: Path,\n        output_dir: Path,\n        zarr_name: str = \"ovro_lwa_full_lm_only.zarr\",\n        fixed_dir: Path | None = None,\n        chunk_lm: int = 1024,\n        rebuild: bool = False,\n        fix_headers_on_demand: bool = True,\n        verbose: bool = False,\n    ) -&gt; None:\n        self.input_dir = input_dir\n        self.output_dir = output_dir\n        self.zarr_name = zarr_name\n        self.fixed_dir = fixed_dir or (output_dir / \"fixed_fits\")\n        self.chunk_lm = chunk_lm\n        self.rebuild = rebuild\n        self.fix_headers_on_demand = fix_headers_on_demand\n        self.verbose = verbose\n\n    @property\n    def zarr_path(self) -&gt; Path:\n        \"\"\"Full path to the output Zarr store.\"\"\"\n        return self.output_dir / self.zarr_name\n\n    def validate(self) -&gt; None:\n        \"\"\"Validate configuration parameters.\n\n        Raises\n        ------\n        FileNotFoundError\n            If input directory doesn't exist.\n        ValueError\n            If parameters are invalid.\n        \"\"\"\n        if not self.input_dir.exists():\n            msg = f\"Input directory does not exist: {self.input_dir}\"\n            raise FileNotFoundError(msg)\n\n        if not self.input_dir.is_dir():\n            msg = f\"Input path is not a directory: {self.input_dir}\"\n            raise ValueError(msg)\n\n        if self.chunk_lm &lt; 0:\n            msg = f\"chunk_lm must be non-negative, got {self.chunk_lm}\"\n            raise ValueError(msg)\n</code></pre>"},{"location":"api/ingest/#ovro_lwa_portal.ingest.ConversionConfig.zarr_path","title":"<code>zarr_path</code>  <code>property</code>","text":"<p>Full path to the output Zarr store.</p>"},{"location":"api/ingest/#ovro_lwa_portal.ingest.ConversionConfig.validate","title":"<code>validate()</code>","text":"<p>Validate configuration parameters.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If input directory doesn't exist.</p> <code>ValueError</code> <p>If parameters are invalid.</p> Source code in <code>src/ovro_lwa_portal/ingest/core.py</code> <pre><code>def validate(self) -&gt; None:\n    \"\"\"Validate configuration parameters.\n\n    Raises\n    ------\n    FileNotFoundError\n        If input directory doesn't exist.\n    ValueError\n        If parameters are invalid.\n    \"\"\"\n    if not self.input_dir.exists():\n        msg = f\"Input directory does not exist: {self.input_dir}\"\n        raise FileNotFoundError(msg)\n\n    if not self.input_dir.is_dir():\n        msg = f\"Input path is not a directory: {self.input_dir}\"\n        raise ValueError(msg)\n\n    if self.chunk_lm &lt; 0:\n        msg = f\"chunk_lm must be non-negative, got {self.chunk_lm}\"\n        raise ValueError(msg)\n</code></pre>"},{"location":"api/ingest/#progresscallback","title":"ProgressCallback","text":""},{"location":"api/ingest/#ovro_lwa_portal.ingest.ProgressCallback","title":"<code>ProgressCallback</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for progress reporting callbacks.</p> Source code in <code>src/ovro_lwa_portal/ingest/core.py</code> <pre><code>class ProgressCallback(Protocol):\n    \"\"\"Protocol for progress reporting callbacks.\"\"\"\n\n    def __call__(self, stage: str, current: int, total: int, message: str) -&gt; None:\n        \"\"\"Report progress to the caller.\n\n        Parameters\n        ----------\n        stage : str\n            The current stage of conversion (e.g., 'discovery', 'fixing', 'combining').\n        current : int\n            Current progress count.\n        total : int\n            Total items to process.\n        message : str\n            Human-readable progress message.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/ingest/#ovro_lwa_portal.ingest.ProgressCallback.__call__","title":"<code>__call__(stage, current, total, message)</code>","text":"<p>Report progress to the caller.</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>str</code> <p>The current stage of conversion (e.g., 'discovery', 'fixing', 'combining').</p> required <code>current</code> <code>int</code> <p>Current progress count.</p> required <code>total</code> <code>int</code> <p>Total items to process.</p> required <code>message</code> <code>str</code> <p>Human-readable progress message.</p> required Source code in <code>src/ovro_lwa_portal/ingest/core.py</code> <pre><code>def __call__(self, stage: str, current: int, total: int, message: str) -&gt; None:\n    \"\"\"Report progress to the caller.\n\n    Parameters\n    ----------\n    stage : str\n        The current stage of conversion (e.g., 'discovery', 'fixing', 'combining').\n    current : int\n        Current progress count.\n    total : int\n        Total items to process.\n    message : str\n        Human-readable progress message.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/ingest/#optional-prefect-integration","title":"Optional Prefect Integration","text":"<p>For orchestrated workflows, the package includes optional Prefect-based workflow orchestration with automatic retries, logging, and monitoring.</p>"},{"location":"api/ingest/#installation","title":"Installation","text":"<pre><code>pip install 'ovro_lwa_portal[prefect]'\n</code></pre>"},{"location":"api/ingest/#usage","title":"Usage","text":"<pre><code>from ovro_lwa_portal.ingest.prefect_workflow import run_conversion_flow\n\nresult = run_conversion_flow(\n    input_dir=\"/data/fits\",\n    output_dir=\"/data/output\",\n    rebuild=False,\n)\n</code></pre>"},{"location":"api/ingest/#run_conversion_flow","title":"run_conversion_flow","text":""},{"location":"api/ingest/#ovro_lwa_portal.ingest.prefect_workflow.run_conversion_flow","title":"<code>run_conversion_flow(input_dir, output_dir, zarr_name='ovro_lwa_full_lm_only.zarr', fixed_dir=None, chunk_lm=1024, rebuild=False, verbose=False)</code>","text":"<p>Run the FITS to Zarr conversion using Prefect orchestration.</p> <p>This is a convenience wrapper around the Prefect flow that checks for Prefect availability and provides helpful error messages.</p> <p>Parameters:</p> Name Type Description Default <code>input_dir</code> <code>str | Path</code> <p>Directory containing input FITS files.</p> required <code>output_dir</code> <code>str | Path</code> <p>Directory where the Zarr store will be written.</p> required <code>zarr_name</code> <code>str</code> <p>Name of the output Zarr store.</p> <code>'ovro_lwa_full_lm_only.zarr'</code> <code>fixed_dir</code> <code>str | Path | None</code> <p>Directory for storing fixed FITS files.</p> <code>None</code> <code>chunk_lm</code> <code>int</code> <p>Chunk size for l and m spatial dimensions.</p> <code>1024</code> <code>rebuild</code> <code>bool</code> <p>If True, overwrite existing Zarr store.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>Enable verbose logging.</p> <code>False</code> <p>Returns:</p> Type Description <code>Path</code> <p>Path to the output Zarr store.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If Prefect is not installed.</p> Source code in <code>src/ovro_lwa_portal/ingest/prefect_workflow.py</code> <pre><code>def run_conversion_flow(\n    input_dir: str | Path,\n    output_dir: str | Path,\n    zarr_name: str = \"ovro_lwa_full_lm_only.zarr\",\n    fixed_dir: str | Path | None = None,\n    chunk_lm: int = 1024,\n    rebuild: bool = False,\n    verbose: bool = False,\n) -&gt; Path:\n    \"\"\"Run the FITS to Zarr conversion using Prefect orchestration.\n\n    This is a convenience wrapper around the Prefect flow that checks for\n    Prefect availability and provides helpful error messages.\n\n    Parameters\n    ----------\n    input_dir : str | Path\n        Directory containing input FITS files.\n    output_dir : str | Path\n        Directory where the Zarr store will be written.\n    zarr_name : str, optional\n        Name of the output Zarr store.\n    fixed_dir : str | Path | None, optional\n        Directory for storing fixed FITS files.\n    chunk_lm : int, optional\n        Chunk size for l and m spatial dimensions.\n    rebuild : bool, optional\n        If True, overwrite existing Zarr store.\n    verbose : bool, optional\n        Enable verbose logging.\n\n    Returns\n    -------\n    Path\n        Path to the output Zarr store.\n\n    Raises\n    ------\n    ImportError\n        If Prefect is not installed.\n    \"\"\"\n    if not PREFECT_AVAILABLE:\n        msg = (\n            \"Prefect is not installed. Install it with:\\n\"\n            \"  pip install 'ovro_lwa_portal[prefect]'\\n\"\n            \"or use the core conversion API directly:\\n\"\n            \"  from ovro_lwa_portal.ingest import FITSToZarrConverter\"\n        )\n        raise ImportError(msg)\n\n    return fits_to_zarr_flow(\n        input_dir=input_dir,\n        output_dir=output_dir,\n        zarr_name=zarr_name,\n        fixed_dir=fixed_dir,\n        chunk_lm=chunk_lm,\n        rebuild=rebuild,\n        verbose=verbose,\n    )\n</code></pre>"},{"location":"api/ingest/#fits_to_zarr_flow","title":"fits_to_zarr_flow","text":"<p><code>fits_to_zarr_flow</code> is the underlying Prefect <code>@flow</code>-decorated function called by <code>run_conversion_flow</code>. It accepts the same parameters (<code>input_dir</code>, <code>output_dir</code>, <code>zarr_name</code>, <code>fixed_dir</code>, <code>chunk_lm</code>, <code>rebuild</code>, <code>verbose</code>) and orchestrates three Prefect tasks in sequence: configuration validation, directory preparation, and the conversion itself (with automatic retries).</p> <p>Note</p> <p><code>fits_to_zarr_flow</code> is conditionally defined depending on whether Prefect is installed. Use <code>run_conversion_flow</code> as the stable entry point \u2014 it checks for Prefect availability and provides a clear error message if it is missing.</p>"},{"location":"api/radport-accessor/","title":"radport Accessor","text":"<p>The <code>radport</code> accessor extends <code>xarray.Dataset</code> with domain-specific methods for OVRO-LWA radio astronomy data analysis and visualization.</p>"},{"location":"api/radport-accessor/#usage","title":"Usage","text":"<p>The accessor becomes available on any <code>xarray.Dataset</code> after importing <code>ovro_lwa_portal</code>:</p> <pre><code>import ovro_lwa_portal\n\nds = ovro_lwa_portal.open_dataset(\"path/to/data.zarr\")\nds.radport.plot()  # accessor is now available\n</code></pre> <p>The dataset must contain the required dimensions (<code>time</code>, <code>frequency</code>, <code>polarization</code>, <code>l</code>, <code>m</code>) and the <code>SKY</code> data variable. An optional <code>BEAM</code> variable enables beam-related functionality.</p>"},{"location":"api/radport-accessor/#method-categories","title":"Method Categories","text":"Category Methods Selection <code>nearest_freq_idx</code>, <code>nearest_time_idx</code>, <code>nearest_lm_idx</code> Basic Plotting <code>plot</code>, <code>cutout</code>, <code>plot_cutout</code> Dynamic Spectrum <code>dynamic_spectrum</code>, <code>plot_dynamic_spectrum</code> Difference Maps <code>diff</code>, <code>plot_diff</code> Data Quality <code>find_valid_frame</code>, <code>finite_fraction</code> Grid Plots <code>plot_grid</code>, <code>plot_frequency_grid</code>, <code>plot_time_grid</code> Light Curves <code>light_curve</code>, <code>plot_light_curve</code> Spectra <code>spectrum</code>, <code>plot_spectrum</code> Averaging <code>time_average</code>, <code>frequency_average</code>, <code>plot_time_average</code>, <code>plot_frequency_average</code> WCS Coordinates <code>has_wcs</code>, <code>pixel_to_coords</code>, <code>coords_to_pixel</code>, <code>plot_wcs</code> Animation <code>animate_time</code>, <code>animate_frequency</code>, <code>export_frames</code> Source Detection <code>rms_map</code>, <code>snr_map</code>, <code>find_peaks</code>, <code>peak_flux_map</code>, <code>plot_snr_map</code> Spectral Analysis <code>spectral_index</code>, <code>spectral_index_map</code>, <code>integrated_flux</code>, <code>plot_spectral_index_map</code>"},{"location":"api/radport-accessor/#full-api-reference","title":"Full API Reference","text":""},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor","title":"<code>RadportAccessor</code>","text":"<p>xarray accessor for OVRO-LWA radio astronomy datasets.</p> <p>This accessor provides domain-specific methods for working with OVRO-LWA data, including visualization and validation utilities.</p> <p>The accessor is automatically available on any xarray Dataset after importing the <code>ovro_lwa_portal</code> package.</p> <p>Parameters:</p> Name Type Description Default <code>xarray_obj</code> <code>Dataset</code> <p>The xarray Dataset to extend with accessor methods.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dataset is missing required dimensions or variables for OVRO-LWA data.</p> Example <p>import ovro_lwa_portal from ovro_lwa_portal import open_dataset ds = open_dataset(\"path/to/data.zarr\") ds.radport.plot()</p> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>@xr.register_dataset_accessor(\"radport\")\nclass RadportAccessor:\n    \"\"\"xarray accessor for OVRO-LWA radio astronomy datasets.\n\n    This accessor provides domain-specific methods for working with\n    OVRO-LWA data, including visualization and validation utilities.\n\n    The accessor is automatically available on any xarray Dataset after\n    importing the `ovro_lwa_portal` package.\n\n    Parameters\n    ----------\n    xarray_obj : xr.Dataset\n        The xarray Dataset to extend with accessor methods.\n\n    Raises\n    ------\n    ValueError\n        If the dataset is missing required dimensions or variables\n        for OVRO-LWA data.\n\n    Example\n    -------\n    &gt;&gt;&gt; import ovro_lwa_portal\n    &gt;&gt;&gt; from ovro_lwa_portal import open_dataset\n    &gt;&gt;&gt; ds = open_dataset(\"path/to/data.zarr\")\n    &gt;&gt;&gt; ds.radport.plot()\n    \"\"\"\n\n    # Required dimensions for OVRO-LWA datasets\n    _required_dims: frozenset[str] = frozenset(\n        {\"time\", \"frequency\", \"polarization\", \"l\", \"m\"}\n    )\n\n    # Required data variables\n    _required_vars: frozenset[str] = frozenset({\"SKY\"})\n\n    # Optional data variables\n    _optional_vars: frozenset[str] = frozenset({\"BEAM\"})\n\n    def __init__(self, xarray_obj: xr.Dataset) -&gt; None:\n        \"\"\"Initialize the RadportAccessor.\n\n        Parameters\n        ----------\n        xarray_obj : xr.Dataset\n            The xarray Dataset to extend.\n\n        Raises\n        ------\n        ValueError\n            If the dataset structure is invalid for OVRO-LWA data.\n        \"\"\"\n        self._obj = xarray_obj\n        self._validate_structure()\n\n    def _validate_structure(self) -&gt; None:\n        \"\"\"Validate that the dataset has required dimensions and variables.\n\n        Raises\n        ------\n        ValueError\n            If required dimensions or variables are missing, with an\n            informative error message listing what is missing.\n        \"\"\"\n        # Check for required dimensions\n        missing_dims = self._required_dims - set(self._obj.dims)\n        if missing_dims:\n            raise ValueError(\n                f\"Dataset is missing required dimensions for OVRO-LWA data: \"\n                f\"{sorted(missing_dims)}. \"\n                f\"Expected dimensions: {sorted(self._required_dims)}. \"\n                f\"Found dimensions: {sorted(self._obj.dims)}.\"\n            )\n\n        # Check for required data variables\n        missing_vars = self._required_vars - set(self._obj.data_vars)\n        if missing_vars:\n            raise ValueError(\n                f\"Dataset is missing required variables for OVRO-LWA data: \"\n                f\"{sorted(missing_vars)}. \"\n                f\"Expected variables: {sorted(self._required_vars)}. \"\n                f\"Found variables: {sorted(self._obj.data_vars)}.\"\n            )\n\n    @property\n    def has_beam(self) -&gt; bool:\n        \"\"\"Check if the dataset contains BEAM data.\n\n        Returns\n        -------\n        bool\n            True if the dataset contains a BEAM variable.\n        \"\"\"\n        return \"BEAM\" in self._obj.data_vars\n\n    # =========================================================================\n    # Selection Helper Methods\n    # =========================================================================\n\n    def nearest_freq_idx(self, freq_mhz: float) -&gt; int:\n        \"\"\"Find the index of the frequency nearest to the given value in MHz.\n\n        Parameters\n        ----------\n        freq_mhz : float\n            Target frequency in MHz.\n\n        Returns\n        -------\n        int\n            Index of the nearest frequency in the dataset.\n\n        Examples\n        --------\n        &gt;&gt;&gt; idx = ds.radport.nearest_freq_idx(50.0)  # Find index nearest to 50 MHz\n        &gt;&gt;&gt; ds.radport.plot(freq_idx=idx)\n        \"\"\"\n        freq_hz = freq_mhz * 1e6\n        freq_values = self._obj.coords[\"frequency\"].values\n        return int(np.argmin(np.abs(freq_values - freq_hz)))\n\n    def nearest_time_idx(self, mjd: float) -&gt; int:\n        \"\"\"Find the index of the time nearest to the given MJD value.\n\n        Parameters\n        ----------\n        mjd : float\n            Target time in Modified Julian Date (MJD).\n\n        Returns\n        -------\n        int\n            Index of the nearest time in the dataset.\n\n        Examples\n        --------\n        &gt;&gt;&gt; idx = ds.radport.nearest_time_idx(60000.5)  # Find index nearest to MJD\n        &gt;&gt;&gt; ds.radport.plot(time_idx=idx)\n        \"\"\"\n        time_values = self._obj.coords[\"time\"].values\n        return int(np.argmin(np.abs(time_values - mjd)))\n\n    def nearest_lm_idx(self, l: float, m: float) -&gt; tuple[int, int]:\n        \"\"\"Find the indices of the (l, m) pixel nearest to the given coordinates.\n\n        Parameters\n        ----------\n        l : float\n            Target l direction cosine coordinate.\n        m : float\n            Target m direction cosine coordinate.\n\n        Returns\n        -------\n        tuple of int\n            (l_idx, m_idx) indices of the nearest pixel.\n\n        Examples\n        --------\n        &gt;&gt;&gt; l_idx, m_idx = ds.radport.nearest_lm_idx(0.0, 0.0)  # Find center pixel\n        \"\"\"\n        l_values = self._obj.coords[\"l\"].values\n        m_values = self._obj.coords[\"m\"].values\n        l_idx = int(np.argmin(np.abs(l_values - l)))\n        m_idx = int(np.argmin(np.abs(m_values - m)))\n        return l_idx, m_idx\n\n    # =========================================================================\n    # Plotting Methods\n    # =========================================================================\n\n    def plot(\n        self,\n        var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n        time_idx: int | None = None,\n        freq_idx: int | None = None,\n        pol: int = 0,\n        freq_mhz: float | None = None,\n        time_mjd: float | None = None,\n        cmap: str = \"inferno\",\n        vmin: float | None = None,\n        vmax: float | None = None,\n        robust: bool = False,\n        mask_radius: int | None = None,\n        figsize: tuple[float, float] = (8, 6),\n        add_colorbar: bool = True,\n        **kwargs: Any,\n    ) -&gt; Figure:\n        \"\"\"Create a visualization of radio data as a 2D image.\n\n        Plots a single snapshot of the data at the specified time, frequency,\n        and polarization indices. The resulting image shows intensity values\n        in the (l, m) direction cosine coordinate system.\n\n        Parameters\n        ----------\n        var : {'SKY', 'BEAM'}, default 'SKY'\n            Data variable to plot. Use 'BEAM' only if the dataset contains\n            beam data (check with `ds.radport.has_beam`).\n        time_idx : int, optional\n            Index along the time dimension for the snapshot. Default is 0.\n            Ignored if `time_mjd` is provided.\n        freq_idx : int, optional\n            Index along the frequency dimension for the snapshot. Default is 0.\n            Ignored if `freq_mhz` is provided.\n        pol : int, default 0\n            Index along the polarization dimension.\n        freq_mhz : float, optional\n            Select frequency by value in MHz. If provided, overrides `freq_idx`.\n            Uses the nearest available frequency.\n        time_mjd : float, optional\n            Select time by MJD value. If provided, overrides `time_idx`.\n            Uses the nearest available time.\n        cmap : str, default 'inferno'\n            Matplotlib colormap name for the image.\n        vmin : float, optional\n            Minimum value for the color scale. If None and robust=False,\n            uses the data minimum.\n        vmax : float, optional\n            Maximum value for the color scale. If None and robust=False,\n            uses the data maximum.\n        robust : bool, default False\n            If True, compute vmin/vmax using the 2nd and 98th percentiles\n            of the data, which is useful for data with outliers.\n        mask_radius : int, optional\n            If provided, mask pixels outside this radius (in pixels) from\n            the image center. Useful for all-sky images where edge pixels\n            are invalid. Masked pixels are shown as NaN (transparent).\n        figsize : tuple of float, default (8, 6)\n            Figure size in inches as (width, height).\n        add_colorbar : bool, default True\n            Whether to add a colorbar to the plot.\n        **kwargs : dict\n            Additional keyword arguments passed to `matplotlib.pyplot.imshow`.\n\n        Returns\n        -------\n        matplotlib.figure.Figure\n            The matplotlib Figure object containing the plot.\n\n        Raises\n        ------\n        ValueError\n            If the requested variable does not exist in the dataset.\n\n        Examples\n        --------\n        &gt;&gt;&gt; import ovro_lwa_portal\n        &gt;&gt;&gt; ds = ovro_lwa_portal.open_dataset(\"path/to/data.zarr\")\n\n        Plot with default settings (first time, frequency, polarization):\n\n        &gt;&gt;&gt; fig = ds.radport.plot()\n\n        Plot a specific time and frequency with custom colormap:\n\n        &gt;&gt;&gt; fig = ds.radport.plot(time_idx=5, freq_idx=10, cmap='viridis')\n\n        Plot by selecting frequency in MHz (more intuitive):\n\n        &gt;&gt;&gt; fig = ds.radport.plot(freq_mhz=50.0)\n\n        Plot with fixed color scale:\n\n        &gt;&gt;&gt; fig = ds.radport.plot(vmin=-1.0, vmax=16.0)\n\n        Plot with robust color scaling for data with outliers:\n\n        &gt;&gt;&gt; fig = ds.radport.plot(robust=True)\n\n        Plot with circular mask to hide invalid edge pixels:\n\n        &gt;&gt;&gt; fig = ds.radport.plot(mask_radius=1800)\n        \"\"\"\n        # Validate the requested variable exists\n        if var not in self._obj.data_vars:\n            available = sorted(self._obj.data_vars)\n            msg = f\"Variable '{var}' not found in dataset. Available variables: {available}\"\n            raise ValueError(msg)\n\n        # Resolve frequency selection: freq_mhz takes precedence over freq_idx\n        if freq_mhz is not None:\n            freq_idx = self.nearest_freq_idx(freq_mhz)\n        elif freq_idx is None:\n            freq_idx = 0\n\n        # Resolve time selection: time_mjd takes precedence over time_idx\n        if time_mjd is not None:\n            time_idx = self.nearest_time_idx(time_mjd)\n        elif time_idx is None:\n            time_idx = 0\n\n        # Extract the 2D slice for plotting\n        da = self._obj[var].isel(\n            time=time_idx,\n            frequency=freq_idx,\n            polarization=pol,\n        )\n\n        # Build title with metadata\n        title = self._build_plot_title(var, time_idx, freq_idx, pol)\n\n        # Create figure and axis\n        fig, ax = plt.subplots(figsize=figsize)\n\n        # Compute data for plotting (triggers dask computation if needed)\n        data = da.values.copy()  # Copy to allow modification for masking\n\n        # Apply circular mask if requested\n        if mask_radius is not None:\n            ny, nx = data.shape\n            cy, cx = ny // 2, nx // 2\n            yy, xx = np.ogrid[:ny, :nx]\n            distance_from_center = np.sqrt((yy - cy) ** 2 + (xx - cx) ** 2)\n            data[distance_from_center &gt; mask_radius] = np.nan\n\n        # Handle robust scaling (after masking, so we only consider valid pixels)\n        if robust and vmin is None and vmax is None:\n            finite_data = data[np.isfinite(data)]\n            if finite_data.size &gt; 0:\n                vmin = float(np.percentile(finite_data, 2))\n                vmax = float(np.percentile(finite_data, 98))\n\n        # Get coordinate extents for proper axis labeling\n        l_vals = da.coords[\"l\"].values\n        m_vals = da.coords[\"m\"].values\n        extent = [float(l_vals.min()), float(l_vals.max()),\n                  float(m_vals.min()), float(m_vals.max())]\n\n        # Plot the image\n        im = ax.imshow(\n            data,\n            origin=\"lower\",\n            cmap=cmap,\n            vmin=vmin,\n            vmax=vmax,\n            extent=extent,\n            aspect=\"equal\",\n            **kwargs,\n        )\n\n        # Add colorbar\n        if add_colorbar:\n            cbar = fig.colorbar(im, ax=ax)\n            cbar.set_label(\"Jy/beam\")\n\n        # Set labels and title\n        ax.set_xlabel(\"l (direction cosine)\")\n        ax.set_ylabel(\"m (direction cosine)\")\n        ax.set_title(title)\n\n        fig.tight_layout()\n\n        return fig\n\n    def _build_plot_title(\n        self,\n        var: str,\n        time_idx: int,\n        freq_idx: int,\n        pol: int,\n    ) -&gt; str:\n        \"\"\"Build an informative title for the plot.\n\n        Parameters\n        ----------\n        var : str\n            The variable being plotted.\n        time_idx : int\n            Time index.\n        freq_idx : int\n            Frequency index.\n        pol : int\n            Polarization index.\n\n        Returns\n        -------\n        str\n            Formatted title string.\n        \"\"\"\n        # Get time value\n        time_val = self._obj.coords[\"time\"].values[time_idx]\n        try:\n            time_str = f\"{float(time_val):.6f} MJD\"\n        except (TypeError, ValueError):\n            time_str = str(time_val)\n\n        # Get frequency value in MHz\n        freq_val = self._obj.coords[\"frequency\"].values[freq_idx]\n        freq_mhz = float(freq_val) / 1e6\n\n        return f\"{var}: t={time_str}, f={freq_mhz:.2f} MHz, pol={pol}\"\n\n    # =========================================================================\n    # Spatial Cutout Methods\n    # =========================================================================\n\n    def cutout(\n        self,\n        l_center: float,\n        m_center: float,\n        dl: float,\n        dm: float,\n        var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n        time_idx: int | None = None,\n        freq_idx: int | None = None,\n        pol: int = 0,\n        freq_mhz: float | None = None,\n        time_mjd: float | None = None,\n    ) -&gt; xr.DataArray:\n        \"\"\"Extract a spatial cutout (rectangular region) from the data.\n\n        Returns a 2D DataArray containing data within the specified (l, m)\n        bounding box for a given time, frequency, and polarization.\n\n        Parameters\n        ----------\n        l_center : float\n            Center l coordinate of the cutout region.\n        m_center : float\n            Center m coordinate of the cutout region.\n        dl : float\n            Half-width of the cutout in the l direction.\n            The cutout spans [l_center - dl, l_center + dl].\n        dm : float\n            Half-width of the cutout in the m direction.\n            The cutout spans [m_center - dm, m_center + dm].\n        var : {'SKY', 'BEAM'}, default 'SKY'\n            Data variable to extract.\n        time_idx : int, optional\n            Time index. Default is 0. Ignored if `time_mjd` is provided.\n        freq_idx : int, optional\n            Frequency index. Default is 0. Ignored if `freq_mhz` is provided.\n        pol : int, default 0\n            Polarization index.\n        freq_mhz : float, optional\n            Select frequency by value in MHz (overrides `freq_idx`).\n        time_mjd : float, optional\n            Select time by MJD value (overrides `time_idx`).\n\n        Returns\n        -------\n        xr.DataArray\n            2D DataArray with dimensions (l, m) containing the cutout data.\n            Includes metadata attributes: cutout_l_center, cutout_m_center,\n            cutout_dl, cutout_dm.\n\n        Raises\n        ------\n        ValueError\n            If the requested variable does not exist or cutout is empty.\n\n        Examples\n        --------\n        &gt;&gt;&gt; # Extract 0.2 x 0.2 region centered at (0, 0)\n        &gt;&gt;&gt; cutout = ds.radport.cutout(l_center=0.0, m_center=0.0, dl=0.1, dm=0.1)\n\n        &gt;&gt;&gt; # Extract at specific frequency\n        &gt;&gt;&gt; cutout = ds.radport.cutout(0.0, 0.0, 0.1, 0.1, freq_mhz=50.0)\n\n        &gt;&gt;&gt; # Plot the cutout\n        &gt;&gt;&gt; cutout.plot()\n        \"\"\"\n        # Validate variable\n        if var not in self._obj.data_vars:\n            available = sorted(self._obj.data_vars)\n            raise ValueError(\n                f\"Variable '{var}' not found. Available: {available}\"\n            )\n\n        # Resolve indices\n        if freq_mhz is not None:\n            freq_idx = self.nearest_freq_idx(freq_mhz)\n        elif freq_idx is None:\n            freq_idx = 0\n\n        if time_mjd is not None:\n            time_idx = self.nearest_time_idx(time_mjd)\n        elif time_idx is None:\n            time_idx = 0\n\n        # Extract 2D slice\n        da = self._obj[var].isel(\n            time=time_idx,\n            frequency=freq_idx,\n            polarization=pol,\n        )\n\n        # Compute l/m bounds\n        l_min, l_max = l_center - dl, l_center + dl\n        m_min, m_max = m_center - dm, m_center + dm\n\n        # Handle coordinate ordering (ascending or descending)\n        l_coords = da.coords[\"l\"]\n        m_coords = da.coords[\"m\"]\n\n        # Determine slice direction based on coordinate ordering\n        if float(l_coords[0]) &lt;= float(l_coords[-1]):\n            l_slice = slice(l_min, l_max)\n        else:\n            l_slice = slice(l_max, l_min)\n\n        if float(m_coords[0]) &lt;= float(m_coords[-1]):\n            m_slice = slice(m_min, m_max)\n        else:\n            m_slice = slice(m_max, m_min)\n\n        # Select the cutout region\n        cutout = da.sel(l=l_slice, m=m_slice)\n\n        # Check if cutout is empty\n        if cutout.size == 0:\n            raise ValueError(\n                f\"Cutout region is empty. Requested l=[{l_min:.3f}, {l_max:.3f}], \"\n                f\"m=[{m_min:.3f}, {m_max:.3f}]. \"\n                f\"Dataset l range: [{float(l_coords.min()):.3f}, {float(l_coords.max()):.3f}], \"\n                f\"m range: [{float(m_coords.min()):.3f}, {float(m_coords.max()):.3f}].\"\n            )\n\n        # Add metadata attributes\n        cutout.attrs[\"cutout_l_center\"] = l_center\n        cutout.attrs[\"cutout_m_center\"] = m_center\n        cutout.attrs[\"cutout_dl\"] = dl\n        cutout.attrs[\"cutout_dm\"] = dm\n        cutout.attrs[\"time_idx\"] = time_idx\n        cutout.attrs[\"freq_idx\"] = freq_idx\n        cutout.attrs[\"pol\"] = pol\n\n        return cutout\n\n    def plot_cutout(\n        self,\n        l_center: float,\n        m_center: float,\n        dl: float,\n        dm: float,\n        var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n        time_idx: int | None = None,\n        freq_idx: int | None = None,\n        pol: int = 0,\n        freq_mhz: float | None = None,\n        time_mjd: float | None = None,\n        cmap: str = \"inferno\",\n        vmin: float | None = None,\n        vmax: float | None = None,\n        robust: bool = True,\n        figsize: tuple[float, float] = (6, 5),\n        add_colorbar: bool = True,\n        **kwargs: Any,\n    ) -&gt; Figure:\n        \"\"\"Extract and plot a spatial cutout.\n\n        Convenience method that combines `cutout()` with plotting.\n\n        Parameters\n        ----------\n        l_center, m_center : float\n            Center coordinates of the cutout region.\n        dl, dm : float\n            Half-widths of the cutout in l and m directions.\n        var : {'SKY', 'BEAM'}, default 'SKY'\n            Data variable to plot.\n        time_idx : int, optional\n            Time index. Default is 0.\n        freq_idx : int, optional\n            Frequency index. Default is 0.\n        pol : int, default 0\n            Polarization index.\n        freq_mhz : float, optional\n            Select frequency by value in MHz.\n        time_mjd : float, optional\n            Select time by MJD value.\n        cmap : str, default 'inferno'\n            Matplotlib colormap.\n        vmin, vmax : float, optional\n            Color scale limits.\n        robust : bool, default True\n            Use percentile-based color scaling.\n        figsize : tuple, default (6, 5)\n            Figure size in inches.\n        add_colorbar : bool, default True\n            Whether to add a colorbar.\n        **kwargs : dict\n            Additional arguments passed to imshow.\n\n        Returns\n        -------\n        matplotlib.figure.Figure\n            The figure containing the cutout plot.\n\n        Examples\n        --------\n        &gt;&gt;&gt; fig = ds.radport.plot_cutout(0.0, 0.0, 0.1, 0.1, freq_mhz=50.0)\n        \"\"\"\n        # Get cutout data\n        cutout = self.cutout(\n            l_center=l_center,\n            m_center=m_center,\n            dl=dl,\n            dm=dm,\n            var=var,\n            time_idx=time_idx,\n            freq_idx=freq_idx,\n            pol=pol,\n            freq_mhz=freq_mhz,\n            time_mjd=time_mjd,\n        )\n\n        # Resolve actual indices for title\n        actual_time_idx = cutout.attrs[\"time_idx\"]\n        actual_freq_idx = cutout.attrs[\"freq_idx\"]\n\n        # Create figure\n        fig, ax = plt.subplots(figsize=figsize)\n\n        # Compute data\n        data = cutout.values\n\n        # Handle robust scaling\n        if robust and vmin is None and vmax is None:\n            finite_data = data[np.isfinite(data)]\n            if finite_data.size &gt; 0:\n                vmin = float(np.percentile(finite_data, 2))\n                vmax = float(np.percentile(finite_data, 98))\n\n        # Get coordinate extents\n        l_vals = cutout.coords[\"l\"].values\n        m_vals = cutout.coords[\"m\"].values\n        extent = [\n            float(l_vals.min()), float(l_vals.max()),\n            float(m_vals.min()), float(m_vals.max()),\n        ]\n\n        # Plot\n        im = ax.imshow(\n            data,\n            origin=\"lower\",\n            cmap=cmap,\n            vmin=vmin,\n            vmax=vmax,\n            extent=extent,\n            aspect=\"equal\",\n            **kwargs,\n        )\n\n        if add_colorbar:\n            cbar = fig.colorbar(im, ax=ax)\n            cbar.set_label(\"Jy/beam\")\n\n        # Build title\n        title = self._build_plot_title(var, actual_time_idx, actual_freq_idx, pol)\n        title += f\"\\nl=[{l_center-dl:+.2f},{l_center+dl:+.2f}], m=[{m_center-dm:+.2f},{m_center+dm:+.2f}]\"\n\n        ax.set_xlabel(\"l (direction cosine)\")\n        ax.set_ylabel(\"m (direction cosine)\")\n        ax.set_title(title)\n\n        fig.tight_layout()\n        return fig\n\n    # =========================================================================\n    # Dynamic Spectrum Methods\n    # =========================================================================\n\n    def dynamic_spectrum(\n        self,\n        l: float,\n        m: float,\n        var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n        pol: int = 0,\n    ) -&gt; xr.DataArray:\n        \"\"\"Extract a dynamic spectrum (time vs frequency) for a single pixel.\n\n        Returns a 2D DataArray showing how intensity varies across time\n        and frequency at the pixel nearest to the specified (l, m) location.\n\n        Parameters\n        ----------\n        l : float\n            Target l coordinate for pixel selection.\n        m : float\n            Target m coordinate for pixel selection.\n        var : {'SKY', 'BEAM'}, default 'SKY'\n            Data variable to extract.\n        pol : int, default 0\n            Polarization index.\n\n        Returns\n        -------\n        xr.DataArray\n            2D DataArray with dimensions (time, frequency).\n            Includes metadata: pixel_l, pixel_m, l_idx, m_idx, pol.\n\n        Examples\n        --------\n        &gt;&gt;&gt; # Get dynamic spectrum at image center\n        &gt;&gt;&gt; dynspec = ds.radport.dynamic_spectrum(l=0.0, m=0.0)\n\n        &gt;&gt;&gt; # Plot it\n        &gt;&gt;&gt; dynspec.plot(x='time', y='frequency')\n        \"\"\"\n        # Validate variable\n        if var not in self._obj.data_vars:\n            available = sorted(self._obj.data_vars)\n            raise ValueError(\n                f\"Variable '{var}' not found. Available: {available}\"\n            )\n\n        # Find nearest pixel\n        l_idx, m_idx = self.nearest_lm_idx(l, m)\n\n        # Extract (time, frequency) slice at this pixel\n        da = self._obj[var].isel(l=l_idx, m=m_idx, polarization=pol)\n\n        # Sort by time and frequency for consistent plotting\n        if \"time\" in da.dims:\n            da = da.sortby(\"time\")\n        if \"frequency\" in da.dims:\n            da = da.sortby(\"frequency\")\n\n        # Add metadata\n        da.attrs[\"pixel_l\"] = float(self._obj.coords[\"l\"].values[l_idx])\n        da.attrs[\"pixel_m\"] = float(self._obj.coords[\"m\"].values[m_idx])\n        da.attrs[\"l_idx\"] = l_idx\n        da.attrs[\"m_idx\"] = m_idx\n        da.attrs[\"pol\"] = pol\n\n        return da\n\n    def plot_dynamic_spectrum(\n        self,\n        l: float,\n        m: float,\n        var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n        pol: int = 0,\n        cmap: str = \"inferno\",\n        vmin: float | None = None,\n        vmax: float | None = None,\n        robust: bool = True,\n        figsize: tuple[float, float] = (8, 5),\n        add_colorbar: bool = True,\n        **kwargs: Any,\n    ) -&gt; Figure:\n        \"\"\"Plot a dynamic spectrum (time vs frequency) for a single pixel.\n\n        Creates a 2D visualization showing intensity variations across\n        time and frequency at a specified (l, m) location.\n\n        Parameters\n        ----------\n        l : float\n            Target l coordinate for pixel selection.\n        m : float\n            Target m coordinate for pixel selection.\n        var : {'SKY', 'BEAM'}, default 'SKY'\n            Data variable to plot.\n        pol : int, default 0\n            Polarization index.\n        cmap : str, default 'inferno'\n            Matplotlib colormap.\n        vmin, vmax : float, optional\n            Color scale limits.\n        robust : bool, default True\n            Use percentile-based color scaling.\n        figsize : tuple, default (8, 5)\n            Figure size in inches.\n        add_colorbar : bool, default True\n            Whether to add a colorbar.\n        **kwargs : dict\n            Additional arguments passed to imshow.\n\n        Returns\n        -------\n        matplotlib.figure.Figure\n            The figure containing the dynamic spectrum plot.\n\n        Examples\n        --------\n        &gt;&gt;&gt; fig = ds.radport.plot_dynamic_spectrum(l=0.0, m=0.0)\n        \"\"\"\n        # Get dynamic spectrum\n        dynspec = self.dynamic_spectrum(l=l, m=m, var=var, pol=pol)\n\n        # Create figure\n        fig, ax = plt.subplots(figsize=figsize)\n\n        # Compute data\n        data = dynspec.values\n\n        # Handle robust scaling\n        if robust and vmin is None and vmax is None:\n            finite_data = data[np.isfinite(data)]\n            if finite_data.size &gt; 0:\n                vmin = float(np.percentile(finite_data, 2))\n                vmax = float(np.percentile(finite_data, 98))\n\n        # Get coordinate values\n        time_vals = dynspec.coords[\"time\"].values\n        freq_vals = dynspec.coords[\"frequency\"].values / 1e6  # Convert to MHz\n\n        # Compute extent for imshow\n        # extent = [xmin, xmax, ymin, ymax]\n        extent = [\n            float(time_vals.min()), float(time_vals.max()),\n            float(freq_vals.min()), float(freq_vals.max()),\n        ]\n\n        # Plot - transpose so time is x-axis and frequency is y-axis\n        im = ax.imshow(\n            data.T,\n            origin=\"lower\",\n            cmap=cmap,\n            vmin=vmin,\n            vmax=vmax,\n            extent=extent,\n            aspect=\"auto\",\n            **kwargs,\n        )\n\n        if add_colorbar:\n            cbar = fig.colorbar(im, ax=ax)\n            cbar.set_label(\"Jy/beam\")\n\n        # Labels and title\n        pixel_l = dynspec.attrs[\"pixel_l\"]\n        pixel_m = dynspec.attrs[\"pixel_m\"]\n        ax.set_xlabel(\"Time (MJD)\")\n        ax.set_ylabel(\"Frequency (MHz)\")\n        ax.set_title(\n            f\"{var} Dynamic Spectrum at l={pixel_l:+.4f}, m={pixel_m:+.4f}, pol={pol}\"\n        )\n\n        fig.tight_layout()\n        return fig\n\n    # =========================================================================\n    # Difference Map Methods\n    # =========================================================================\n\n    def diff(\n        self,\n        mode: Literal[\"time\", \"frequency\"] = \"time\",\n        var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n        time_idx: int | None = None,\n        freq_idx: int | None = None,\n        pol: int = 0,\n        freq_mhz: float | None = None,\n        time_mjd: float | None = None,\n    ) -&gt; xr.DataArray:\n        \"\"\"Compute a difference map between adjacent time or frequency slices.\n\n        Useful for identifying transient sources or spectral features by\n        subtracting consecutive frames.\n\n        Parameters\n        ----------\n        mode : {'time', 'frequency'}, default 'time'\n            Difference mode:\n            - 'time': Subtract previous time step from current (at fixed freq)\n            - 'frequency': Subtract previous frequency from current (at fixed time)\n        var : {'SKY', 'BEAM'}, default 'SKY'\n            Data variable to difference.\n        time_idx : int, optional\n            Time index for the \"current\" frame. Default is 1.\n            For mode='time', differences frame[time_idx] - frame[time_idx-1].\n        freq_idx : int, optional\n            Frequency index for the \"current\" frame. Default is 1.\n            For mode='frequency', differences frame[freq_idx] - frame[freq_idx-1].\n        pol : int, default 0\n            Polarization index.\n        freq_mhz : float, optional\n            Select frequency by value in MHz.\n        time_mjd : float, optional\n            Select time by MJD value.\n\n        Returns\n        -------\n        xr.DataArray\n            2D DataArray with dimensions (l, m) containing the difference.\n            Includes metadata: diff_mode, idx1, idx2.\n\n        Raises\n        ------\n        ValueError\n            If indices are out of bounds for differencing.\n\n        Examples\n        --------\n        &gt;&gt;&gt; # Time difference at fixed frequency\n        &gt;&gt;&gt; diff = ds.radport.diff(mode='time', time_idx=5, freq_mhz=50.0)\n\n        &gt;&gt;&gt; # Frequency difference at fixed time\n        &gt;&gt;&gt; diff = ds.radport.diff(mode='frequency', freq_idx=10, time_idx=0)\n        \"\"\"\n        # Validate variable\n        if var not in self._obj.data_vars:\n            available = sorted(self._obj.data_vars)\n            raise ValueError(\n                f\"Variable '{var}' not found. Available: {available}\"\n            )\n\n        # Resolve indices\n        if freq_mhz is not None:\n            freq_idx = self.nearest_freq_idx(freq_mhz)\n        elif freq_idx is None:\n            freq_idx = 1 if mode == \"frequency\" else 0\n\n        if time_mjd is not None:\n            time_idx = self.nearest_time_idx(time_mjd)\n        elif time_idx is None:\n            time_idx = 1 if mode == \"time\" else 0\n\n        # Compute difference based on mode\n        if mode == \"time\":\n            if time_idx &lt; 1:\n                raise ValueError(\n                    f\"time_idx must be &gt;= 1 for time differencing. Got {time_idx}.\"\n                )\n            n_times = self._obj.sizes[\"time\"]\n            if time_idx &gt;= n_times:\n                raise ValueError(\n                    f\"time_idx {time_idx} out of bounds (dataset has {n_times} times).\"\n                )\n\n            frame_current = self._obj[var].isel(\n                time=time_idx, frequency=freq_idx, polarization=pol\n            )\n            frame_prev = self._obj[var].isel(\n                time=time_idx - 1, frequency=freq_idx, polarization=pol\n            )\n            diff = frame_current - frame_prev\n\n            diff.attrs[\"diff_mode\"] = \"time\"\n            diff.attrs[\"time_idx_current\"] = time_idx\n            diff.attrs[\"time_idx_prev\"] = time_idx - 1\n            diff.attrs[\"freq_idx\"] = freq_idx\n\n        else:  # mode == \"frequency\"\n            if freq_idx &lt; 1:\n                raise ValueError(\n                    f\"freq_idx must be &gt;= 1 for frequency differencing. Got {freq_idx}.\"\n                )\n            n_freqs = self._obj.sizes[\"frequency\"]\n            if freq_idx &gt;= n_freqs:\n                raise ValueError(\n                    f\"freq_idx {freq_idx} out of bounds (dataset has {n_freqs} frequencies).\"\n                )\n\n            frame_current = self._obj[var].isel(\n                time=time_idx, frequency=freq_idx, polarization=pol\n            )\n            frame_prev = self._obj[var].isel(\n                time=time_idx, frequency=freq_idx - 1, polarization=pol\n            )\n            diff = frame_current - frame_prev\n\n            diff.attrs[\"diff_mode\"] = \"frequency\"\n            diff.attrs[\"freq_idx_current\"] = freq_idx\n            diff.attrs[\"freq_idx_prev\"] = freq_idx - 1\n            diff.attrs[\"time_idx\"] = time_idx\n\n        diff.attrs[\"pol\"] = pol\n        return diff\n\n    def plot_diff(\n        self,\n        mode: Literal[\"time\", \"frequency\"] = \"time\",\n        var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n        time_idx: int | None = None,\n        freq_idx: int | None = None,\n        pol: int = 0,\n        freq_mhz: float | None = None,\n        time_mjd: float | None = None,\n        cmap: str = \"RdBu_r\",\n        vmin: float | None = None,\n        vmax: float | None = None,\n        symmetric: bool = True,\n        figsize: tuple[float, float] = (8, 6),\n        add_colorbar: bool = True,\n        **kwargs: Any,\n    ) -&gt; Figure:\n        \"\"\"Plot a difference map between adjacent time or frequency slices.\n\n        Parameters\n        ----------\n        mode : {'time', 'frequency'}, default 'time'\n            Difference mode.\n        var : {'SKY', 'BEAM'}, default 'SKY'\n            Data variable to difference.\n        time_idx : int, optional\n            Time index for the \"current\" frame.\n        freq_idx : int, optional\n            Frequency index for the \"current\" frame.\n        pol : int, default 0\n            Polarization index.\n        freq_mhz : float, optional\n            Select frequency by value in MHz.\n        time_mjd : float, optional\n            Select time by MJD value.\n        cmap : str, default 'RdBu_r'\n            Colormap (diverging colormaps work well for differences).\n        vmin, vmax : float, optional\n            Color scale limits.\n        symmetric : bool, default True\n            If True and vmin/vmax not specified, use symmetric color scale\n            centered on zero.\n        figsize : tuple, default (8, 6)\n            Figure size in inches.\n        add_colorbar : bool, default True\n            Whether to add a colorbar.\n        **kwargs : dict\n            Additional arguments passed to imshow.\n\n        Returns\n        -------\n        matplotlib.figure.Figure\n            The figure containing the difference plot.\n\n        Examples\n        --------\n        &gt;&gt;&gt; fig = ds.radport.plot_diff(mode='time', time_idx=5, freq_mhz=50.0)\n        \"\"\"\n        # Get difference data\n        diff = self.diff(\n            mode=mode,\n            var=var,\n            time_idx=time_idx,\n            freq_idx=freq_idx,\n            pol=pol,\n            freq_mhz=freq_mhz,\n            time_mjd=time_mjd,\n        )\n\n        # Create figure\n        fig, ax = plt.subplots(figsize=figsize)\n\n        # Compute data\n        data = diff.values\n\n        # Handle symmetric scaling\n        if symmetric and vmin is None and vmax is None:\n            finite_data = data[np.isfinite(data)]\n            if finite_data.size &gt; 0:\n                max_abs = float(np.percentile(np.abs(finite_data), 98))\n                vmin, vmax = -max_abs, max_abs\n\n        # Get coordinate extents\n        l_vals = diff.coords[\"l\"].values\n        m_vals = diff.coords[\"m\"].values\n        extent = [\n            float(l_vals.min()), float(l_vals.max()),\n            float(m_vals.min()), float(m_vals.max()),\n        ]\n\n        # Plot\n        im = ax.imshow(\n            data,\n            origin=\"lower\",\n            cmap=cmap,\n            vmin=vmin,\n            vmax=vmax,\n            extent=extent,\n            aspect=\"equal\",\n            **kwargs,\n        )\n\n        if add_colorbar:\n            cbar = fig.colorbar(im, ax=ax)\n            cbar.set_label(\"\u0394Jy/beam\")\n\n        # Build title\n        if mode == \"time\":\n            t_curr = diff.attrs[\"time_idx_current\"]\n            t_prev = diff.attrs[\"time_idx_prev\"]\n            f_idx = diff.attrs[\"freq_idx\"]\n            freq_mhz_val = float(self._obj.coords[\"frequency\"].values[f_idx]) / 1e6\n            title = f\"{var} Time Diff (t{t_curr} - t{t_prev}) at f={freq_mhz_val:.2f} MHz\"\n        else:\n            f_curr = diff.attrs[\"freq_idx_current\"]\n            f_prev = diff.attrs[\"freq_idx_prev\"]\n            t_idx = diff.attrs[\"time_idx\"]\n            freq_curr_mhz = float(self._obj.coords[\"frequency\"].values[f_curr]) / 1e6\n            freq_prev_mhz = float(self._obj.coords[\"frequency\"].values[f_prev]) / 1e6\n            time_val = self._obj.coords[\"time\"].values[t_idx]\n            title = f\"{var} Freq Diff ({freq_curr_mhz:.1f} - {freq_prev_mhz:.1f} MHz) at t={float(time_val):.6f}\"\n\n        ax.set_xlabel(\"l (direction cosine)\")\n        ax.set_ylabel(\"m (direction cosine)\")\n        ax.set_title(title)\n\n        fig.tight_layout()\n        return fig\n\n    # =========================================================================\n    # Data Quality Methods\n    # =========================================================================\n\n    def find_valid_frame(\n        self,\n        var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n        pol: int = 0,\n        min_finite_fraction: float = 0.1,\n    ) -&gt; tuple[int, int]:\n        \"\"\"Find the first (time, freq) frame with sufficient finite data.\n\n        Searches through time and frequency indices to find a frame where\n        at least `min_finite_fraction` of pixels contain finite (non-NaN) values.\n        Useful for automatically selecting a valid frame for visualization.\n\n        Parameters\n        ----------\n        var : {'SKY', 'BEAM'}, default 'SKY'\n            Data variable to check.\n        pol : int, default 0\n            Polarization index.\n        min_finite_fraction : float, default 0.1\n            Minimum fraction of finite pixels required (0 to 1).\n\n        Returns\n        -------\n        tuple of int\n            (time_idx, freq_idx) of the first valid frame.\n\n        Raises\n        ------\n        ValueError\n            If no valid frame is found.\n\n        Examples\n        --------\n        &gt;&gt;&gt; time_idx, freq_idx = ds.radport.find_valid_frame()\n        &gt;&gt;&gt; fig = ds.radport.plot(time_idx=time_idx, freq_idx=freq_idx)\n        \"\"\"\n        if var not in self._obj.data_vars:\n            available = sorted(self._obj.data_vars)\n            raise ValueError(f\"Variable '{var}' not found. Available: {available}\")\n\n        da = self._obj[var].isel(polarization=pol)\n\n        # Compute fraction of finite values for each (time, freq) plane\n        finite_frac = np.isfinite(da).mean(dim=(\"l\", \"m\"))\n\n        # If data is lazy (dask), compute it\n        if hasattr(finite_frac, \"compute\"):\n            finite_frac = finite_frac.compute()\n\n        arr = finite_frac.values\n\n        # Search for first valid frame\n        for ti in range(arr.shape[0]):\n            for fi in range(arr.shape[1]):\n                if arr[ti, fi] &gt;= min_finite_fraction:\n                    return ti, fi\n\n        raise ValueError(\n            f\"No valid frame found with at least {min_finite_fraction:.0%} finite pixels. \"\n            f\"Dataset may contain all NaN values.\"\n        )\n\n    def finite_fraction(\n        self,\n        var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n        pol: int = 0,\n    ) -&gt; xr.DataArray:\n        \"\"\"Compute the fraction of finite (non-NaN) pixels for each (time, freq).\n\n        Returns a 2D DataArray showing data availability across all\n        time and frequency combinations. Useful for identifying which\n        frames contain valid data.\n\n        Parameters\n        ----------\n        var : {'SKY', 'BEAM'}, default 'SKY'\n            Data variable to check.\n        pol : int, default 0\n            Polarization index.\n\n        Returns\n        -------\n        xr.DataArray\n            2D array with dimensions (time, frequency) containing fractions\n            from 0 (all NaN) to 1 (all finite).\n\n        Examples\n        --------\n        &gt;&gt;&gt; frac = ds.radport.finite_fraction()\n        &gt;&gt;&gt; frac.plot()  # Visualize data availability\n        \"\"\"\n        if var not in self._obj.data_vars:\n            available = sorted(self._obj.data_vars)\n            raise ValueError(f\"Variable '{var}' not found. Available: {available}\")\n\n        da = self._obj[var].isel(polarization=pol)\n        finite_frac = np.isfinite(da).mean(dim=(\"l\", \"m\"))\n\n        finite_frac.attrs[\"variable\"] = var\n        finite_frac.attrs[\"pol\"] = pol\n\n        return finite_frac\n\n    # =========================================================================\n    # Grid Plot Methods\n    # =========================================================================\n\n    def plot_grid(\n        self,\n        time_indices: list[int] | None = None,\n        freq_indices: list[int] | None = None,\n        freq_mhz_list: list[float] | None = None,\n        var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n        pol: int = 0,\n        ncols: int = 4,\n        panel_size: tuple[float, float] = (3.0, 2.6),\n        cmap: str = \"inferno\",\n        vmin: float | None = None,\n        vmax: float | None = None,\n        robust: bool = True,\n        mask_radius: int | None = None,\n        share_colorbar: bool = True,\n        **kwargs: Any,\n    ) -&gt; Figure:\n        \"\"\"Create a grid of plots showing multiple time/frequency combinations.\n\n        Useful for comparing observations across time or frequency in a\n        single figure with consistent scaling.\n\n        Parameters\n        ----------\n        time_indices : list of int, optional\n            Time indices to plot. If None, uses all available times.\n        freq_indices : list of int, optional\n            Frequency indices to plot. If None, uses all available frequencies.\n            Ignored if `freq_mhz_list` is provided.\n        freq_mhz_list : list of float, optional\n            Frequencies in MHz to plot. Overrides `freq_indices`.\n        var : {'SKY', 'BEAM'}, default 'SKY'\n            Data variable to plot.\n        pol : int, default 0\n            Polarization index.\n        ncols : int, default 4\n            Number of columns in the grid.\n        panel_size : tuple of float, default (3.0, 2.6)\n            Size of each panel in inches as (width, height).\n        cmap : str, default 'inferno'\n            Matplotlib colormap.\n        vmin, vmax : float, optional\n            Color scale limits. Applied to all panels.\n        robust : bool, default True\n            If True and vmin/vmax not specified, compute global percentile\n            scaling across all panels.\n        mask_radius : int, optional\n            Circular mask radius in pixels.\n        share_colorbar : bool, default True\n            If True, show a single shared colorbar for all panels.\n        **kwargs : dict\n            Additional arguments passed to imshow.\n\n        Returns\n        -------\n        matplotlib.figure.Figure\n            The figure containing the grid of plots.\n\n        Examples\n        --------\n        &gt;&gt;&gt; # Plot all times at a single frequency\n        &gt;&gt;&gt; fig = ds.radport.plot_grid(freq_mhz_list=[50.0])\n\n        &gt;&gt;&gt; # Plot specific times and frequencies\n        &gt;&gt;&gt; fig = ds.radport.plot_grid(\n        ...     time_indices=[0, 1, 2],\n        ...     freq_mhz_list=[46.0, 50.0, 54.0],\n        ... )\n\n        &gt;&gt;&gt; # Plot first 4 times at all frequencies\n        &gt;&gt;&gt; fig = ds.radport.plot_grid(time_indices=[0, 1, 2, 3])\n        \"\"\"\n        # Validate variable\n        if var not in self._obj.data_vars:\n            available = sorted(self._obj.data_vars)\n            raise ValueError(f\"Variable '{var}' not found. Available: {available}\")\n\n        # Resolve time indices\n        if time_indices is None:\n            time_indices = list(range(self._obj.sizes[\"time\"]))\n\n        # Resolve frequency indices\n        if freq_mhz_list is not None:\n            freq_indices = [self.nearest_freq_idx(f) for f in freq_mhz_list]\n        elif freq_indices is None:\n            freq_indices = list(range(self._obj.sizes[\"frequency\"]))\n\n        # Calculate grid dimensions\n        n_panels = len(time_indices) * len(freq_indices)\n        if n_panels == 0:\n            raise ValueError(\"No panels to plot. Check time_indices and freq_indices.\")\n\n        nrows = int(np.ceil(n_panels / ncols))\n\n        # Create figure\n        fig_width = panel_size[0] * ncols\n        fig_height = panel_size[1] * nrows\n        fig, axes = plt.subplots(\n            nrows, ncols,\n            figsize=(fig_width, fig_height),\n            squeeze=False,\n        )\n\n        # Collect all data for global scaling if robust=True\n        all_data = []\n        panel_data = []\n\n        for ti in time_indices:\n            for fi in freq_indices:\n                da = self._obj[var].isel(\n                    time=ti, frequency=fi, polarization=pol\n                )\n                data = da.values.copy()\n\n                # Apply mask if requested\n                if mask_radius is not None:\n                    ny, nx = data.shape\n                    cy, cx = ny // 2, nx // 2\n                    yy, xx = np.ogrid[:ny, :nx]\n                    dist = np.sqrt((yy - cy) ** 2 + (xx - cx) ** 2)\n                    data[dist &gt; mask_radius] = np.nan\n\n                panel_data.append((ti, fi, data, da))\n                if robust and vmin is None and vmax is None:\n                    finite = data[np.isfinite(data)]\n                    if finite.size &gt; 0:\n                        all_data.append(finite)\n\n        # Compute global vmin/vmax if robust\n        if robust and vmin is None and vmax is None and all_data:\n            all_finite = np.concatenate(all_data)\n            vmin = float(np.percentile(all_finite, 2))\n            vmax = float(np.percentile(all_finite, 98))\n\n        # Plot each panel\n        im = None\n        for idx, (ti, fi, data, da) in enumerate(panel_data):\n            row, col = divmod(idx, ncols)\n            ax = axes[row, col]\n\n            # Get coordinate extents\n            l_vals = da.coords[\"l\"].values\n            m_vals = da.coords[\"m\"].values\n            extent = [\n                float(l_vals.min()), float(l_vals.max()),\n                float(m_vals.min()), float(m_vals.max()),\n            ]\n\n            # Check if panel has data\n            has_data = np.any(np.isfinite(data))\n\n            if has_data:\n                im = ax.imshow(\n                    data,\n                    origin=\"lower\",\n                    cmap=cmap,\n                    vmin=vmin,\n                    vmax=vmax,\n                    extent=extent,\n                    aspect=\"equal\",\n                    **kwargs,\n                )\n            else:\n                ax.text(\n                    0.5, 0.5, \"No Data\",\n                    ha=\"center\", va=\"center\",\n                    transform=ax.transAxes,\n                    fontsize=10,\n                )\n                ax.set_xlim(extent[0], extent[1])\n                ax.set_ylim(extent[2], extent[3])\n\n            # Build panel title\n            time_val = self._obj.coords[\"time\"].values[ti]\n            freq_val = self._obj.coords[\"frequency\"].values[fi] / 1e6\n            try:\n                time_str = f\"{float(time_val):.6f}\"\n            except (TypeError, ValueError):\n                time_str = str(time_val)\n\n            ax.set_title(f\"t={time_str}\\nf={freq_val:.2f} MHz\", fontsize=9)\n            ax.set_xticks([])\n            ax.set_yticks([])\n\n        # Hide unused panels\n        for idx in range(n_panels, nrows * ncols):\n            row, col = divmod(idx, ncols)\n            axes[row, col].axis(\"off\")\n\n        # Add shared colorbar\n        if share_colorbar and im is not None:\n            fig.subplots_adjust(right=0.9)\n            cbar_ax = fig.add_axes([0.92, 0.15, 0.02, 0.7])\n            cbar = fig.colorbar(im, cax=cbar_ax)\n            cbar.set_label(\"Jy/beam\")\n\n        fig.suptitle(f\"{var} Grid (pol={pol})\", fontsize=12, y=1.02)\n\n        return fig\n\n    def plot_frequency_grid(\n        self,\n        time_idx: int = 0,\n        freq_mhz_list: list[float] | None = None,\n        var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n        pol: int = 0,\n        ncols: int = 4,\n        panel_size: tuple[float, float] = (3.0, 2.6),\n        cmap: str = \"inferno\",\n        vmin: float | None = None,\n        vmax: float | None = None,\n        robust: bool = True,\n        mask_radius: int | None = None,\n        **kwargs: Any,\n    ) -&gt; Figure:\n        \"\"\"Create a grid showing all frequencies at a fixed time.\n\n        Convenience method for comparing across frequency channels.\n\n        Parameters\n        ----------\n        time_idx : int, default 0\n            Time index for all panels.\n        freq_mhz_list : list of float, optional\n            Specific frequencies to plot. If None, plots all frequencies.\n        var : {'SKY', 'BEAM'}, default 'SKY'\n            Data variable to plot.\n        pol : int, default 0\n            Polarization index.\n        ncols : int, default 4\n            Number of columns.\n        panel_size : tuple, default (3.0, 2.6)\n            Size of each panel.\n        cmap : str, default 'inferno'\n            Colormap.\n        vmin, vmax : float, optional\n            Color scale limits.\n        robust : bool, default True\n            Use percentile-based scaling.\n        mask_radius : int, optional\n            Circular mask radius.\n        **kwargs : dict\n            Additional arguments passed to imshow.\n\n        Returns\n        -------\n        matplotlib.figure.Figure\n\n        Examples\n        --------\n        &gt;&gt;&gt; fig = ds.radport.plot_frequency_grid(time_idx=0)\n        \"\"\"\n        return self.plot_grid(\n            time_indices=[time_idx],\n            freq_mhz_list=freq_mhz_list,\n            var=var,\n            pol=pol,\n            ncols=ncols,\n            panel_size=panel_size,\n            cmap=cmap,\n            vmin=vmin,\n            vmax=vmax,\n            robust=robust,\n            mask_radius=mask_radius,\n            **kwargs,\n        )\n\n    def plot_time_grid(\n        self,\n        freq_idx: int | None = None,\n        freq_mhz: float | None = None,\n        time_indices: list[int] | None = None,\n        var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n        pol: int = 0,\n        ncols: int = 4,\n        panel_size: tuple[float, float] = (3.0, 2.6),\n        cmap: str = \"inferno\",\n        vmin: float | None = None,\n        vmax: float | None = None,\n        robust: bool = True,\n        mask_radius: int | None = None,\n        **kwargs: Any,\n    ) -&gt; Figure:\n        \"\"\"Create a grid showing all times at a fixed frequency.\n\n        Convenience method for comparing across time steps (time evolution).\n\n        Parameters\n        ----------\n        freq_idx : int, optional\n            Frequency index. Default is 0. Ignored if `freq_mhz` is provided.\n        freq_mhz : float, optional\n            Frequency in MHz (overrides freq_idx).\n        time_indices : list of int, optional\n            Specific time indices to plot. If None, plots all times.\n        var : {'SKY', 'BEAM'}, default 'SKY'\n            Data variable to plot.\n        pol : int, default 0\n            Polarization index.\n        ncols : int, default 4\n            Number of columns.\n        panel_size : tuple, default (3.0, 2.6)\n            Size of each panel.\n        cmap : str, default 'inferno'\n            Colormap.\n        vmin, vmax : float, optional\n            Color scale limits.\n        robust : bool, default True\n            Use percentile-based scaling.\n        mask_radius : int, optional\n            Circular mask radius.\n        **kwargs : dict\n            Additional arguments passed to imshow.\n\n        Returns\n        -------\n        matplotlib.figure.Figure\n\n        Examples\n        --------\n        &gt;&gt;&gt; fig = ds.radport.plot_time_grid(freq_mhz=50.0)\n        \"\"\"\n        # Resolve frequency\n        if freq_mhz is not None:\n            freq_indices = [self.nearest_freq_idx(freq_mhz)]\n        elif freq_idx is not None:\n            freq_indices = [freq_idx]\n        else:\n            freq_indices = [0]\n\n        return self.plot_grid(\n            time_indices=time_indices,\n            freq_indices=freq_indices,\n            var=var,\n            pol=pol,\n            ncols=ncols,\n            panel_size=panel_size,\n            cmap=cmap,\n            vmin=vmin,\n            vmax=vmax,\n            robust=robust,\n            mask_radius=mask_radius,\n            **kwargs,\n        )\n\n    # =========================================================================\n    # 1D Analysis Methods\n    # =========================================================================\n\n    def light_curve(\n        self,\n        l: float,\n        m: float,\n        freq_idx: int | None = None,\n        freq_mhz: float | None = None,\n        var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n        pol: int = 0,\n    ) -&gt; xr.DataArray:\n        \"\"\"Extract a light curve (time series) at a specific spatial location.\n\n        Returns intensity as a function of time at the pixel nearest to\n        the specified (l, m) coordinates and frequency.\n\n        Parameters\n        ----------\n        l : float\n            Direction cosine l coordinate.\n        m : float\n            Direction cosine m coordinate.\n        freq_idx : int, optional\n            Frequency index. Default is 0. Ignored if `freq_mhz` is provided.\n        freq_mhz : float, optional\n            Frequency in MHz (overrides freq_idx).\n        var : {'SKY', 'BEAM'}, default 'SKY'\n            Data variable to extract.\n        pol : int, default 0\n            Polarization index.\n\n        Returns\n        -------\n        xr.DataArray\n            1D array with dimension 'time' containing the light curve.\n\n        Examples\n        --------\n        &gt;&gt;&gt; lc = ds.radport.light_curve(l=0.0, m=0.0, freq_mhz=50.0)\n        &gt;&gt;&gt; lc.plot()  # Plot intensity vs time\n        \"\"\"\n        if var not in self._obj.data_vars:\n            available = sorted(self._obj.data_vars)\n            raise ValueError(f\"Variable '{var}' not found. Available: {available}\")\n\n        # Resolve frequency index\n        if freq_mhz is not None:\n            fi = self.nearest_freq_idx(freq_mhz)\n        elif freq_idx is not None:\n            fi = freq_idx\n        else:\n            fi = 0\n\n        # Find nearest pixel\n        l_idx, m_idx = self.nearest_lm_idx(l, m)\n\n        # Extract light curve\n        lc = self._obj[var].isel(\n            frequency=fi,\n            polarization=pol,\n            l=l_idx,\n            m=m_idx,\n        )\n\n        # Add metadata\n        freq_hz = float(self._obj.coords[\"frequency\"].values[fi])\n        l_val = float(self._obj.coords[\"l\"].values[l_idx])\n        m_val = float(self._obj.coords[\"m\"].values[m_idx])\n\n        lc.attrs[\"variable\"] = var\n        lc.attrs[\"freq_idx\"] = fi\n        lc.attrs[\"freq_mhz\"] = freq_hz / 1e6\n        lc.attrs[\"pol\"] = pol\n        lc.attrs[\"l\"] = l_val\n        lc.attrs[\"m\"] = m_val\n        lc.attrs[\"l_idx\"] = l_idx\n        lc.attrs[\"m_idx\"] = m_idx\n\n        return lc\n\n    def plot_light_curve(\n        self,\n        l: float,\n        m: float,\n        freq_idx: int | None = None,\n        freq_mhz: float | None = None,\n        var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n        pol: int = 0,\n        figsize: tuple[float, float] = (10, 4),\n        marker: str = \"o\",\n        linestyle: str = \"-\",\n        **kwargs: Any,\n    ) -&gt; Figure:\n        \"\"\"Plot a light curve (time series) at a specific spatial location.\n\n        Parameters\n        ----------\n        l : float\n            Direction cosine l coordinate.\n        m : float\n            Direction cosine m coordinate.\n        freq_idx : int, optional\n            Frequency index. Default is 0. Ignored if `freq_mhz` is provided.\n        freq_mhz : float, optional\n            Frequency in MHz (overrides freq_idx).\n        var : {'SKY', 'BEAM'}, default 'SKY'\n            Data variable to plot.\n        pol : int, default 0\n            Polarization index.\n        figsize : tuple, default (10, 4)\n            Figure size in inches.\n        marker : str, default 'o'\n            Marker style for data points.\n        linestyle : str, default '-'\n            Line style connecting points.\n        **kwargs : dict\n            Additional arguments passed to plt.plot.\n\n        Returns\n        -------\n        matplotlib.figure.Figure\n\n        Examples\n        --------\n        &gt;&gt;&gt; fig = ds.radport.plot_light_curve(l=0.0, m=0.0, freq_mhz=50.0)\n        \"\"\"\n        lc = self.light_curve(\n            l=l, m=m, freq_idx=freq_idx, freq_mhz=freq_mhz, var=var, pol=pol\n        )\n\n        fig, ax = plt.subplots(figsize=figsize)\n\n        time_vals = lc.coords[\"time\"].values\n        ax.plot(time_vals, lc.values, marker=marker, linestyle=linestyle, **kwargs)\n\n        ax.set_xlabel(\"Time (MJD)\")\n        ax.set_ylabel(f\"{var} Intensity (Jy/beam)\")\n\n        freq_mhz_val = lc.attrs[\"freq_mhz\"]\n        l_val = lc.attrs[\"l\"]\n        m_val = lc.attrs[\"m\"]\n        ax.set_title(\n            f\"{var} Light Curve at (l={l_val:.3f}, m={m_val:.3f}), \"\n            f\"f={freq_mhz_val:.2f} MHz, pol={pol}\"\n        )\n\n        ax.grid(True, alpha=0.3)\n        fig.tight_layout()\n\n        return fig\n\n    def spectrum(\n        self,\n        l: float,\n        m: float,\n        time_idx: int | None = None,\n        time_mjd: float | None = None,\n        var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n        pol: int = 0,\n    ) -&gt; xr.DataArray:\n        \"\"\"Extract a frequency spectrum at a specific spatial location and time.\n\n        Returns intensity as a function of frequency at the pixel nearest to\n        the specified (l, m) coordinates and time.\n\n        Parameters\n        ----------\n        l : float\n            Direction cosine l coordinate.\n        m : float\n            Direction cosine m coordinate.\n        time_idx : int, optional\n            Time index. Default is 0. Ignored if `time_mjd` is provided.\n        time_mjd : float, optional\n            Time in MJD (overrides time_idx).\n        var : {'SKY', 'BEAM'}, default 'SKY'\n            Data variable to extract.\n        pol : int, default 0\n            Polarization index.\n\n        Returns\n        -------\n        xr.DataArray\n            1D array with dimension 'frequency' containing the spectrum.\n\n        Examples\n        --------\n        &gt;&gt;&gt; spec = ds.radport.spectrum(l=0.0, m=0.0, time_idx=0)\n        &gt;&gt;&gt; spec.plot()  # Plot intensity vs frequency\n        \"\"\"\n        if var not in self._obj.data_vars:\n            available = sorted(self._obj.data_vars)\n            raise ValueError(f\"Variable '{var}' not found. Available: {available}\")\n\n        # Resolve time index\n        if time_mjd is not None:\n            ti = self.nearest_time_idx(time_mjd)\n        elif time_idx is not None:\n            ti = time_idx\n        else:\n            ti = 0\n\n        # Find nearest pixel\n        l_idx, m_idx = self.nearest_lm_idx(l, m)\n\n        # Extract spectrum\n        spec = self._obj[var].isel(\n            time=ti,\n            polarization=pol,\n            l=l_idx,\n            m=m_idx,\n        )\n\n        # Add metadata\n        time_val = float(self._obj.coords[\"time\"].values[ti])\n        l_val = float(self._obj.coords[\"l\"].values[l_idx])\n        m_val = float(self._obj.coords[\"m\"].values[m_idx])\n\n        spec.attrs[\"variable\"] = var\n        spec.attrs[\"time_idx\"] = ti\n        spec.attrs[\"time_mjd\"] = time_val\n        spec.attrs[\"pol\"] = pol\n        spec.attrs[\"l\"] = l_val\n        spec.attrs[\"m\"] = m_val\n        spec.attrs[\"l_idx\"] = l_idx\n        spec.attrs[\"m_idx\"] = m_idx\n\n        return spec\n\n    def plot_spectrum(\n        self,\n        l: float,\n        m: float,\n        time_idx: int | None = None,\n        time_mjd: float | None = None,\n        var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n        pol: int = 0,\n        figsize: tuple[float, float] = (10, 4),\n        marker: str = \"o\",\n        linestyle: str = \"-\",\n        freq_unit: Literal[\"Hz\", \"MHz\"] = \"MHz\",\n        **kwargs: Any,\n    ) -&gt; Figure:\n        \"\"\"Plot a frequency spectrum at a specific spatial location and time.\n\n        Parameters\n        ----------\n        l : float\n            Direction cosine l coordinate.\n        m : float\n            Direction cosine m coordinate.\n        time_idx : int, optional\n            Time index. Default is 0. Ignored if `time_mjd` is provided.\n        time_mjd : float, optional\n            Time in MJD (overrides time_idx).\n        var : {'SKY', 'BEAM'}, default 'SKY'\n            Data variable to plot.\n        pol : int, default 0\n            Polarization index.\n        figsize : tuple, default (10, 4)\n            Figure size in inches.\n        marker : str, default 'o'\n            Marker style for data points.\n        linestyle : str, default '-'\n            Line style connecting points.\n        freq_unit : {'Hz', 'MHz'}, default 'MHz'\n            Unit for frequency axis.\n        **kwargs : dict\n            Additional arguments passed to plt.plot.\n\n        Returns\n        -------\n        matplotlib.figure.Figure\n\n        Examples\n        --------\n        &gt;&gt;&gt; fig = ds.radport.plot_spectrum(l=0.0, m=0.0, time_idx=0)\n        \"\"\"\n        spec = self.spectrum(\n            l=l, m=m, time_idx=time_idx, time_mjd=time_mjd, var=var, pol=pol\n        )\n\n        fig, ax = plt.subplots(figsize=figsize)\n\n        freq_vals = spec.coords[\"frequency\"].values\n        if freq_unit == \"MHz\":\n            freq_vals = freq_vals / 1e6\n            xlabel = \"Frequency (MHz)\"\n        else:\n            xlabel = \"Frequency (Hz)\"\n\n        ax.plot(freq_vals, spec.values, marker=marker, linestyle=linestyle, **kwargs)\n\n        ax.set_xlabel(xlabel)\n        ax.set_ylabel(f\"{var} Intensity (Jy/beam)\")\n\n        time_mjd_val = spec.attrs[\"time_mjd\"]\n        l_val = spec.attrs[\"l\"]\n        m_val = spec.attrs[\"m\"]\n        ax.set_title(\n            f\"{var} Spectrum at (l={l_val:.3f}, m={m_val:.3f}), \"\n            f\"t={time_mjd_val:.6f} MJD, pol={pol}\"\n        )\n\n        ax.grid(True, alpha=0.3)\n        fig.tight_layout()\n\n        return fig\n\n    def time_average(\n        self,\n        var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n        pol: int = 0,\n        time_indices: list[int] | None = None,\n    ) -&gt; xr.DataArray:\n        \"\"\"Compute the time-averaged image.\n\n        Averages the data across the time dimension, returning a 3D array\n        with dimensions (frequency, l, m).\n\n        Parameters\n        ----------\n        var : {'SKY', 'BEAM'}, default 'SKY'\n            Data variable to average.\n        pol : int, default 0\n            Polarization index.\n        time_indices : list of int, optional\n            Specific time indices to include in the average.\n            If None, averages over all times.\n\n        Returns\n        -------\n        xr.DataArray\n            3D array with dimensions (frequency, l, m).\n\n        Examples\n        --------\n        &gt;&gt;&gt; avg = ds.radport.time_average()\n        &gt;&gt;&gt; avg.isel(frequency=0).plot()  # Plot mean image at first frequency\n        \"\"\"\n        if var not in self._obj.data_vars:\n            available = sorted(self._obj.data_vars)\n            raise ValueError(f\"Variable '{var}' not found. Available: {available}\")\n\n        da = self._obj[var].isel(polarization=pol)\n\n        if time_indices is not None:\n            da = da.isel(time=time_indices)\n\n        avg = da.mean(dim=\"time\")\n\n        avg.attrs[\"variable\"] = var\n        avg.attrs[\"pol\"] = pol\n        avg.attrs[\"operation\"] = \"time_average\"\n        if time_indices is not None:\n            avg.attrs[\"time_indices\"] = time_indices\n        else:\n            avg.attrs[\"n_times\"] = self._obj.sizes[\"time\"]\n\n        return avg\n\n    def frequency_average(\n        self,\n        var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n        pol: int = 0,\n        freq_indices: list[int] | None = None,\n        freq_min_mhz: float | None = None,\n        freq_max_mhz: float | None = None,\n    ) -&gt; xr.DataArray:\n        \"\"\"Compute the frequency-averaged image.\n\n        Averages the data across the frequency dimension, returning a 3D array\n        with dimensions (time, l, m).\n\n        Parameters\n        ----------\n        var : {'SKY', 'BEAM'}, default 'SKY'\n            Data variable to average.\n        pol : int, default 0\n            Polarization index.\n        freq_indices : list of int, optional\n            Specific frequency indices to include in the average.\n            If None (and freq_min/max not set), averages over all frequencies.\n        freq_min_mhz : float, optional\n            Minimum frequency in MHz for averaging band.\n        freq_max_mhz : float, optional\n            Maximum frequency in MHz for averaging band.\n\n        Returns\n        -------\n        xr.DataArray\n            3D array with dimensions (time, l, m).\n\n        Examples\n        --------\n        &gt;&gt;&gt; avg = ds.radport.frequency_average()\n        &gt;&gt;&gt; avg.isel(time=0).plot()  # Plot mean image at first time\n\n        &gt;&gt;&gt; # Average only 45-55 MHz band\n        &gt;&gt;&gt; band_avg = ds.radport.frequency_average(freq_min_mhz=45.0, freq_max_mhz=55.0)\n        \"\"\"\n        if var not in self._obj.data_vars:\n            available = sorted(self._obj.data_vars)\n            raise ValueError(f\"Variable '{var}' not found. Available: {available}\")\n\n        da = self._obj[var].isel(polarization=pol)\n\n        # Handle frequency selection\n        if freq_min_mhz is not None or freq_max_mhz is not None:\n            freq_hz = self._obj.coords[\"frequency\"].values\n            freq_mhz = freq_hz / 1e6\n\n            if freq_min_mhz is None:\n                freq_min_mhz = freq_mhz.min()\n            if freq_max_mhz is None:\n                freq_max_mhz = freq_mhz.max()\n\n            mask = (freq_mhz &gt;= freq_min_mhz) &amp; (freq_mhz &lt;= freq_max_mhz)\n            freq_indices = list(np.where(mask)[0])\n\n            if len(freq_indices) == 0:\n                raise ValueError(\n                    f\"No frequencies in range [{freq_min_mhz}, {freq_max_mhz}] MHz. \"\n                    f\"Available range: [{freq_mhz.min():.2f}, {freq_mhz.max():.2f}] MHz\"\n                )\n\n        if freq_indices is not None:\n            da = da.isel(frequency=freq_indices)\n\n        avg = da.mean(dim=\"frequency\")\n\n        avg.attrs[\"variable\"] = var\n        avg.attrs[\"pol\"] = pol\n        avg.attrs[\"operation\"] = \"frequency_average\"\n        if freq_indices is not None:\n            avg.attrs[\"freq_indices\"] = freq_indices\n        else:\n            avg.attrs[\"n_frequencies\"] = self._obj.sizes[\"frequency\"]\n        if freq_min_mhz is not None:\n            avg.attrs[\"freq_min_mhz\"] = freq_min_mhz\n        if freq_max_mhz is not None:\n            avg.attrs[\"freq_max_mhz\"] = freq_max_mhz\n\n        return avg\n\n    def plot_time_average(\n        self,\n        freq_idx: int | None = None,\n        freq_mhz: float | None = None,\n        var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n        pol: int = 0,\n        time_indices: list[int] | None = None,\n        cmap: str = \"inferno\",\n        vmin: float | None = None,\n        vmax: float | None = None,\n        robust: bool = True,\n        mask_radius: int | None = None,\n        figsize: tuple[float, float] = (8, 6),\n        add_colorbar: bool = True,\n        **kwargs: Any,\n    ) -&gt; Figure:\n        \"\"\"Plot the time-averaged image at a specific frequency.\n\n        Parameters\n        ----------\n        freq_idx : int, optional\n            Frequency index. Default is 0. Ignored if `freq_mhz` is provided.\n        freq_mhz : float, optional\n            Frequency in MHz (overrides freq_idx).\n        var : {'SKY', 'BEAM'}, default 'SKY'\n            Data variable to plot.\n        pol : int, default 0\n            Polarization index.\n        time_indices : list of int, optional\n            Specific time indices to include in the average.\n        cmap : str, default 'inferno'\n            Colormap.\n        vmin, vmax : float, optional\n            Color scale limits.\n        robust : bool, default True\n            Use 2nd/98th percentile for scaling.\n        mask_radius : int, optional\n            Circular mask radius in pixels.\n        figsize : tuple, default (8, 6)\n            Figure size in inches.\n        add_colorbar : bool, default True\n            Whether to add colorbar.\n        **kwargs : dict\n            Additional arguments passed to imshow.\n\n        Returns\n        -------\n        matplotlib.figure.Figure\n\n        Examples\n        --------\n        &gt;&gt;&gt; fig = ds.radport.plot_time_average(freq_mhz=50.0)\n        \"\"\"\n        avg = self.time_average(var=var, pol=pol, time_indices=time_indices)\n\n        # Resolve frequency index\n        if freq_mhz is not None:\n            fi = self.nearest_freq_idx(freq_mhz)\n        elif freq_idx is not None:\n            fi = freq_idx\n        else:\n            fi = 0\n\n        # Select frequency slice\n        data = avg.isel(frequency=fi).values.copy()\n\n        # Apply mask if requested\n        if mask_radius is not None:\n            ny, nx = data.shape\n            cy, cx = ny // 2, nx // 2\n            yy, xx = np.ogrid[:ny, :nx]\n            dist = np.sqrt((yy - cy) ** 2 + (xx - cx) ** 2)\n            data[dist &gt; mask_radius] = np.nan\n\n        # Compute vmin/vmax if robust\n        if robust and vmin is None and vmax is None:\n            finite = data[np.isfinite(data)]\n            if finite.size &gt; 0:\n                vmin = float(np.percentile(finite, 2))\n                vmax = float(np.percentile(finite, 98))\n\n        # Create plot\n        fig, ax = plt.subplots(figsize=figsize)\n\n        l_vals = avg.coords[\"l\"].values\n        m_vals = avg.coords[\"m\"].values\n        extent = [\n            float(l_vals.min()), float(l_vals.max()),\n            float(m_vals.min()), float(m_vals.max()),\n        ]\n\n        im = ax.imshow(\n            data,\n            origin=\"lower\",\n            cmap=cmap,\n            vmin=vmin,\n            vmax=vmax,\n            extent=extent,\n            aspect=\"equal\",\n            **kwargs,\n        )\n\n        if add_colorbar:\n            cbar = fig.colorbar(im, ax=ax)\n            cbar.set_label(\"Jy/beam\")\n\n        freq_hz = float(self._obj.coords[\"frequency\"].values[fi])\n        n_times = len(time_indices) if time_indices else self._obj.sizes[\"time\"]\n        ax.set_xlabel(\"l (direction cosine)\")\n        ax.set_ylabel(\"m (direction cosine)\")\n        ax.set_title(\n            f\"{var} Time Average ({n_times} frames) at f={freq_hz/1e6:.2f} MHz, pol={pol}\"\n        )\n\n        fig.tight_layout()\n        return fig\n\n    def plot_frequency_average(\n        self,\n        time_idx: int | None = None,\n        time_mjd: float | None = None,\n        var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n        pol: int = 0,\n        freq_indices: list[int] | None = None,\n        freq_min_mhz: float | None = None,\n        freq_max_mhz: float | None = None,\n        cmap: str = \"inferno\",\n        vmin: float | None = None,\n        vmax: float | None = None,\n        robust: bool = True,\n        mask_radius: int | None = None,\n        figsize: tuple[float, float] = (8, 6),\n        add_colorbar: bool = True,\n        **kwargs: Any,\n    ) -&gt; Figure:\n        \"\"\"Plot the frequency-averaged image at a specific time.\n\n        Parameters\n        ----------\n        time_idx : int, optional\n            Time index. Default is 0. Ignored if `time_mjd` is provided.\n        time_mjd : float, optional\n            Time in MJD (overrides time_idx).\n        var : {'SKY', 'BEAM'}, default 'SKY'\n            Data variable to plot.\n        pol : int, default 0\n            Polarization index.\n        freq_indices : list of int, optional\n            Specific frequency indices to include in the average.\n        freq_min_mhz : float, optional\n            Minimum frequency in MHz for averaging band.\n        freq_max_mhz : float, optional\n            Maximum frequency in MHz for averaging band.\n        cmap : str, default 'inferno'\n            Colormap.\n        vmin, vmax : float, optional\n            Color scale limits.\n        robust : bool, default True\n            Use 2nd/98th percentile for scaling.\n        mask_radius : int, optional\n            Circular mask radius in pixels.\n        figsize : tuple, default (8, 6)\n            Figure size in inches.\n        add_colorbar : bool, default True\n            Whether to add colorbar.\n        **kwargs : dict\n            Additional arguments passed to imshow.\n\n        Returns\n        -------\n        matplotlib.figure.Figure\n\n        Examples\n        --------\n        &gt;&gt;&gt; fig = ds.radport.plot_frequency_average(time_idx=0)\n\n        &gt;&gt;&gt; # Average 45-55 MHz band\n        &gt;&gt;&gt; fig = ds.radport.plot_frequency_average(\n        ...     time_idx=0, freq_min_mhz=45.0, freq_max_mhz=55.0\n        ... )\n        \"\"\"\n        avg = self.frequency_average(\n            var=var,\n            pol=pol,\n            freq_indices=freq_indices,\n            freq_min_mhz=freq_min_mhz,\n            freq_max_mhz=freq_max_mhz,\n        )\n\n        # Resolve time index\n        if time_mjd is not None:\n            ti = self.nearest_time_idx(time_mjd)\n        elif time_idx is not None:\n            ti = time_idx\n        else:\n            ti = 0\n\n        # Select time slice\n        data = avg.isel(time=ti).values.copy()\n\n        # Apply mask if requested\n        if mask_radius is not None:\n            ny, nx = data.shape\n            cy, cx = ny // 2, nx // 2\n            yy, xx = np.ogrid[:ny, :nx]\n            dist = np.sqrt((yy - cy) ** 2 + (xx - cx) ** 2)\n            data[dist &gt; mask_radius] = np.nan\n\n        # Compute vmin/vmax if robust\n        if robust and vmin is None and vmax is None:\n            finite = data[np.isfinite(data)]\n            if finite.size &gt; 0:\n                vmin = float(np.percentile(finite, 2))\n                vmax = float(np.percentile(finite, 98))\n\n        # Create plot\n        fig, ax = plt.subplots(figsize=figsize)\n\n        l_vals = avg.coords[\"l\"].values\n        m_vals = avg.coords[\"m\"].values\n        extent = [\n            float(l_vals.min()), float(l_vals.max()),\n            float(m_vals.min()), float(m_vals.max()),\n        ]\n\n        im = ax.imshow(\n            data,\n            origin=\"lower\",\n            cmap=cmap,\n            vmin=vmin,\n            vmax=vmax,\n            extent=extent,\n            aspect=\"equal\",\n            **kwargs,\n        )\n\n        if add_colorbar:\n            cbar = fig.colorbar(im, ax=ax)\n            cbar.set_label(\"Jy/beam\")\n\n        time_val = float(self._obj.coords[\"time\"].values[ti])\n\n        # Build title with frequency info\n        if freq_min_mhz is not None and freq_max_mhz is not None:\n            freq_info = f\"{freq_min_mhz:.1f}-{freq_max_mhz:.1f} MHz\"\n        elif freq_indices is not None:\n            freq_info = f\"{len(freq_indices)} channels\"\n        else:\n            freq_info = f\"{self._obj.sizes['frequency']} channels\"\n\n        ax.set_xlabel(\"l (direction cosine)\")\n        ax.set_ylabel(\"m (direction cosine)\")\n        ax.set_title(\n            f\"{var} Frequency Average ({freq_info}) at t={time_val:.6f} MJD, pol={pol}\"\n        )\n\n        fig.tight_layout()\n        return fig\n\n    # =========================================================================\n    # WCS &amp; Coordinate Methods\n    # =========================================================================\n\n    def _get_wcs(self, var: Literal[\"SKY\", \"BEAM\"] = \"SKY\"):\n        \"\"\"Get WCS object from the dataset.\n\n        Parameters\n        ----------\n        var : {'SKY', 'BEAM'}, default 'SKY'\n            Data variable to get WCS from (checks attrs first).\n\n        Returns\n        -------\n        astropy.wcs.WCS\n            The WCS object for coordinate transformations.\n\n        Raises\n        ------\n        ImportError\n            If astropy is not installed.\n        ValueError\n            If no WCS header is found in the dataset.\n        \"\"\"\n        try:\n            from astropy.io.fits import Header\n            from astropy.wcs import WCS\n        except ImportError as e:\n            raise ImportError(\n                \"astropy is required for WCS functionality. \"\n                \"Install with: pip install astropy\"\n            ) from e\n\n        # Try to get WCS header string from various locations\n        hdr_str = None\n\n        # 1. Check variable attrs\n        if var in self._obj.data_vars:\n            hdr_str = self._obj[var].attrs.get(\"fits_wcs_header\")\n\n        # 2. Check dataset attrs\n        if not hdr_str:\n            hdr_str = self._obj.attrs.get(\"fits_wcs_header\")\n\n        # 3. Check wcs_header_str variable\n        if not hdr_str and \"wcs_header_str\" in self._obj:\n            val = self._obj[\"wcs_header_str\"].values\n            if isinstance(val, np.ndarray):\n                val = val.item()\n            if isinstance(val, (bytes, bytearray)) or type(val).__name__ == \"bytes_\":\n                hdr_str = val.decode(\"utf-8\", errors=\"replace\")\n            else:\n                hdr_str = str(val)\n\n        if not hdr_str:\n            raise ValueError(\n                \"No WCS header found in dataset. Expected 'fits_wcs_header' \"\n                \"attribute on variable/dataset or 'wcs_header_str' variable.\"\n            )\n\n        return WCS(Header.fromstring(hdr_str, sep=\"\\n\"))\n\n    @property\n    def has_wcs(self) -&gt; bool:\n        \"\"\"Check if WCS coordinate information is available.\n\n        Returns\n        -------\n        bool\n            True if WCS header is available in the dataset.\n\n        Example\n        -------\n        &gt;&gt;&gt; if ds.radport.has_wcs:\n        ...     fig = ds.radport.plot_wcs()\n        \"\"\"\n        try:\n            self._get_wcs()\n            return True\n        except (ImportError, ValueError):\n            return False\n\n    def pixel_to_coords(\n        self,\n        l_idx: int,\n        m_idx: int,\n    ) -&gt; tuple[float, float]:\n        \"\"\"Convert pixel indices to celestial coordinates (RA, Dec).\n\n        Parameters\n        ----------\n        l_idx : int\n            Index along the l dimension.\n        m_idx : int\n            Index along the m dimension.\n\n        Returns\n        -------\n        tuple of float\n            (ra, dec) in degrees. RA is in range [0, 360).\n\n        Raises\n        ------\n        ValueError\n            If WCS is not available or indices are out of bounds.\n\n        Example\n        -------\n        &gt;&gt;&gt; ra, dec = ds.radport.pixel_to_coords(100, 100)\n        &gt;&gt;&gt; print(f\"RA={ra:.2f}\u00b0, Dec={dec:.2f}\u00b0\")\n        \"\"\"\n        wcs = self._get_wcs()\n\n        # Validate indices\n        n_l = self._obj.sizes[\"l\"]\n        n_m = self._obj.sizes[\"m\"]\n        if not (0 &lt;= l_idx &lt; n_l):\n            raise ValueError(f\"l_idx={l_idx} out of bounds [0, {n_l})\")\n        if not (0 &lt;= m_idx &lt; n_m):\n            raise ValueError(f\"m_idx={m_idx} out of bounds [0, {n_m})\")\n\n        # WCS pixel_to_world expects (x, y) which is (l, m) in our convention\n        coord = wcs.pixel_to_world(l_idx, m_idx)\n        ra = float(coord.ra.wrap_at(\"360d\").deg)\n        dec = float(coord.dec.deg)\n\n        return ra, dec\n\n    def coords_to_pixel(\n        self,\n        ra: float,\n        dec: float,\n    ) -&gt; tuple[int, int]:\n        \"\"\"Convert celestial coordinates (RA, Dec) to pixel indices.\n\n        Parameters\n        ----------\n        ra : float\n            Right Ascension in degrees.\n        dec : float\n            Declination in degrees.\n\n        Returns\n        -------\n        tuple of int\n            (l_idx, m_idx) pixel indices (rounded to nearest integer).\n\n        Raises\n        ------\n        ValueError\n            If WCS is not available or coordinates are outside the image.\n\n        Example\n        -------\n        &gt;&gt;&gt; l_idx, m_idx = ds.radport.coords_to_pixel(180.0, 45.0)\n        \"\"\"\n        try:\n            from astropy.coordinates import SkyCoord\n            from astropy import units as u\n        except ImportError as e:\n            raise ImportError(\n                \"astropy is required for coordinate transformations.\"\n            ) from e\n\n        wcs = self._get_wcs()\n\n        coord = SkyCoord(ra=ra * u.deg, dec=dec * u.deg, frame=\"fk5\")\n        x, y = wcs.world_to_pixel(coord)\n\n        l_idx = int(round(float(x)))\n        m_idx = int(round(float(y)))\n\n        # Validate result is within bounds\n        n_l = self._obj.sizes[\"l\"]\n        n_m = self._obj.sizes[\"m\"]\n        if not (0 &lt;= l_idx &lt; n_l) or not (0 &lt;= m_idx &lt; n_m):\n            raise ValueError(\n                f\"Coordinates (RA={ra}, Dec={dec}) map to pixel ({l_idx}, {m_idx}) \"\n                f\"which is outside image bounds [0, {n_l}) x [0, {n_m})\"\n            )\n\n        return l_idx, m_idx\n\n    def plot_wcs(\n        self,\n        var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n        time_idx: int = 0,\n        freq_idx: int = 0,\n        freq_mhz: float | None = None,\n        pol: int = 0,\n        cmap: str = \"inferno\",\n        vmin: float | None = None,\n        vmax: float | None = None,\n        robust: bool = True,\n        mask_radius: int | None = None,\n        figsize: tuple[float, float] = (10, 10),\n        add_colorbar: bool = True,\n        grid_color: str = \"white\",\n        grid_alpha: float = 0.6,\n        grid_linestyle: str = \":\",\n        label_color: str = \"white\",\n        facecolor: str = \"black\",\n        **kwargs: Any,\n    ) -&gt; Figure:\n        \"\"\"Plot with WCS projection and celestial coordinate grid.\n\n        Creates a publication-quality plot with RA/Dec coordinate axes\n        and optional grid overlay.\n\n        Parameters\n        ----------\n        var : {'SKY', 'BEAM'}, default 'SKY'\n            Data variable to plot.\n        time_idx : int, default 0\n            Time index.\n        freq_idx : int, default 0\n            Frequency index. Ignored if `freq_mhz` is provided.\n        freq_mhz : float, optional\n            Frequency in MHz (overrides freq_idx).\n        pol : int, default 0\n            Polarization index.\n        cmap : str, default 'inferno'\n            Colormap name.\n        vmin, vmax : float, optional\n            Color scale limits.\n        robust : bool, default True\n            Use 2nd/98th percentile for scaling.\n        mask_radius : int, optional\n            Circular mask radius in pixels.\n        figsize : tuple, default (10, 10)\n            Figure size in inches.\n        add_colorbar : bool, default True\n            Whether to add colorbar.\n        grid_color : str, default 'white'\n            Color of coordinate grid lines.\n        grid_alpha : float, default 0.6\n            Transparency of grid lines.\n        grid_linestyle : str, default ':'\n            Line style for grid.\n        label_color : str, default 'white'\n            Color for axis labels and ticks.\n        facecolor : str, default 'black'\n            Background color for the plot.\n        **kwargs : dict\n            Additional arguments passed to imshow.\n\n        Returns\n        -------\n        matplotlib.figure.Figure\n\n        Raises\n        ------\n        ValueError\n            If WCS is not available in the dataset.\n\n        Example\n        -------\n        &gt;&gt;&gt; fig = ds.radport.plot_wcs(freq_mhz=50.0, mask_radius=1800)\n        \"\"\"\n        try:\n            from astropy import units as u\n        except ImportError as e:\n            raise ImportError(\n                \"astropy is required for WCS plotting.\"\n            ) from e\n\n        if var not in self._obj.data_vars:\n            available = sorted(self._obj.data_vars)\n            raise ValueError(f\"Variable '{var}' not found. Available: {available}\")\n\n        wcs = self._get_wcs(var)\n\n        # Resolve frequency index\n        if freq_mhz is not None:\n            fi = self.nearest_freq_idx(freq_mhz)\n        else:\n            fi = freq_idx\n\n        # Extract data\n        da = self._obj[var].isel(\n            time=time_idx, frequency=fi, polarization=pol\n        )\n\n        # Ensure proper dimension order (m, l) for imshow\n        if set(da.dims) == {\"m\", \"l\"}:\n            da = da.transpose(\"m\", \"l\")\n\n        data = da.values.astype(float).copy()\n\n        # Apply mask if requested\n        if mask_radius is not None:\n            ny, nx = data.shape\n            cy, cx = ny // 2, nx // 2\n            yy, xx = np.ogrid[:ny, :nx]\n            dist = np.sqrt((yy - cy) ** 2 + (xx - cx) ** 2)\n            data[dist &gt; mask_radius] = np.nan\n\n        # Compute vmin/vmax if robust\n        if robust and vmin is None and vmax is None:\n            finite = data[np.isfinite(data)]\n            if finite.size &gt; 0:\n                vmin = float(np.percentile(finite, 2))\n                vmax = float(np.percentile(finite, 98))\n\n        # Set up colormap with bad values as black\n        cmap_obj = plt.get_cmap(cmap).copy()\n        cmap_obj.set_bad(facecolor, 1.0)\n\n        # Create figure with WCS projection\n        fig = plt.figure(figsize=figsize, facecolor=facecolor)\n        ax = fig.add_subplot(111, projection=wcs, facecolor=facecolor)\n\n        # Plot image\n        im = ax.imshow(\n            data,\n            origin=\"lower\",\n            cmap=cmap_obj,\n            vmin=vmin,\n            vmax=vmax,\n            **kwargs,\n        )\n\n        # Configure axes\n        ax.set_xlabel(\"RA\", color=label_color, fontsize=12)\n        ax.set_ylabel(\"Dec\", color=label_color, fontsize=12)\n\n        # Check if RA needs to be inverted (increases to left in sky)\n        try:\n            cdelt1 = float(wcs.wcs.cdelt[0])\n            if np.isfinite(cdelt1) and cdelt1 &gt; 0:\n                ax.invert_xaxis()\n        except (AttributeError, IndexError):\n            pass\n\n        # Add coordinate grid\n        overlay = ax.get_coords_overlay(\"fk5\")\n        overlay.grid(color=grid_color, ls=grid_linestyle, lw=1.0, alpha=grid_alpha)\n\n        # Configure tick labels\n        for coord in overlay:\n            coord.set_ticklabel_visible(True)\n            coord.set_ticklabel(color=label_color, size=10)\n            coord.tick_params(width=1, color=label_color)\n\n        # Add colorbar\n        if add_colorbar:\n            cbar = fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04)\n            cbar.set_label(\"Jy/beam\", color=label_color, fontsize=11)\n            cbar.ax.tick_params(color=label_color, labelcolor=label_color)\n            cbar.outline.set_edgecolor(label_color)\n\n        # Add title\n        freq_hz = float(self._obj.coords[\"frequency\"].values[fi])\n        time_val = self._obj.coords[\"time\"].values[time_idx]\n        try:\n            time_str = f\"{float(time_val):.6f}\"\n        except (TypeError, ValueError):\n            time_str = str(time_val)\n\n        ax.set_title(\n            f\"{var} at t={time_str} MJD, f={freq_hz/1e6:.2f} MHz, pol={pol}\",\n            color=label_color,\n            fontsize=12,\n            pad=10,\n        )\n\n        return fig\n\n    # =========================================================================\n    # Phase F: Animation &amp; Export Methods\n    # =========================================================================\n\n    def animate_time(\n        self,\n        freq_idx: int | None = None,\n        freq_mhz: float | None = None,\n        var: str = \"SKY\",\n        pol: int = 0,\n        output_file: str | None = None,\n        fps: int = 5,\n        cmap: str = \"inferno\",\n        vmin: float | None = None,\n        vmax: float | None = None,\n        robust: bool = True,\n        mask_radius: int | None = None,\n        figsize: tuple[float, float] = (8, 6),\n        dpi: int = 100,\n        **kwargs: Any,\n    ) -&gt; Any:\n        \"\"\"Create an animation showing time evolution at a fixed frequency.\n\n        Parameters\n        ----------\n        freq_idx : int, optional\n            Frequency index to animate. Defaults to 0 if neither freq_idx\n            nor freq_mhz is provided.\n        freq_mhz : float, optional\n            Select frequency by value in MHz. Overrides freq_idx if provided.\n        var : str, default \"SKY\"\n            Data variable to animate (\"SKY\" or \"BEAM\").\n        pol : int, default 0\n            Polarization index.\n        output_file : str, optional\n            Path to save the animation. Supported formats: .mp4, .gif.\n            If None, returns the animation object for display in notebooks.\n        fps : int, default 5\n            Frames per second for the animation.\n        cmap : str, default \"inferno\"\n            Matplotlib colormap name.\n        vmin : float, optional\n            Minimum value for color scaling. If None and robust=True,\n            uses 2nd percentile across all frames.\n        vmax : float, optional\n            Maximum value for color scaling. If None and robust=True,\n            uses 98th percentile across all frames.\n        robust : bool, default True\n            Use percentile-based color scaling across all frames.\n        mask_radius : int, optional\n            Apply circular mask with this radius in pixels.\n        figsize : tuple, default (8, 6)\n            Figure size in inches.\n        dpi : int, default 100\n            Resolution for saved animation.\n        **kwargs\n            Additional arguments passed to FuncAnimation.\n\n        Returns\n        -------\n        matplotlib.animation.FuncAnimation\n            Animation object. Can be displayed in notebooks with HTML(anim.to_jshtml())\n            or saved to file.\n\n        Raises\n        ------\n        ValueError\n            If the specified variable doesn't exist in the dataset.\n\n        Example\n        -------\n        &gt;&gt;&gt; # Create animation and save to file\n        &gt;&gt;&gt; anim = ds.radport.animate_time(freq_mhz=50.0, output_file=\"time_evolution.mp4\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Display in Jupyter notebook\n        &gt;&gt;&gt; from IPython.display import HTML\n        &gt;&gt;&gt; anim = ds.radport.animate_time(freq_mhz=50.0)\n        &gt;&gt;&gt; HTML(anim.to_jshtml())\n        \"\"\"\n        from matplotlib.animation import FuncAnimation\n\n        # Validate variable\n        if var not in self._obj.data_vars:\n            raise ValueError(\n                f\"Variable '{var}' not found in dataset. \"\n                f\"Available variables: {list(self._obj.data_vars)}.\"\n            )\n\n        # Resolve frequency index\n        if freq_mhz is not None:\n            fi = self.nearest_freq_idx(freq_mhz)\n        elif freq_idx is not None:\n            fi = freq_idx\n        else:\n            fi = 0\n\n        # Get data for all time steps\n        data = self._obj[var].isel(frequency=fi, polarization=pol)\n        n_times = len(self._obj.coords[\"time\"])\n\n        # Compute global color scale from all frames\n        if vmin is None or vmax is None:\n            all_values = data.values.ravel()\n            finite_values = all_values[np.isfinite(all_values)]\n            if len(finite_values) &gt; 0:\n                if robust:\n                    computed_vmin = np.percentile(finite_values, 2)\n                    computed_vmax = np.percentile(finite_values, 98)\n                else:\n                    computed_vmin = np.nanmin(finite_values)\n                    computed_vmax = np.nanmax(finite_values)\n            else:\n                computed_vmin, computed_vmax = 0, 1\n\n            if vmin is None:\n                vmin = computed_vmin\n            if vmax is None:\n                vmax = computed_vmax\n\n        # Create mask if requested\n        mask = None\n        if mask_radius is not None:\n            nl = len(self._obj.coords[\"l\"])\n            nm = len(self._obj.coords[\"m\"])\n            center_l, center_m = nl // 2, nm // 2\n            l_idx, m_idx = np.ogrid[:nl, :nm]\n            dist = np.sqrt((l_idx - center_l) ** 2 + (m_idx - center_m) ** 2)\n            mask = dist &gt; mask_radius\n\n        # Create figure and initial plot\n        fig, ax = plt.subplots(figsize=figsize)\n\n        frame_data = data.isel(time=0).values.copy()\n        if mask is not None:\n            frame_data[mask] = np.nan\n\n        im = ax.imshow(\n            frame_data.T,\n            origin=\"lower\",\n            cmap=cmap,\n            vmin=vmin,\n            vmax=vmax,\n            aspect=\"equal\",\n        )\n\n        # Add colorbar\n        cbar = fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04)\n        cbar.set_label(\"Jy/beam\", fontsize=11)\n\n        # Labels\n        ax.set_xlabel(\"l index\", fontsize=11)\n        ax.set_ylabel(\"m index\", fontsize=11)\n\n        freq_hz = float(self._obj.coords[\"frequency\"].values[fi])\n\n        def update(frame: int) -&gt; tuple:\n            \"\"\"Update function for animation.\"\"\"\n            frame_data = data.isel(time=frame).values.copy()\n            if mask is not None:\n                frame_data[mask] = np.nan\n            im.set_array(frame_data.T)\n\n            time_val = self._obj.coords[\"time\"].values[frame]\n            try:\n                time_str = f\"{float(time_val):.6f}\"\n            except (TypeError, ValueError):\n                time_str = str(time_val)\n\n            ax.set_title(\n                f\"{var} at f={freq_hz/1e6:.2f} MHz, pol={pol}\\n\"\n                f\"Time: {time_str} MJD (frame {frame + 1}/{n_times})\",\n                fontsize=11,\n            )\n            return (im,)\n\n        # Create animation\n        anim = FuncAnimation(\n            fig,\n            update,\n            frames=n_times,\n            interval=1000 // fps,\n            blit=True,\n            **kwargs,\n        )\n\n        # Save if output file specified\n        if output_file is not None:\n            if output_file.endswith(\".gif\"):\n                anim.save(output_file, writer=\"pillow\", fps=fps, dpi=dpi)\n            else:\n                anim.save(output_file, writer=\"ffmpeg\", fps=fps, dpi=dpi)\n            plt.close(fig)\n\n        return anim\n\n    def animate_frequency(\n        self,\n        time_idx: int | None = None,\n        time_mjd: float | None = None,\n        var: str = \"SKY\",\n        pol: int = 0,\n        output_file: str | None = None,\n        fps: int = 5,\n        cmap: str = \"inferno\",\n        vmin: float | None = None,\n        vmax: float | None = None,\n        robust: bool = True,\n        mask_radius: int | None = None,\n        figsize: tuple[float, float] = (8, 6),\n        dpi: int = 100,\n        **kwargs: Any,\n    ) -&gt; Any:\n        \"\"\"Create an animation showing frequency sweep at a fixed time.\n\n        Parameters\n        ----------\n        time_idx : int, optional\n            Time index to animate. Defaults to 0 if neither time_idx\n            nor time_mjd is provided.\n        time_mjd : float, optional\n            Select time by MJD value. Overrides time_idx if provided.\n        var : str, default \"SKY\"\n            Data variable to animate (\"SKY\" or \"BEAM\").\n        pol : int, default 0\n            Polarization index.\n        output_file : str, optional\n            Path to save the animation. Supported formats: .mp4, .gif.\n            If None, returns the animation object for display in notebooks.\n        fps : int, default 5\n            Frames per second for the animation.\n        cmap : str, default \"inferno\"\n            Matplotlib colormap name.\n        vmin : float, optional\n            Minimum value for color scaling. If None and robust=True,\n            uses 2nd percentile across all frames.\n        vmax : float, optional\n            Maximum value for color scaling. If None and robust=True,\n            uses 98th percentile across all frames.\n        robust : bool, default True\n            Use percentile-based color scaling across all frames.\n        mask_radius : int, optional\n            Apply circular mask with this radius in pixels.\n        figsize : tuple, default (8, 6)\n            Figure size in inches.\n        dpi : int, default 100\n            Resolution for saved animation.\n        **kwargs\n            Additional arguments passed to FuncAnimation.\n\n        Returns\n        -------\n        matplotlib.animation.FuncAnimation\n            Animation object. Can be displayed in notebooks with HTML(anim.to_jshtml())\n            or saved to file.\n\n        Raises\n        ------\n        ValueError\n            If the specified variable doesn't exist in the dataset.\n\n        Example\n        -------\n        &gt;&gt;&gt; # Create animation and save to file\n        &gt;&gt;&gt; anim = ds.radport.animate_frequency(time_idx=0, output_file=\"freq_sweep.gif\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Display in Jupyter notebook\n        &gt;&gt;&gt; from IPython.display import HTML\n        &gt;&gt;&gt; anim = ds.radport.animate_frequency(time_idx=0)\n        &gt;&gt;&gt; HTML(anim.to_jshtml())\n        \"\"\"\n        from matplotlib.animation import FuncAnimation\n\n        # Validate variable\n        if var not in self._obj.data_vars:\n            raise ValueError(\n                f\"Variable '{var}' not found in dataset. \"\n                f\"Available variables: {list(self._obj.data_vars)}.\"\n            )\n\n        # Resolve time index\n        if time_mjd is not None:\n            ti = self.nearest_time_idx(time_mjd)\n        elif time_idx is not None:\n            ti = time_idx\n        else:\n            ti = 0\n\n        # Get data for all frequencies\n        data = self._obj[var].isel(time=ti, polarization=pol)\n        n_freqs = len(self._obj.coords[\"frequency\"])\n        freqs_hz = self._obj.coords[\"frequency\"].values\n\n        # Compute global color scale from all frames\n        if vmin is None or vmax is None:\n            all_values = data.values.ravel()\n            finite_values = all_values[np.isfinite(all_values)]\n            if len(finite_values) &gt; 0:\n                if robust:\n                    computed_vmin = np.percentile(finite_values, 2)\n                    computed_vmax = np.percentile(finite_values, 98)\n                else:\n                    computed_vmin = np.nanmin(finite_values)\n                    computed_vmax = np.nanmax(finite_values)\n            else:\n                computed_vmin, computed_vmax = 0, 1\n\n            if vmin is None:\n                vmin = computed_vmin\n            if vmax is None:\n                vmax = computed_vmax\n\n        # Create mask if requested\n        mask = None\n        if mask_radius is not None:\n            nl = len(self._obj.coords[\"l\"])\n            nm = len(self._obj.coords[\"m\"])\n            center_l, center_m = nl // 2, nm // 2\n            l_idx, m_idx = np.ogrid[:nl, :nm]\n            dist = np.sqrt((l_idx - center_l) ** 2 + (m_idx - center_m) ** 2)\n            mask = dist &gt; mask_radius\n\n        # Create figure and initial plot\n        fig, ax = plt.subplots(figsize=figsize)\n\n        frame_data = data.isel(frequency=0).values.copy()\n        if mask is not None:\n            frame_data[mask] = np.nan\n\n        im = ax.imshow(\n            frame_data.T,\n            origin=\"lower\",\n            cmap=cmap,\n            vmin=vmin,\n            vmax=vmax,\n            aspect=\"equal\",\n        )\n\n        # Add colorbar\n        cbar = fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04)\n        cbar.set_label(\"Jy/beam\", fontsize=11)\n\n        # Labels\n        ax.set_xlabel(\"l index\", fontsize=11)\n        ax.set_ylabel(\"m index\", fontsize=11)\n\n        time_val = self._obj.coords[\"time\"].values[ti]\n        try:\n            time_str = f\"{float(time_val):.6f}\"\n        except (TypeError, ValueError):\n            time_str = str(time_val)\n\n        def update(frame: int) -&gt; tuple:\n            \"\"\"Update function for animation.\"\"\"\n            frame_data = data.isel(frequency=frame).values.copy()\n            if mask is not None:\n                frame_data[mask] = np.nan\n            im.set_array(frame_data.T)\n\n            freq_hz = float(freqs_hz[frame])\n            ax.set_title(\n                f\"{var} at t={time_str} MJD, pol={pol}\\n\"\n                f\"Frequency: {freq_hz/1e6:.2f} MHz (channel {frame + 1}/{n_freqs})\",\n                fontsize=11,\n            )\n            return (im,)\n\n        # Create animation\n        anim = FuncAnimation(\n            fig,\n            update,\n            frames=n_freqs,\n            interval=1000 // fps,\n            blit=True,\n            **kwargs,\n        )\n\n        # Save if output file specified\n        if output_file is not None:\n            if output_file.endswith(\".gif\"):\n                anim.save(output_file, writer=\"pillow\", fps=fps, dpi=dpi)\n            else:\n                anim.save(output_file, writer=\"ffmpeg\", fps=fps, dpi=dpi)\n            plt.close(fig)\n\n        return anim\n\n    def export_frames(\n        self,\n        output_dir: str,\n        var: str = \"SKY\",\n        pol: int = 0,\n        time_indices: list[int] | None = None,\n        freq_indices: list[int] | None = None,\n        format: str = \"png\",\n        cmap: str = \"inferno\",\n        vmin: float | None = None,\n        vmax: float | None = None,\n        robust: bool = True,\n        mask_radius: int | None = None,\n        figsize: tuple[float, float] = (8, 6),\n        dpi: int = 150,\n        filename_template: str = \"{var}_t{time_idx:04d}_f{freq_idx:04d}.{format}\",\n    ) -&gt; list[str]:\n        \"\"\"Export all (time, freq) frames as individual image files.\n\n        Parameters\n        ----------\n        output_dir : str\n            Directory to save the image files. Will be created if it doesn't exist.\n        var : str, default \"SKY\"\n            Data variable to export (\"SKY\" or \"BEAM\").\n        pol : int, default 0\n            Polarization index.\n        time_indices : list of int, optional\n            Time indices to export. If None, exports all times.\n        freq_indices : list of int, optional\n            Frequency indices to export. If None, exports all frequencies.\n        format : str, default \"png\"\n            Image format (e.g., \"png\", \"jpg\", \"pdf\").\n        cmap : str, default \"inferno\"\n            Matplotlib colormap name.\n        vmin : float, optional\n            Minimum value for color scaling. If None and robust=True,\n            uses 2nd percentile across all exported frames.\n        vmax : float, optional\n            Maximum value for color scaling. If None and robust=True,\n            uses 98th percentile across all exported frames.\n        robust : bool, default True\n            Use percentile-based color scaling across all exported frames.\n        mask_radius : int, optional\n            Apply circular mask with this radius in pixels.\n        figsize : tuple, default (8, 6)\n            Figure size in inches.\n        dpi : int, default 150\n            Resolution for saved images.\n        filename_template : str, default \"{var}_t{time_idx:04d}_f{freq_idx:04d}.{format}\"\n            Template for filenames. Available placeholders: {var}, {time_idx},\n            {freq_idx}, {time_mjd}, {freq_mhz}, {format}.\n\n        Returns\n        -------\n        list of str\n            List of paths to the saved image files.\n\n        Raises\n        ------\n        ValueError\n            If the specified variable doesn't exist in the dataset.\n\n        Example\n        -------\n        &gt;&gt;&gt; # Export all frames\n        &gt;&gt;&gt; files = ds.radport.export_frames(\"./frames\")\n        &gt;&gt;&gt; print(f\"Exported {len(files)} frames\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Export specific time/frequency combinations\n        &gt;&gt;&gt; files = ds.radport.export_frames(\n        ...     \"./frames\",\n        ...     time_indices=[0, 1, 2],\n        ...     freq_indices=[0, 5, 10],\n        ... )\n        \"\"\"\n        import os\n\n        # Validate variable\n        if var not in self._obj.data_vars:\n            raise ValueError(\n                f\"Variable '{var}' not found in dataset. \"\n                f\"Available variables: {list(self._obj.data_vars)}.\"\n            )\n\n        # Create output directory\n        os.makedirs(output_dir, exist_ok=True)\n\n        # Get indices to export\n        if time_indices is None:\n            time_indices = list(range(len(self._obj.coords[\"time\"])))\n        if freq_indices is None:\n            freq_indices = list(range(len(self._obj.coords[\"frequency\"])))\n\n        # Get coordinate values for labels\n        time_values = self._obj.coords[\"time\"].values\n        freq_values = self._obj.coords[\"frequency\"].values\n\n        # Compute global color scale from all frames to export\n        if vmin is None or vmax is None:\n            all_values = []\n            for ti in time_indices:\n                for fi in freq_indices:\n                    frame_data = self._obj[var].isel(\n                        time=ti, frequency=fi, polarization=pol\n                    ).values\n                    all_values.extend(frame_data.ravel())\n\n            all_values = np.array(all_values)\n            finite_values = all_values[np.isfinite(all_values)]\n            if len(finite_values) &gt; 0:\n                if robust:\n                    computed_vmin = np.percentile(finite_values, 2)\n                    computed_vmax = np.percentile(finite_values, 98)\n                else:\n                    computed_vmin = np.nanmin(finite_values)\n                    computed_vmax = np.nanmax(finite_values)\n            else:\n                computed_vmin, computed_vmax = 0, 1\n\n            if vmin is None:\n                vmin = computed_vmin\n            if vmax is None:\n                vmax = computed_vmax\n\n        # Create mask if requested\n        mask = None\n        if mask_radius is not None:\n            nl = len(self._obj.coords[\"l\"])\n            nm = len(self._obj.coords[\"m\"])\n            center_l, center_m = nl // 2, nm // 2\n            l_idx, m_idx = np.ogrid[:nl, :nm]\n            dist = np.sqrt((l_idx - center_l) ** 2 + (m_idx - center_m) ** 2)\n            mask = dist &gt; mask_radius\n\n        # Export frames\n        exported_files = []\n\n        for ti in time_indices:\n            for fi in freq_indices:\n                # Get frame data\n                frame_data = self._obj[var].isel(\n                    time=ti, frequency=fi, polarization=pol\n                ).values.copy()\n\n                if mask is not None:\n                    frame_data[mask] = np.nan\n\n                # Create figure\n                fig, ax = plt.subplots(figsize=figsize)\n\n                im = ax.imshow(\n                    frame_data.T,\n                    origin=\"lower\",\n                    cmap=cmap,\n                    vmin=vmin,\n                    vmax=vmax,\n                    aspect=\"equal\",\n                )\n\n                # Add colorbar\n                cbar = fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04)\n                cbar.set_label(\"Jy/beam\", fontsize=11)\n\n                # Labels\n                ax.set_xlabel(\"l index\", fontsize=11)\n                ax.set_ylabel(\"m index\", fontsize=11)\n\n                # Title\n                time_val = time_values[ti]\n                freq_hz = float(freq_values[fi])\n                try:\n                    time_str = f\"{float(time_val):.6f}\"\n                except (TypeError, ValueError):\n                    time_str = str(time_val)\n\n                ax.set_title(\n                    f\"{var} at t={time_str} MJD, f={freq_hz/1e6:.2f} MHz, pol={pol}\",\n                    fontsize=11,\n                )\n\n                # Generate filename\n                try:\n                    time_mjd = float(time_val)\n                except (TypeError, ValueError):\n                    time_mjd = 0.0\n\n                filename = filename_template.format(\n                    var=var,\n                    time_idx=ti,\n                    freq_idx=fi,\n                    time_mjd=time_mjd,\n                    freq_mhz=freq_hz / 1e6,\n                    format=format,\n                )\n                filepath = os.path.join(output_dir, filename)\n\n                # Save figure\n                fig.savefig(filepath, dpi=dpi, bbox_inches=\"tight\")\n                plt.close(fig)\n\n                exported_files.append(filepath)\n\n        return exported_files\n\n    # =========================================================================\n    # Phase G: Source Detection Methods\n    # =========================================================================\n\n    def rms_map(\n        self,\n        time_idx: int = 0,\n        freq_idx: int | None = None,\n        freq_mhz: float | None = None,\n        var: str = \"SKY\",\n        pol: int = 0,\n        box_size: int = 50,\n    ) -&gt; xr.DataArray:\n        \"\"\"Compute local RMS noise estimate map using a sliding box.\n\n        The RMS is computed using a uniform filter approach where each pixel's\n        RMS is estimated from the surrounding box_size x box_size region.\n\n        Parameters\n        ----------\n        time_idx : int, default 0\n            Time index for the frame.\n        freq_idx : int, optional\n            Frequency index for the frame. Defaults to 0 if neither freq_idx\n            nor freq_mhz is provided.\n        freq_mhz : float, optional\n            Select frequency by value in MHz. Overrides freq_idx if provided.\n        var : str, default \"SKY\"\n            Data variable to analyze (\"SKY\" or \"BEAM\").\n        pol : int, default 0\n            Polarization index.\n        box_size : int, default 50\n            Size of the sliding box for local RMS computation.\n\n        Returns\n        -------\n        xr.DataArray\n            2D array of local RMS values with dimensions (l, m).\n\n        Raises\n        ------\n        ValueError\n            If the specified variable doesn't exist in the dataset.\n\n        Example\n        -------\n        &gt;&gt;&gt; rms = ds.radport.rms_map(freq_mhz=50.0, box_size=100)\n        &gt;&gt;&gt; rms.plot()\n        \"\"\"\n        from scipy.ndimage import uniform_filter\n\n        # Validate variable\n        if var not in self._obj.data_vars:\n            raise ValueError(\n                f\"Variable '{var}' not found in dataset. \"\n                f\"Available variables: {list(self._obj.data_vars)}.\"\n            )\n\n        # Resolve frequency index\n        if freq_mhz is not None:\n            fi = self.nearest_freq_idx(freq_mhz)\n        elif freq_idx is not None:\n            fi = freq_idx\n        else:\n            fi = 0\n\n        # Get frame data\n        data = self._obj[var].isel(\n            time=time_idx, frequency=fi, polarization=pol\n        ).values.astype(float)\n\n        # Replace NaN with 0 for filtering (we'll handle NaN regions later)\n        nan_mask = ~np.isfinite(data)\n        data_filled = np.where(nan_mask, 0.0, data)\n\n        # Compute local mean and mean of squares\n        local_mean = uniform_filter(data_filled, size=box_size, mode=\"constant\")\n        local_mean_sq = uniform_filter(data_filled**2, size=box_size, mode=\"constant\")\n\n        # Count valid pixels in each box\n        valid_count = uniform_filter(\n            (~nan_mask).astype(float), size=box_size, mode=\"constant\"\n        )\n        valid_count = np.maximum(valid_count, 1e-10)  # Avoid division by zero\n\n        # Correct for the fact that we filled NaN with 0\n        local_mean = local_mean / valid_count * (box_size**2)\n        local_mean_sq = local_mean_sq / valid_count * (box_size**2)\n\n        # Compute variance: E[X^2] - E[X]^2\n        local_var = local_mean_sq - local_mean**2\n        local_var = np.maximum(local_var, 0.0)  # Ensure non-negative\n\n        # RMS is sqrt of variance\n        rms = np.sqrt(local_var)\n\n        # Restore NaN where original was NaN\n        rms[nan_mask] = np.nan\n\n        # Create DataArray with coordinates\n        return xr.DataArray(\n            rms,\n            dims=[\"l\", \"m\"],\n            coords={\n                \"l\": self._obj.coords[\"l\"],\n                \"m\": self._obj.coords[\"m\"],\n            },\n            name=\"rms\",\n            attrs={\n                \"long_name\": \"Local RMS noise estimate\",\n                \"units\": \"Jy/beam\",\n                \"box_size\": box_size,\n            },\n        )\n\n    def snr_map(\n        self,\n        time_idx: int = 0,\n        freq_idx: int | None = None,\n        freq_mhz: float | None = None,\n        var: str = \"SKY\",\n        pol: int = 0,\n        box_size: int = 50,\n    ) -&gt; xr.DataArray:\n        \"\"\"Compute signal-to-noise ratio map.\n\n        The SNR is computed as the signal divided by the local RMS noise\n        estimate from a sliding box.\n\n        Parameters\n        ----------\n        time_idx : int, default 0\n            Time index for the frame.\n        freq_idx : int, optional\n            Frequency index for the frame. Defaults to 0 if neither freq_idx\n            nor freq_mhz is provided.\n        freq_mhz : float, optional\n            Select frequency by value in MHz. Overrides freq_idx if provided.\n        var : str, default \"SKY\"\n            Data variable to analyze (\"SKY\" or \"BEAM\").\n        pol : int, default 0\n            Polarization index.\n        box_size : int, default 50\n            Size of the sliding box for local RMS computation.\n\n        Returns\n        -------\n        xr.DataArray\n            2D array of SNR values with dimensions (l, m).\n\n        Raises\n        ------\n        ValueError\n            If the specified variable doesn't exist in the dataset.\n\n        Example\n        -------\n        &gt;&gt;&gt; snr = ds.radport.snr_map(freq_mhz=50.0)\n        &gt;&gt;&gt; # Find pixels with SNR &gt; 5\n        &gt;&gt;&gt; significant = snr.where(snr &gt; 5)\n        \"\"\"\n        # Validate variable\n        if var not in self._obj.data_vars:\n            raise ValueError(\n                f\"Variable '{var}' not found in dataset. \"\n                f\"Available variables: {list(self._obj.data_vars)}.\"\n            )\n\n        # Resolve frequency index\n        if freq_mhz is not None:\n            fi = self.nearest_freq_idx(freq_mhz)\n        elif freq_idx is not None:\n            fi = freq_idx\n        else:\n            fi = 0\n\n        # Get signal\n        signal = self._obj[var].isel(\n            time=time_idx, frequency=fi, polarization=pol\n        ).values.astype(float)\n\n        # Get RMS map\n        rms = self.rms_map(\n            time_idx=time_idx,\n            freq_idx=fi,\n            var=var,\n            pol=pol,\n            box_size=box_size,\n        ).values\n\n        # Compute SNR (avoiding division by zero)\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            snr = signal / rms\n            snr[~np.isfinite(snr)] = np.nan\n\n        # Create DataArray with coordinates\n        return xr.DataArray(\n            snr,\n            dims=[\"l\", \"m\"],\n            coords={\n                \"l\": self._obj.coords[\"l\"],\n                \"m\": self._obj.coords[\"m\"],\n            },\n            name=\"snr\",\n            attrs={\n                \"long_name\": \"Signal-to-noise ratio\",\n                \"units\": \"\",\n                \"box_size\": box_size,\n            },\n        )\n\n    def find_peaks(\n        self,\n        time_idx: int = 0,\n        freq_idx: int | None = None,\n        freq_mhz: float | None = None,\n        var: str = \"SKY\",\n        pol: int = 0,\n        threshold_sigma: float = 5.0,\n        box_size: int = 50,\n        min_separation: int = 5,\n    ) -&gt; list[dict]:\n        \"\"\"Find peaks above threshold in the image.\n\n        Identifies local maxima that exceed the specified SNR threshold.\n        Uses local maximum detection with minimum separation between peaks.\n\n        Parameters\n        ----------\n        time_idx : int, default 0\n            Time index for the frame.\n        freq_idx : int, optional\n            Frequency index for the frame. Defaults to 0 if neither freq_idx\n            nor freq_mhz is provided.\n        freq_mhz : float, optional\n            Select frequency by value in MHz. Overrides freq_idx if provided.\n        var : str, default \"SKY\"\n            Data variable to analyze (\"SKY\" or \"BEAM\").\n        pol : int, default 0\n            Polarization index.\n        threshold_sigma : float, default 5.0\n            Minimum SNR threshold for peak detection.\n        box_size : int, default 50\n            Size of the sliding box for local RMS computation.\n        min_separation : int, default 5\n            Minimum separation between peaks in pixels.\n\n        Returns\n        -------\n        list of dict\n            List of detected peaks, each with keys:\n            - l: l coordinate value\n            - m: m coordinate value\n            - l_idx: l pixel index\n            - m_idx: m pixel index\n            - flux: peak flux value (Jy/beam)\n            - snr: signal-to-noise ratio\n\n        Raises\n        ------\n        ValueError\n            If the specified variable doesn't exist in the dataset.\n\n        Example\n        -------\n        &gt;&gt;&gt; peaks = ds.radport.find_peaks(freq_mhz=50.0, threshold_sigma=5.0)\n        &gt;&gt;&gt; print(f\"Found {len(peaks)} peaks\")\n        &gt;&gt;&gt; for p in peaks[:5]:\n        ...     print(f\"  l={p['l']:.3f}, m={p['m']:.3f}, flux={p['flux']:.2f}, SNR={p['snr']:.1f}\")\n        \"\"\"\n        from scipy.ndimage import maximum_filter\n\n        # Validate variable\n        if var not in self._obj.data_vars:\n            raise ValueError(\n                f\"Variable '{var}' not found in dataset. \"\n                f\"Available variables: {list(self._obj.data_vars)}.\"\n            )\n\n        # Resolve frequency index\n        if freq_mhz is not None:\n            fi = self.nearest_freq_idx(freq_mhz)\n        elif freq_idx is not None:\n            fi = freq_idx\n        else:\n            fi = 0\n\n        # Get signal and SNR maps\n        signal = self._obj[var].isel(\n            time=time_idx, frequency=fi, polarization=pol\n        ).values.astype(float)\n\n        snr = self.snr_map(\n            time_idx=time_idx,\n            freq_idx=fi,\n            var=var,\n            pol=pol,\n            box_size=box_size,\n        ).values\n\n        # Find local maxima using maximum filter\n        # A pixel is a local max if it equals the max in its neighborhood\n        local_max = maximum_filter(signal, size=min_separation * 2 + 1)\n        is_local_max = (signal == local_max) &amp; np.isfinite(signal)\n\n        # Apply SNR threshold\n        is_peak = is_local_max &amp; (snr &gt;= threshold_sigma)\n\n        # Get peak locations\n        l_indices, m_indices = np.where(is_peak)\n\n        # Get coordinate values\n        l_coords = self._obj.coords[\"l\"].values\n        m_coords = self._obj.coords[\"m\"].values\n\n        # Build list of peaks sorted by SNR (descending)\n        peaks = []\n        for l_idx, m_idx in zip(l_indices, m_indices):\n            peaks.append(\n                {\n                    \"l\": float(l_coords[l_idx]),\n                    \"m\": float(m_coords[m_idx]),\n                    \"l_idx\": int(l_idx),\n                    \"m_idx\": int(m_idx),\n                    \"flux\": float(signal[l_idx, m_idx]),\n                    \"snr\": float(snr[l_idx, m_idx]),\n                }\n            )\n\n        # Sort by SNR descending\n        peaks.sort(key=lambda p: p[\"snr\"], reverse=True)\n\n        return peaks\n\n    def peak_flux_map(\n        self,\n        var: str = \"SKY\",\n        pol: int = 0,\n        freq_idx: int | None = None,\n        freq_mhz: float | None = None,\n    ) -&gt; xr.DataArray:\n        \"\"\"Compute peak flux at each pixel across all times.\n\n        For each (l, m) pixel, finds the maximum flux value across\n        all time steps at the specified frequency.\n\n        Parameters\n        ----------\n        var : str, default \"SKY\"\n            Data variable to analyze (\"SKY\" or \"BEAM\").\n        pol : int, default 0\n            Polarization index.\n        freq_idx : int, optional\n            Frequency index. Defaults to 0 if neither freq_idx\n            nor freq_mhz is provided.\n        freq_mhz : float, optional\n            Select frequency by value in MHz. Overrides freq_idx if provided.\n\n        Returns\n        -------\n        xr.DataArray\n            2D array of peak flux values with dimensions (l, m).\n\n        Raises\n        ------\n        ValueError\n            If the specified variable doesn't exist in the dataset.\n\n        Example\n        -------\n        &gt;&gt;&gt; # Find brightest emission at each pixel across all times\n        &gt;&gt;&gt; peak_map = ds.radport.peak_flux_map(freq_mhz=50.0)\n        &gt;&gt;&gt; peak_map.plot()\n        \"\"\"\n        # Validate variable\n        if var not in self._obj.data_vars:\n            raise ValueError(\n                f\"Variable '{var}' not found in dataset. \"\n                f\"Available variables: {list(self._obj.data_vars)}.\"\n            )\n\n        # Resolve frequency index\n        if freq_mhz is not None:\n            fi = self.nearest_freq_idx(freq_mhz)\n        elif freq_idx is not None:\n            fi = freq_idx\n        else:\n            fi = 0\n\n        # Get data for all times at this frequency\n        data = self._obj[var].isel(frequency=fi, polarization=pol)\n\n        # Compute max across time dimension\n        peak_flux = data.max(dim=\"time\", skipna=True)\n\n        # Update attributes\n        peak_flux.name = \"peak_flux\"\n        peak_flux.attrs = {\n            \"long_name\": \"Peak flux across time\",\n            \"units\": \"Jy/beam\",\n        }\n\n        return peak_flux\n\n    def plot_snr_map(\n        self,\n        time_idx: int = 0,\n        freq_idx: int | None = None,\n        freq_mhz: float | None = None,\n        var: str = \"SKY\",\n        pol: int = 0,\n        box_size: int = 50,\n        cmap: str = \"RdBu_r\",\n        vmin: float | None = None,\n        vmax: float | None = None,\n        mask_radius: int | None = None,\n        figsize: tuple[float, float] = (8, 6),\n        add_colorbar: bool = True,\n        symmetric: bool = True,\n    ) -&gt; \"Figure\":\n        \"\"\"Plot the signal-to-noise ratio map.\n\n        Parameters\n        ----------\n        time_idx : int, default 0\n            Time index for the frame.\n        freq_idx : int, optional\n            Frequency index for the frame.\n        freq_mhz : float, optional\n            Select frequency by value in MHz.\n        var : str, default \"SKY\"\n            Data variable to analyze.\n        pol : int, default 0\n            Polarization index.\n        box_size : int, default 50\n            Size of the sliding box for local RMS computation.\n        cmap : str, default \"RdBu_r\"\n            Colormap (diverging recommended for SNR).\n        vmin : float, optional\n            Minimum value for color scaling.\n        vmax : float, optional\n            Maximum value for color scaling.\n        mask_radius : int, optional\n            Apply circular mask with this radius in pixels.\n        figsize : tuple, default (8, 6)\n            Figure size in inches.\n        add_colorbar : bool, default True\n            Whether to add a colorbar.\n        symmetric : bool, default True\n            Use symmetric color scale centered at zero.\n\n        Returns\n        -------\n        matplotlib.figure.Figure\n            The generated figure.\n\n        Example\n        -------\n        &gt;&gt;&gt; fig = ds.radport.plot_snr_map(freq_mhz=50.0, mask_radius=1800)\n        \"\"\"\n        # Get SNR map\n        snr = self.snr_map(\n            time_idx=time_idx,\n            freq_idx=freq_idx,\n            freq_mhz=freq_mhz,\n            var=var,\n            pol=pol,\n            box_size=box_size,\n        )\n\n        snr_values = snr.values.copy()\n\n        # Apply mask if requested\n        if mask_radius is not None:\n            nl = len(self._obj.coords[\"l\"])\n            nm = len(self._obj.coords[\"m\"])\n            center_l, center_m = nl // 2, nm // 2\n            l_idx, m_idx = np.ogrid[:nl, :nm]\n            dist = np.sqrt((l_idx - center_l) ** 2 + (m_idx - center_m) ** 2)\n            mask = dist &gt; mask_radius\n            snr_values[mask] = np.nan\n\n        # Compute color scale\n        if symmetric and vmin is None and vmax is None:\n            finite_vals = snr_values[np.isfinite(snr_values)]\n            if len(finite_vals) &gt; 0:\n                max_abs = np.percentile(np.abs(finite_vals), 98)\n                vmin = -max_abs\n                vmax = max_abs\n\n        # Create figure\n        fig, ax = plt.subplots(figsize=figsize)\n\n        im = ax.imshow(\n            snr_values.T,\n            origin=\"lower\",\n            cmap=cmap,\n            vmin=vmin,\n            vmax=vmax,\n            aspect=\"equal\",\n        )\n\n        # Add colorbar\n        if add_colorbar:\n            cbar = fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04)\n            cbar.set_label(\"SNR (\u03c3)\", fontsize=11)\n\n        # Labels\n        ax.set_xlabel(\"l index\", fontsize=11)\n        ax.set_ylabel(\"m index\", fontsize=11)\n\n        # Get frequency for title\n        if freq_mhz is not None:\n            fi = self.nearest_freq_idx(freq_mhz)\n        elif freq_idx is not None:\n            fi = freq_idx\n        else:\n            fi = 0\n\n        freq_hz = float(self._obj.coords[\"frequency\"].values[fi])\n        time_val = self._obj.coords[\"time\"].values[time_idx]\n        try:\n            time_str = f\"{float(time_val):.6f}\"\n        except (TypeError, ValueError):\n            time_str = str(time_val)\n\n        ax.set_title(\n            f\"SNR Map at t={time_str} MJD, f={freq_hz/1e6:.2f} MHz\\n\"\n            f\"(box_size={box_size})\",\n            fontsize=11,\n        )\n\n        return fig\n\n    # =========================================================================\n    # Phase H: Spectral Analysis Methods\n    # =========================================================================\n\n    def spectral_index(\n        self,\n        l: float,\n        m: float,\n        time_idx: int = 0,\n        pol: int = 0,\n        freq1_mhz: float | None = None,\n        freq2_mhz: float | None = None,\n        freq1_idx: int | None = None,\n        freq2_idx: int | None = None,\n        var: str = \"SKY\",\n    ) -&gt; float:\n        \"\"\"Compute spectral index (power-law slope) between two frequencies.\n\n        The spectral index \u03b1 is defined by the power-law relationship S \u221d \u03bd^\u03b1,\n        computed as: \u03b1 = log(S2/S1) / log(\u03bd2/\u03bd1)\n\n        Parameters\n        ----------\n        l : float\n            The l coordinate value for the pixel location.\n        m : float\n            The m coordinate value for the pixel location.\n        time_idx : int, default 0\n            Time index for the measurement.\n        pol : int, default 0\n            Polarization index.\n        freq1_mhz : float, optional\n            First frequency in MHz. If not provided, uses freq1_idx or first channel.\n        freq2_mhz : float, optional\n            Second frequency in MHz. If not provided, uses freq2_idx or last channel.\n        freq1_idx : int, optional\n            First frequency index. Overridden by freq1_mhz if provided.\n        freq2_idx : int, optional\n            Second frequency index. Overridden by freq2_mhz if provided.\n        var : str, default \"SKY\"\n            Data variable to analyze.\n\n        Returns\n        -------\n        float\n            Spectral index \u03b1 where S \u221d \u03bd^\u03b1. Returns NaN if calculation\n            is not possible (e.g., non-positive flux values).\n\n        Raises\n        ------\n        ValueError\n            If the specified variable doesn't exist in the dataset.\n\n        Example\n        -------\n        &gt;&gt;&gt; # Compute spectral index at image center between 46 and 54 MHz\n        &gt;&gt;&gt; alpha = ds.radport.spectral_index(\n        ...     l=0.0, m=0.0,\n        ...     freq1_mhz=46.0,\n        ...     freq2_mhz=54.0,\n        ... )\n        &gt;&gt;&gt; print(f\"Spectral index: {alpha:.2f}\")\n\n        Notes\n        -----\n        - Assumes power-law spectrum: S \u221d \u03bd^\u03b1\n        - Returns NaN for non-positive flux values (cannot take log)\n        - Typical radio sources have \u03b1 \u2248 -0.7 (synchrotron emission)\n        \"\"\"\n        # Validate variable\n        if var not in self._obj.data_vars:\n            raise ValueError(\n                f\"Variable '{var}' not found in dataset. \"\n                f\"Available variables: {list(self._obj.data_vars)}.\"\n            )\n\n        # Get pixel indices\n        l_idx, m_idx = self.nearest_lm_idx(l, m)\n\n        # Resolve frequency indices\n        if freq1_mhz is not None:\n            fi1 = self.nearest_freq_idx(freq1_mhz)\n        elif freq1_idx is not None:\n            fi1 = freq1_idx\n        else:\n            fi1 = 0\n\n        if freq2_mhz is not None:\n            fi2 = self.nearest_freq_idx(freq2_mhz)\n        elif freq2_idx is not None:\n            fi2 = freq2_idx\n        else:\n            fi2 = len(self._obj.coords[\"frequency\"]) - 1\n\n        # Get flux values at both frequencies\n        s1 = float(\n            self._obj[var]\n            .isel(time=time_idx, frequency=fi1, polarization=pol, l=l_idx, m=m_idx)\n            .values\n        )\n        s2 = float(\n            self._obj[var]\n            .isel(time=time_idx, frequency=fi2, polarization=pol, l=l_idx, m=m_idx)\n            .values\n        )\n\n        # Get frequency values in Hz\n        nu1 = float(self._obj.coords[\"frequency\"].values[fi1])\n        nu2 = float(self._obj.coords[\"frequency\"].values[fi2])\n\n        # Compute spectral index: \u03b1 = log(S2/S1) / log(\u03bd2/\u03bd1)\n        # Handle non-positive flux values\n        if s1 &lt;= 0 or s2 &lt;= 0 or nu1 &lt;= 0 or nu2 &lt;= 0 or nu1 == nu2:\n            return float(\"nan\")\n\n        alpha = np.log(s2 / s1) / np.log(nu2 / nu1)\n        return float(alpha)\n\n    def spectral_index_map(\n        self,\n        time_idx: int = 0,\n        pol: int = 0,\n        freq1_mhz: float | None = None,\n        freq2_mhz: float | None = None,\n        freq1_idx: int | None = None,\n        freq2_idx: int | None = None,\n        var: str = \"SKY\",\n    ) -&gt; xr.DataArray:\n        \"\"\"Compute spectral index map across the image.\n\n        Computes the spectral index \u03b1 at each pixel, where S \u221d \u03bd^\u03b1.\n\n        Parameters\n        ----------\n        time_idx : int, default 0\n            Time index for the measurement.\n        pol : int, default 0\n            Polarization index.\n        freq1_mhz : float, optional\n            First frequency in MHz. If not provided, uses freq1_idx or first channel.\n        freq2_mhz : float, optional\n            Second frequency in MHz. If not provided, uses freq2_idx or last channel.\n        freq1_idx : int, optional\n            First frequency index. Overridden by freq1_mhz if provided.\n        freq2_idx : int, optional\n            Second frequency index. Overridden by freq2_mhz if provided.\n        var : str, default \"SKY\"\n            Data variable to analyze.\n\n        Returns\n        -------\n        xr.DataArray\n            2D array of spectral index values with dimensions (l, m).\n            NaN values indicate pixels where the calculation was not possible.\n\n        Raises\n        ------\n        ValueError\n            If the specified variable doesn't exist in the dataset.\n\n        Example\n        -------\n        &gt;&gt;&gt; # Compute spectral index map between first and last frequency\n        &gt;&gt;&gt; alpha_map = ds.radport.spectral_index_map()\n        &gt;&gt;&gt; alpha_map.plot(vmin=-3, vmax=1, cmap=\"RdBu_r\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Compute between specific frequencies\n        &gt;&gt;&gt; alpha_map = ds.radport.spectral_index_map(\n        ...     freq1_mhz=46.0,\n        ...     freq2_mhz=54.0,\n        ... )\n        \"\"\"\n        # Validate variable\n        if var not in self._obj.data_vars:\n            raise ValueError(\n                f\"Variable '{var}' not found in dataset. \"\n                f\"Available variables: {list(self._obj.data_vars)}.\"\n            )\n\n        # Resolve frequency indices\n        if freq1_mhz is not None:\n            fi1 = self.nearest_freq_idx(freq1_mhz)\n        elif freq1_idx is not None:\n            fi1 = freq1_idx\n        else:\n            fi1 = 0\n\n        if freq2_mhz is not None:\n            fi2 = self.nearest_freq_idx(freq2_mhz)\n        elif freq2_idx is not None:\n            fi2 = freq2_idx\n        else:\n            fi2 = len(self._obj.coords[\"frequency\"]) - 1\n\n        # Get flux arrays at both frequencies\n        s1 = self._obj[var].isel(\n            time=time_idx, frequency=fi1, polarization=pol\n        ).values.astype(float)\n        s2 = self._obj[var].isel(\n            time=time_idx, frequency=fi2, polarization=pol\n        ).values.astype(float)\n\n        # Get frequency values in Hz\n        nu1 = float(self._obj.coords[\"frequency\"].values[fi1])\n        nu2 = float(self._obj.coords[\"frequency\"].values[fi2])\n\n        # Compute spectral index: \u03b1 = log(S2/S1) / log(\u03bd2/\u03bd1)\n        with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n            # Mask non-positive values\n            valid_mask = (s1 &gt; 0) &amp; (s2 &gt; 0)\n            alpha = np.full_like(s1, np.nan)\n            alpha[valid_mask] = (\n                np.log(s2[valid_mask] / s1[valid_mask]) / np.log(nu2 / nu1)\n            )\n\n        # Create DataArray with coordinates\n        return xr.DataArray(\n            alpha,\n            dims=[\"l\", \"m\"],\n            coords={\n                \"l\": self._obj.coords[\"l\"],\n                \"m\": self._obj.coords[\"m\"],\n            },\n            name=\"spectral_index\",\n            attrs={\n                \"long_name\": \"Spectral index\",\n                \"units\": \"\",\n                \"freq1_hz\": nu1,\n                \"freq2_hz\": nu2,\n                \"freq1_mhz\": nu1 / 1e6,\n                \"freq2_mhz\": nu2 / 1e6,\n            },\n        )\n\n    def integrated_flux(\n        self,\n        l: float,\n        m: float,\n        time_idx: int = 0,\n        pol: int = 0,\n        freq_min_mhz: float | None = None,\n        freq_max_mhz: float | None = None,\n        freq_indices: list[int] | None = None,\n        var: str = \"SKY\",\n    ) -&gt; float:\n        \"\"\"Compute integrated flux density over a frequency band.\n\n        Integrates the flux density across the specified frequency range\n        using the trapezoidal rule.\n\n        Parameters\n        ----------\n        l : float\n            The l coordinate value for the pixel location.\n        m : float\n            The m coordinate value for the pixel location.\n        time_idx : int, default 0\n            Time index for the measurement.\n        pol : int, default 0\n            Polarization index.\n        freq_min_mhz : float, optional\n            Minimum frequency in MHz. If not provided, uses full range.\n        freq_max_mhz : float, optional\n            Maximum frequency in MHz. If not provided, uses full range.\n        freq_indices : list of int, optional\n            Specific frequency indices to include. Overrides freq_min/max_mhz.\n        var : str, default \"SKY\"\n            Data variable to analyze.\n\n        Returns\n        -------\n        float\n            Integrated flux density in Jy\u00b7Hz. Divide by bandwidth to get\n            average flux density.\n\n        Raises\n        ------\n        ValueError\n            If the specified variable doesn't exist in the dataset.\n\n        Example\n        -------\n        &gt;&gt;&gt; # Compute integrated flux at image center across all frequencies\n        &gt;&gt;&gt; flux = ds.radport.integrated_flux(l=0.0, m=0.0)\n        &gt;&gt;&gt; print(f\"Integrated flux: {flux:.2e} Jy\u00b7Hz\")\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Compute over specific band\n        &gt;&gt;&gt; flux = ds.radport.integrated_flux(\n        ...     l=0.0, m=0.0,\n        ...     freq_min_mhz=45.0,\n        ...     freq_max_mhz=55.0,\n        ... )\n\n        Notes\n        -----\n        Uses trapezoidal integration over the frequency axis.\n        \"\"\"\n        # Validate variable\n        if var not in self._obj.data_vars:\n            raise ValueError(\n                f\"Variable '{var}' not found in dataset. \"\n                f\"Available variables: {list(self._obj.data_vars)}.\"\n            )\n\n        # Get pixel indices\n        l_idx, m_idx = self.nearest_lm_idx(l, m)\n\n        # Get all frequency values\n        freq_hz = self._obj.coords[\"frequency\"].values\n\n        # Determine which frequencies to include\n        if freq_indices is not None:\n            indices = freq_indices\n        else:\n            if freq_min_mhz is not None:\n                min_idx = self.nearest_freq_idx(freq_min_mhz)\n            else:\n                min_idx = 0\n\n            if freq_max_mhz is not None:\n                max_idx = self.nearest_freq_idx(freq_max_mhz)\n            else:\n                max_idx = len(freq_hz) - 1\n\n            # Ensure proper ordering\n            if min_idx &gt; max_idx:\n                min_idx, max_idx = max_idx, min_idx\n\n            indices = list(range(min_idx, max_idx + 1))\n\n        if len(indices) &lt; 2:\n            # Need at least 2 points for integration\n            if len(indices) == 1:\n                # Return single point value (no integration possible)\n                return float(\n                    self._obj[var]\n                    .isel(\n                        time=time_idx,\n                        frequency=indices[0],\n                        polarization=pol,\n                        l=l_idx,\n                        m=m_idx,\n                    )\n                    .values\n                )\n            return 0.0\n\n        # Get flux values at selected frequencies\n        flux_values = []\n        freq_values = []\n        for fi in indices:\n            flux = float(\n                self._obj[var]\n                .isel(time=time_idx, frequency=fi, polarization=pol, l=l_idx, m=m_idx)\n                .values\n            )\n            flux_values.append(flux)\n            freq_values.append(float(freq_hz[fi]))\n\n        flux_values = np.array(flux_values)\n        freq_values = np.array(freq_values)\n\n        # Integrate using trapezoidal rule\n        integrated = np.trapezoid(flux_values, freq_values)\n\n        return float(integrated)\n\n    def plot_spectral_index_map(\n        self,\n        time_idx: int = 0,\n        pol: int = 0,\n        freq1_mhz: float | None = None,\n        freq2_mhz: float | None = None,\n        freq1_idx: int | None = None,\n        freq2_idx: int | None = None,\n        var: str = \"SKY\",\n        cmap: str = \"RdBu_r\",\n        vmin: float | None = -3.0,\n        vmax: float | None = 1.0,\n        mask_radius: int | None = None,\n        figsize: tuple[float, float] = (8, 6),\n        add_colorbar: bool = True,\n    ) -&gt; \"Figure\":\n        \"\"\"Plot the spectral index map.\n\n        Parameters\n        ----------\n        time_idx : int, default 0\n            Time index for the measurement.\n        pol : int, default 0\n            Polarization index.\n        freq1_mhz : float, optional\n            First frequency in MHz.\n        freq2_mhz : float, optional\n            Second frequency in MHz.\n        freq1_idx : int, optional\n            First frequency index.\n        freq2_idx : int, optional\n            Second frequency index.\n        var : str, default \"SKY\"\n            Data variable to analyze.\n        cmap : str, default \"RdBu_r\"\n            Colormap (diverging recommended for spectral index).\n        vmin : float, default -3.0\n            Minimum value for color scaling.\n        vmax : float, default 1.0\n            Maximum value for color scaling.\n        mask_radius : int, optional\n            Apply circular mask with this radius in pixels.\n        figsize : tuple, default (8, 6)\n            Figure size in inches.\n        add_colorbar : bool, default True\n            Whether to add a colorbar.\n\n        Returns\n        -------\n        matplotlib.figure.Figure\n            The generated figure.\n\n        Example\n        -------\n        &gt;&gt;&gt; fig = ds.radport.plot_spectral_index_map(\n        ...     freq1_mhz=46.0,\n        ...     freq2_mhz=54.0,\n        ...     mask_radius=1800,\n        ... )\n        \"\"\"\n        # Get spectral index map\n        alpha_map = self.spectral_index_map(\n            time_idx=time_idx,\n            pol=pol,\n            freq1_mhz=freq1_mhz,\n            freq2_mhz=freq2_mhz,\n            freq1_idx=freq1_idx,\n            freq2_idx=freq2_idx,\n            var=var,\n        )\n\n        alpha_values = alpha_map.values.copy()\n\n        # Apply mask if requested\n        if mask_radius is not None:\n            nl = len(self._obj.coords[\"l\"])\n            nm = len(self._obj.coords[\"m\"])\n            center_l, center_m = nl // 2, nm // 2\n            l_idx, m_idx = np.ogrid[:nl, :nm]\n            dist = np.sqrt((l_idx - center_l) ** 2 + (m_idx - center_m) ** 2)\n            mask = dist &gt; mask_radius\n            alpha_values[mask] = np.nan\n\n        # Create figure\n        fig, ax = plt.subplots(figsize=figsize)\n\n        im = ax.imshow(\n            alpha_values.T,\n            origin=\"lower\",\n            cmap=cmap,\n            vmin=vmin,\n            vmax=vmax,\n            aspect=\"equal\",\n        )\n\n        # Add colorbar\n        if add_colorbar:\n            cbar = fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04)\n            cbar.set_label(\"Spectral Index (\u03b1)\", fontsize=11)\n\n        # Labels\n        ax.set_xlabel(\"l index\", fontsize=11)\n        ax.set_ylabel(\"m index\", fontsize=11)\n\n        # Title\n        freq1_hz = alpha_map.attrs.get(\"freq1_hz\", 0)\n        freq2_hz = alpha_map.attrs.get(\"freq2_hz\", 0)\n        time_val = self._obj.coords[\"time\"].values[time_idx]\n        try:\n            time_str = f\"{float(time_val):.6f}\"\n        except (TypeError, ValueError):\n            time_str = str(time_val)\n\n        ax.set_title(\n            f\"Spectral Index Map at t={time_str} MJD\\n\"\n            f\"({freq1_hz/1e6:.1f} - {freq2_hz/1e6:.1f} MHz)\",\n            fontsize=11,\n        )\n\n        return fig\n\n    # =========================================================================\n    # Dispersion Measure Correction Methods\n    # =========================================================================\n\n    # Dispersion constant in MHz^2 pc^-1 cm^3 s\n    # Reference: Lorimer &amp; Kramer (2004), Handbook of Pulsar Astronomy\n    K_DM = 4.148808e3  # MHz^2 pc^-1 cm^3 s\n\n    def dispersion_delay(\n        self,\n        dm: float,\n        freq_mhz: float | np.ndarray | None = None,\n        freq_ref_mhz: float | None = None,\n    ) -&gt; float | np.ndarray:\n        \"\"\"Calculate dispersion delay for a given DM and frequency.\n\n        Radio signals experience frequency-dependent delays when propagating\n        through the ionized interstellar medium. Lower frequencies arrive\n        later than higher frequencies. This method computes the time delay\n        using the cold plasma dispersion relation.\n\n        Parameters\n        ----------\n        dm : float\n            Dispersion measure in pc cm^-3. Must be non-negative.\n        freq_mhz : float or np.ndarray, optional\n            Frequency or array of frequencies in MHz at which to compute\n            delays. If None, uses all frequencies in the dataset.\n        freq_ref_mhz : float, optional\n            Reference frequency in MHz (typically the highest frequency).\n            Delays are computed relative to this frequency.\n            If None, uses the highest frequency in the dataset.\n\n        Returns\n        -------\n        float or np.ndarray\n            Time delay(s) in seconds. Positive values indicate the signal\n            arrives later at lower frequencies. Returns the same shape as\n            freq_mhz input.\n\n        Raises\n        ------\n        ValueError\n            If dm is negative.\n\n        Notes\n        -----\n        The dispersion delay is computed using:\n\n            \u0394t = K_DM \u00d7 DM \u00d7 (f_lo^-2 - f_hi^-2)\n\n        where:\n        - K_DM = 4.148808 \u00d7 10^3 MHz^2 pc^-1 cm^3 s (dispersion constant)\n        - DM is the dispersion measure in pc cm^-3\n        - f_lo, f_hi are frequencies in MHz\n\n        Example\n        -------\n        &gt;&gt;&gt; # Crab pulsar DM = 56.8 pc cm^-3\n        &gt;&gt;&gt; dm = 56.8\n        &gt;&gt;&gt; delay = ds.radport.dispersion_delay(dm=dm, freq_mhz=46.0)\n        &gt;&gt;&gt; print(f\"Delay at 46 MHz: {delay:.3f} seconds\")\n\n        &gt;&gt;&gt; # Get delays at all dataset frequencies\n        &gt;&gt;&gt; delays = ds.radport.dispersion_delay(dm=56.8)\n\n        References\n        ----------\n        .. [1] Lorimer &amp; Kramer (2004), \"Handbook of Pulsar Astronomy\"\n        \"\"\"\n        # Validate DM\n        if dm &lt; 0:\n            raise ValueError(f\"DM must be non-negative, got {dm}\")\n\n        # Get frequencies\n        if freq_mhz is None:\n            freq_mhz = self._obj.coords[\"frequency\"].values / 1e6\n\n        freq_mhz = np.asarray(freq_mhz)\n\n        # Get reference frequency (highest frequency by default)\n        if freq_ref_mhz is None:\n            freq_ref_mhz = float(self._obj.coords[\"frequency\"].values.max() / 1e6)\n\n        # Validate reference frequency\n        if freq_ref_mhz &lt;= 0:\n            raise ValueError(f\"Reference frequency must be positive, got {freq_ref_mhz}\")\n\n        # Validate input frequencies\n        if np.any(freq_mhz &lt;= 0):\n            raise ValueError(\"All frequencies must be positive\")\n\n        # Compute delay: \u0394t = K_DM \u00d7 DM \u00d7 (f^-2 - f_ref^-2)\n        delay = self.K_DM * dm * (freq_mhz**-2 - freq_ref_mhz**-2)\n\n        return delay\n\n    def dynamic_spectrum_dedispersed(\n        self,\n        l: float,\n        m: float,\n        dm: float,\n        var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n        pol: int = 0,\n        method: Literal[\"shift\", \"interpolate\"] = \"shift\",\n        fill_value: float = np.nan,\n        trim: bool = False,\n    ) -&gt; xr.DataArray:\n        \"\"\"Extract a dedispersed dynamic spectrum for a single pixel.\n\n        Corrects for interstellar dispersion by shifting or interpolating\n        frequency channels according to the dispersion delay. This is essential\n        for analyzing dispersed radio transients like pulsars and FRBs.\n\n        Parameters\n        ----------\n        l : float\n            Target l coordinate for pixel selection.\n        m : float\n            Target m coordinate for pixel selection.\n        dm : float\n            Dispersion measure in pc cm^-3. Must be non-negative.\n        var : {'SKY', 'BEAM'}, default 'SKY'\n            Data variable to extract.\n        pol : int, default 0\n            Polarization index.\n        method : {'shift', 'interpolate'}, default 'shift'\n            Dedispersion method:\n            - 'shift': Fast integer-sample shifting (approximate).\n              Rounds delays to nearest time sample.\n            - 'interpolate': Slower but precise sub-sample interpolation.\n              Uses linear interpolation for accurate delay correction.\n        fill_value : float, default np.nan\n            Value to use for samples shifted outside the time range.\n        trim : bool, default False\n            If True, trim the time axis to only include valid data\n            (removes NaN edges from shifting). If False, returns full\n            time axis with NaN-filled edges.\n\n        Returns\n        -------\n        xr.DataArray\n            2D DataArray with dimensions (time, frequency) containing\n            the dedispersed dynamic spectrum. Time axis represents\n            arrival time at the reference frequency.\n            Includes metadata: pixel_l, pixel_m, dm, method, freq_ref_mhz.\n\n        Raises\n        ------\n        ValueError\n            If dm is negative, variable doesn't exist, or method is invalid.\n\n        Warns\n        -----\n        UserWarning\n            If the maximum dispersion shift exceeds 50% of the time span.\n\n        Notes\n        -----\n        The dedispersion aligns all frequency channels to a common reference\n        time (typically the highest frequency). Lower frequency channels are\n        shifted backwards in time to compensate for the dispersion delay.\n\n        For the 'shift' method, delays are rounded to the nearest integer\n        number of time samples, which introduces quantization error. For\n        precise analysis, use 'interpolate'.\n\n        Example\n        -------\n        &gt;&gt;&gt; # Dedisperse at Crab pulsar DM\n        &gt;&gt;&gt; dynspec = ds.radport.dynamic_spectrum_dedispersed(\n        ...     l=0.0, m=0.0, dm=56.8, method=\"interpolate\"\n        ... )\n\n        &gt;&gt;&gt; # Fast approximate dedispersion\n        &gt;&gt;&gt; dynspec_fast = ds.radport.dynamic_spectrum_dedispersed(\n        ...     l=0.0, m=0.0, dm=56.8, method=\"shift\", trim=True\n        ... )\n\n        See Also\n        --------\n        dispersion_delay : Compute dispersion delays for given frequencies.\n        dynamic_spectrum : Extract uncorrected dynamic spectrum.\n        plot_dynamic_spectrum : Plot dynamic spectrum with optional dedispersion.\n        \"\"\"\n        # Validate inputs\n        if dm &lt; 0:\n            raise ValueError(f\"DM must be non-negative, got {dm}\")\n\n        if method not in (\"shift\", \"interpolate\"):\n            raise ValueError(\n                f\"Method must be 'shift' or 'interpolate', got '{method}'\"\n            )\n\n        if var not in self._obj.data_vars:\n            available = sorted(self._obj.data_vars)\n            raise ValueError(\n                f\"Variable '{var}' not found. Available: {available}\"\n            )\n\n        # Get the uncorrected dynamic spectrum\n        dynspec = self.dynamic_spectrum(l=l, m=m, var=var, pol=pol)\n\n        # If DM is zero, return the original spectrum\n        if dm == 0:\n            dynspec.attrs[\"dm\"] = 0.0\n            dynspec.attrs[\"method\"] = method\n            dynspec.attrs[\"freq_ref_mhz\"] = float(\n                self._obj.coords[\"frequency\"].values.max() / 1e6\n            )\n            return dynspec\n\n        # Get coordinates\n        time_vals = dynspec.coords[\"time\"].values\n        freq_vals = dynspec.coords[\"frequency\"].values  # Hz\n        freq_mhz = freq_vals / 1e6\n\n        # Compute reference frequency (highest)\n        freq_ref_mhz = float(freq_mhz.max())\n\n        # Compute dispersion delays for each frequency channel\n        delays = self.dispersion_delay(dm=dm, freq_mhz=freq_mhz, freq_ref_mhz=freq_ref_mhz)\n\n        # Get time resolution\n        if len(time_vals) &lt; 2:\n            raise ValueError(\"Need at least 2 time samples for dedispersion\")\n\n        dt = float(time_vals[1] - time_vals[0])  # Time resolution in MJD\n        dt_seconds = dt * 86400.0  # Convert to seconds\n\n        # Convert delays to time samples\n        delay_samples = delays / dt_seconds\n\n        # Check for excessive delays\n        max_delay_samples = np.abs(delay_samples).max()\n        if max_delay_samples &gt; 0.5 * len(time_vals):\n            warnings.warn(\n                f\"Maximum dispersion shift ({max_delay_samples:.1f} samples) \"\n                f\"exceeds 50% of time span ({len(time_vals)} samples). \"\n                \"Consider using a smaller DM or longer observation.\",\n                UserWarning,\n                stacklevel=2,\n            )\n\n        # Get data values\n        data = dynspec.values.copy()  # Shape: (time, frequency)\n        n_time, n_freq = data.shape\n\n        # Create output array\n        dedispersed = np.full_like(data, fill_value)\n\n        if method == \"shift\":\n            # Integer sample shifting (fast, approximate)\n            for i_freq in range(n_freq):\n                shift = int(np.round(delay_samples[i_freq]))\n\n                if shift == 0:\n                    dedispersed[:, i_freq] = data[:, i_freq]\n                elif shift &gt; 0:\n                    # Signal arrives later at lower freq, shift backwards\n                    if shift &lt; n_time:\n                        dedispersed[:-shift, i_freq] = data[shift:, i_freq]\n                else:\n                    # Negative shift (shouldn't happen for positive DM)\n                    shift = abs(shift)\n                    if shift &lt; n_time:\n                        dedispersed[shift:, i_freq] = data[:-shift, i_freq]\n\n        else:  # method == \"interpolate\"\n            # Sub-sample interpolation (slower, precise)\n            for i_freq in range(n_freq):\n                delay_mjd = delays[i_freq] / 86400.0  # Convert to MJD\n\n                # Create interpolator for this frequency channel\n                interp_func = interpolate.interp1d(\n                    time_vals,\n                    data[:, i_freq],\n                    kind=\"linear\",\n                    bounds_error=False,\n                    fill_value=fill_value,\n                )\n\n                # Interpolate at shifted times\n                # To correct for dispersion, we sample at time + delay\n                shifted_times = time_vals + delay_mjd\n                dedispersed[:, i_freq] = interp_func(shifted_times)\n\n        # Trim if requested\n        if trim:\n            # Find valid time range (where all frequencies have data)\n            valid_mask = ~np.all(np.isnan(dedispersed), axis=1)\n            if np.any(valid_mask):\n                first_valid = np.argmax(valid_mask)\n                last_valid = len(valid_mask) - np.argmax(valid_mask[::-1]) - 1\n                dedispersed = dedispersed[first_valid:last_valid + 1, :]\n                time_vals = time_vals[first_valid:last_valid + 1]\n\n        # Create output DataArray\n        result = xr.DataArray(\n            dedispersed,\n            dims=[\"time\", \"frequency\"],\n            coords={\n                \"time\": time_vals,\n                \"frequency\": freq_vals,\n            },\n            name=f\"{var}_dedispersed\",\n            attrs={\n                \"pixel_l\": dynspec.attrs[\"pixel_l\"],\n                \"pixel_m\": dynspec.attrs[\"pixel_m\"],\n                \"l_idx\": dynspec.attrs[\"l_idx\"],\n                \"m_idx\": dynspec.attrs[\"m_idx\"],\n                \"pol\": pol,\n                \"dm\": dm,\n                \"method\": method,\n                \"freq_ref_mhz\": freq_ref_mhz,\n                \"long_name\": f\"Dedispersed {var} (DM={dm:.2f} pc/cm\u00b3)\",\n                \"units\": \"Jy/beam\",\n            },\n        )\n\n        return result\n\n    def plot_dynamic_spectrum_dedispersed(\n        self,\n        l: float,\n        m: float,\n        dm: float,\n        var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n        pol: int = 0,\n        method: Literal[\"shift\", \"interpolate\"] = \"shift\",\n        trim: bool = False,\n        cmap: str = \"inferno\",\n        vmin: float | None = None,\n        vmax: float | None = None,\n        robust: bool = True,\n        figsize: tuple[float, float] = (10, 5),\n        add_colorbar: bool = True,\n        show_delay_curve: bool = False,\n        **kwargs: Any,\n    ) -&gt; \"Figure\":\n        \"\"\"Plot a dedispersed dynamic spectrum for a single pixel.\n\n        Creates a 2D visualization showing intensity variations across\n        time and frequency after correcting for interstellar dispersion.\n\n        Parameters\n        ----------\n        l : float\n            Target l coordinate for pixel selection.\n        m : float\n            Target m coordinate for pixel selection.\n        dm : float\n            Dispersion measure in pc cm^-3.\n        var : {'SKY', 'BEAM'}, default 'SKY'\n            Data variable to plot.\n        pol : int, default 0\n            Polarization index.\n        method : {'shift', 'interpolate'}, default 'shift'\n            Dedispersion method ('shift' for fast, 'interpolate' for precise).\n        trim : bool, default False\n            If True, trim time axis to valid data only.\n        cmap : str, default 'inferno'\n            Matplotlib colormap.\n        vmin, vmax : float, optional\n            Color scale limits.\n        robust : bool, default True\n            Use percentile-based color scaling.\n        figsize : tuple, default (10, 5)\n            Figure size in inches.\n        add_colorbar : bool, default True\n            Whether to add a colorbar.\n        show_delay_curve : bool, default False\n            If True, overlay the dispersion delay curve on the plot.\n        **kwargs : dict\n            Additional arguments passed to imshow.\n\n        Returns\n        -------\n        matplotlib.figure.Figure\n            The figure containing the dedispersed dynamic spectrum plot.\n\n        Example\n        -------\n        &gt;&gt;&gt; fig = ds.radport.plot_dynamic_spectrum_dedispersed(\n        ...     l=0.0, m=0.0, dm=56.8, method=\"interpolate\"\n        ... )\n        \"\"\"\n        # Get dedispersed dynamic spectrum\n        dynspec = self.dynamic_spectrum_dedispersed(\n            l=l, m=m, dm=dm, var=var, pol=pol, method=method, trim=trim\n        )\n\n        # Create figure\n        fig, ax = plt.subplots(figsize=figsize)\n\n        # Compute data\n        data = dynspec.values\n\n        # Handle robust scaling\n        if robust and vmin is None and vmax is None:\n            finite_data = data[np.isfinite(data)]\n            if finite_data.size &gt; 0:\n                vmin = float(np.percentile(finite_data, 2))\n                vmax = float(np.percentile(finite_data, 98))\n\n        # Get coordinate values\n        time_vals = dynspec.coords[\"time\"].values\n        freq_vals = dynspec.coords[\"frequency\"].values / 1e6  # Convert to MHz\n\n        # Compute extent for imshow\n        extent = [\n            float(time_vals.min()), float(time_vals.max()),\n            float(freq_vals.min()), float(freq_vals.max()),\n        ]\n\n        # Plot - transpose so time is x-axis and frequency is y-axis\n        im = ax.imshow(\n            data.T,\n            origin=\"lower\",\n            cmap=cmap,\n            vmin=vmin,\n            vmax=vmax,\n            extent=extent,\n            aspect=\"auto\",\n            **kwargs,\n        )\n\n        # Optionally show dispersion delay curve\n        if show_delay_curve and dm &gt; 0:\n            delays = self.dispersion_delay(dm=dm, freq_mhz=freq_vals)\n            # Convert delays to MJD offset from reference\n            delay_mjd = delays / 86400.0\n            # Plot as time offset from center of time range\n            t_center = (time_vals.min() + time_vals.max()) / 2\n            ax.plot(\n                t_center - delay_mjd,\n                freq_vals,\n                \"w--\",\n                linewidth=1.5,\n                alpha=0.7,\n                label=\"Dispersion curve\",\n            )\n            ax.legend(loc=\"upper right\")\n\n        if add_colorbar:\n            cbar = fig.colorbar(im, ax=ax)\n            cbar.set_label(\"Jy/beam\")\n\n        # Labels and title\n        pixel_l = dynspec.attrs[\"pixel_l\"]\n        pixel_m = dynspec.attrs[\"pixel_m\"]\n        ax.set_xlabel(\"Time (MJD)\")\n        ax.set_ylabel(\"Frequency (MHz)\")\n        ax.set_title(\n            f\"{var} Dedispersed Dynamic Spectrum\\n\"\n            f\"l={pixel_l:+.4f}, m={pixel_m:+.4f}, pol={pol}, \"\n            f\"DM={dm:.2f} pc/cm\u00b3 ({method})\"\n        )\n\n        fig.tight_layout()\n        return fig\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.has_beam","title":"<code>has_beam</code>  <code>property</code>","text":"<p>Check if the dataset contains BEAM data.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the dataset contains a BEAM variable.</p>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.has_wcs","title":"<code>has_wcs</code>  <code>property</code>","text":"<p>Check if WCS coordinate information is available.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if WCS header is available in the dataset.</p> Example <p>if ds.radport.has_wcs: ...     fig = ds.radport.plot_wcs()</p>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.__init__","title":"<code>__init__(xarray_obj)</code>","text":"<p>Initialize the RadportAccessor.</p> <p>Parameters:</p> Name Type Description Default <code>xarray_obj</code> <code>Dataset</code> <p>The xarray Dataset to extend.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dataset structure is invalid for OVRO-LWA data.</p> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def __init__(self, xarray_obj: xr.Dataset) -&gt; None:\n    \"\"\"Initialize the RadportAccessor.\n\n    Parameters\n    ----------\n    xarray_obj : xr.Dataset\n        The xarray Dataset to extend.\n\n    Raises\n    ------\n    ValueError\n        If the dataset structure is invalid for OVRO-LWA data.\n    \"\"\"\n    self._obj = xarray_obj\n    self._validate_structure()\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.nearest_freq_idx","title":"<code>nearest_freq_idx(freq_mhz)</code>","text":"<p>Find the index of the frequency nearest to the given value in MHz.</p> <p>Parameters:</p> Name Type Description Default <code>freq_mhz</code> <code>float</code> <p>Target frequency in MHz.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Index of the nearest frequency in the dataset.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; idx = ds.radport.nearest_freq_idx(50.0)  # Find index nearest to 50 MHz\n&gt;&gt;&gt; ds.radport.plot(freq_idx=idx)\n</code></pre> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def nearest_freq_idx(self, freq_mhz: float) -&gt; int:\n    \"\"\"Find the index of the frequency nearest to the given value in MHz.\n\n    Parameters\n    ----------\n    freq_mhz : float\n        Target frequency in MHz.\n\n    Returns\n    -------\n    int\n        Index of the nearest frequency in the dataset.\n\n    Examples\n    --------\n    &gt;&gt;&gt; idx = ds.radport.nearest_freq_idx(50.0)  # Find index nearest to 50 MHz\n    &gt;&gt;&gt; ds.radport.plot(freq_idx=idx)\n    \"\"\"\n    freq_hz = freq_mhz * 1e6\n    freq_values = self._obj.coords[\"frequency\"].values\n    return int(np.argmin(np.abs(freq_values - freq_hz)))\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.nearest_time_idx","title":"<code>nearest_time_idx(mjd)</code>","text":"<p>Find the index of the time nearest to the given MJD value.</p> <p>Parameters:</p> Name Type Description Default <code>mjd</code> <code>float</code> <p>Target time in Modified Julian Date (MJD).</p> required <p>Returns:</p> Type Description <code>int</code> <p>Index of the nearest time in the dataset.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; idx = ds.radport.nearest_time_idx(60000.5)  # Find index nearest to MJD\n&gt;&gt;&gt; ds.radport.plot(time_idx=idx)\n</code></pre> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def nearest_time_idx(self, mjd: float) -&gt; int:\n    \"\"\"Find the index of the time nearest to the given MJD value.\n\n    Parameters\n    ----------\n    mjd : float\n        Target time in Modified Julian Date (MJD).\n\n    Returns\n    -------\n    int\n        Index of the nearest time in the dataset.\n\n    Examples\n    --------\n    &gt;&gt;&gt; idx = ds.radport.nearest_time_idx(60000.5)  # Find index nearest to MJD\n    &gt;&gt;&gt; ds.radport.plot(time_idx=idx)\n    \"\"\"\n    time_values = self._obj.coords[\"time\"].values\n    return int(np.argmin(np.abs(time_values - mjd)))\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.nearest_lm_idx","title":"<code>nearest_lm_idx(l, m)</code>","text":"<p>Find the indices of the (l, m) pixel nearest to the given coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>float</code> <p>Target l direction cosine coordinate.</p> required <code>m</code> <code>float</code> <p>Target m direction cosine coordinate.</p> required <p>Returns:</p> Type Description <code>tuple of int</code> <p>(l_idx, m_idx) indices of the nearest pixel.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; l_idx, m_idx = ds.radport.nearest_lm_idx(0.0, 0.0)  # Find center pixel\n</code></pre> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def nearest_lm_idx(self, l: float, m: float) -&gt; tuple[int, int]:\n    \"\"\"Find the indices of the (l, m) pixel nearest to the given coordinates.\n\n    Parameters\n    ----------\n    l : float\n        Target l direction cosine coordinate.\n    m : float\n        Target m direction cosine coordinate.\n\n    Returns\n    -------\n    tuple of int\n        (l_idx, m_idx) indices of the nearest pixel.\n\n    Examples\n    --------\n    &gt;&gt;&gt; l_idx, m_idx = ds.radport.nearest_lm_idx(0.0, 0.0)  # Find center pixel\n    \"\"\"\n    l_values = self._obj.coords[\"l\"].values\n    m_values = self._obj.coords[\"m\"].values\n    l_idx = int(np.argmin(np.abs(l_values - l)))\n    m_idx = int(np.argmin(np.abs(m_values - m)))\n    return l_idx, m_idx\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.plot","title":"<code>plot(var='SKY', time_idx=None, freq_idx=None, pol=0, freq_mhz=None, time_mjd=None, cmap='inferno', vmin=None, vmax=None, robust=False, mask_radius=None, figsize=(8, 6), add_colorbar=True, **kwargs)</code>","text":"<p>Create a visualization of radio data as a 2D image.</p> <p>Plots a single snapshot of the data at the specified time, frequency, and polarization indices. The resulting image shows intensity values in the (l, m) direction cosine coordinate system.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>('SKY', 'BEAM')</code> <p>Data variable to plot. Use 'BEAM' only if the dataset contains beam data (check with <code>ds.radport.has_beam</code>).</p> <code>'SKY'</code> <code>time_idx</code> <code>int</code> <p>Index along the time dimension for the snapshot. Default is 0. Ignored if <code>time_mjd</code> is provided.</p> <code>None</code> <code>freq_idx</code> <code>int</code> <p>Index along the frequency dimension for the snapshot. Default is 0. Ignored if <code>freq_mhz</code> is provided.</p> <code>None</code> <code>pol</code> <code>int</code> <p>Index along the polarization dimension.</p> <code>0</code> <code>freq_mhz</code> <code>float</code> <p>Select frequency by value in MHz. If provided, overrides <code>freq_idx</code>. Uses the nearest available frequency.</p> <code>None</code> <code>time_mjd</code> <code>float</code> <p>Select time by MJD value. If provided, overrides <code>time_idx</code>. Uses the nearest available time.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>Matplotlib colormap name for the image.</p> <code>'inferno'</code> <code>vmin</code> <code>float</code> <p>Minimum value for the color scale. If None and robust=False, uses the data minimum.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>Maximum value for the color scale. If None and robust=False, uses the data maximum.</p> <code>None</code> <code>robust</code> <code>bool</code> <p>If True, compute vmin/vmax using the 2nd and 98th percentiles of the data, which is useful for data with outliers.</p> <code>False</code> <code>mask_radius</code> <code>int</code> <p>If provided, mask pixels outside this radius (in pixels) from the image center. Useful for all-sky images where edge pixels are invalid. Masked pixels are shown as NaN (transparent).</p> <code>None</code> <code>figsize</code> <code>tuple of float</code> <p>Figure size in inches as (width, height).</p> <code>(8, 6)</code> <code>add_colorbar</code> <code>bool</code> <p>Whether to add a colorbar to the plot.</p> <code>True</code> <code>**kwargs</code> <code>dict</code> <p>Additional keyword arguments passed to <code>matplotlib.pyplot.imshow</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>The matplotlib Figure object containing the plot.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the requested variable does not exist in the dataset.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import ovro_lwa_portal\n&gt;&gt;&gt; ds = ovro_lwa_portal.open_dataset(\"path/to/data.zarr\")\n</code></pre> <p>Plot with default settings (first time, frequency, polarization):</p> <pre><code>&gt;&gt;&gt; fig = ds.radport.plot()\n</code></pre> <p>Plot a specific time and frequency with custom colormap:</p> <pre><code>&gt;&gt;&gt; fig = ds.radport.plot(time_idx=5, freq_idx=10, cmap='viridis')\n</code></pre> <p>Plot by selecting frequency in MHz (more intuitive):</p> <pre><code>&gt;&gt;&gt; fig = ds.radport.plot(freq_mhz=50.0)\n</code></pre> <p>Plot with fixed color scale:</p> <pre><code>&gt;&gt;&gt; fig = ds.radport.plot(vmin=-1.0, vmax=16.0)\n</code></pre> <p>Plot with robust color scaling for data with outliers:</p> <pre><code>&gt;&gt;&gt; fig = ds.radport.plot(robust=True)\n</code></pre> <p>Plot with circular mask to hide invalid edge pixels:</p> <pre><code>&gt;&gt;&gt; fig = ds.radport.plot(mask_radius=1800)\n</code></pre> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def plot(\n    self,\n    var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n    time_idx: int | None = None,\n    freq_idx: int | None = None,\n    pol: int = 0,\n    freq_mhz: float | None = None,\n    time_mjd: float | None = None,\n    cmap: str = \"inferno\",\n    vmin: float | None = None,\n    vmax: float | None = None,\n    robust: bool = False,\n    mask_radius: int | None = None,\n    figsize: tuple[float, float] = (8, 6),\n    add_colorbar: bool = True,\n    **kwargs: Any,\n) -&gt; Figure:\n    \"\"\"Create a visualization of radio data as a 2D image.\n\n    Plots a single snapshot of the data at the specified time, frequency,\n    and polarization indices. The resulting image shows intensity values\n    in the (l, m) direction cosine coordinate system.\n\n    Parameters\n    ----------\n    var : {'SKY', 'BEAM'}, default 'SKY'\n        Data variable to plot. Use 'BEAM' only if the dataset contains\n        beam data (check with `ds.radport.has_beam`).\n    time_idx : int, optional\n        Index along the time dimension for the snapshot. Default is 0.\n        Ignored if `time_mjd` is provided.\n    freq_idx : int, optional\n        Index along the frequency dimension for the snapshot. Default is 0.\n        Ignored if `freq_mhz` is provided.\n    pol : int, default 0\n        Index along the polarization dimension.\n    freq_mhz : float, optional\n        Select frequency by value in MHz. If provided, overrides `freq_idx`.\n        Uses the nearest available frequency.\n    time_mjd : float, optional\n        Select time by MJD value. If provided, overrides `time_idx`.\n        Uses the nearest available time.\n    cmap : str, default 'inferno'\n        Matplotlib colormap name for the image.\n    vmin : float, optional\n        Minimum value for the color scale. If None and robust=False,\n        uses the data minimum.\n    vmax : float, optional\n        Maximum value for the color scale. If None and robust=False,\n        uses the data maximum.\n    robust : bool, default False\n        If True, compute vmin/vmax using the 2nd and 98th percentiles\n        of the data, which is useful for data with outliers.\n    mask_radius : int, optional\n        If provided, mask pixels outside this radius (in pixels) from\n        the image center. Useful for all-sky images where edge pixels\n        are invalid. Masked pixels are shown as NaN (transparent).\n    figsize : tuple of float, default (8, 6)\n        Figure size in inches as (width, height).\n    add_colorbar : bool, default True\n        Whether to add a colorbar to the plot.\n    **kwargs : dict\n        Additional keyword arguments passed to `matplotlib.pyplot.imshow`.\n\n    Returns\n    -------\n    matplotlib.figure.Figure\n        The matplotlib Figure object containing the plot.\n\n    Raises\n    ------\n    ValueError\n        If the requested variable does not exist in the dataset.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import ovro_lwa_portal\n    &gt;&gt;&gt; ds = ovro_lwa_portal.open_dataset(\"path/to/data.zarr\")\n\n    Plot with default settings (first time, frequency, polarization):\n\n    &gt;&gt;&gt; fig = ds.radport.plot()\n\n    Plot a specific time and frequency with custom colormap:\n\n    &gt;&gt;&gt; fig = ds.radport.plot(time_idx=5, freq_idx=10, cmap='viridis')\n\n    Plot by selecting frequency in MHz (more intuitive):\n\n    &gt;&gt;&gt; fig = ds.radport.plot(freq_mhz=50.0)\n\n    Plot with fixed color scale:\n\n    &gt;&gt;&gt; fig = ds.radport.plot(vmin=-1.0, vmax=16.0)\n\n    Plot with robust color scaling for data with outliers:\n\n    &gt;&gt;&gt; fig = ds.radport.plot(robust=True)\n\n    Plot with circular mask to hide invalid edge pixels:\n\n    &gt;&gt;&gt; fig = ds.radport.plot(mask_radius=1800)\n    \"\"\"\n    # Validate the requested variable exists\n    if var not in self._obj.data_vars:\n        available = sorted(self._obj.data_vars)\n        msg = f\"Variable '{var}' not found in dataset. Available variables: {available}\"\n        raise ValueError(msg)\n\n    # Resolve frequency selection: freq_mhz takes precedence over freq_idx\n    if freq_mhz is not None:\n        freq_idx = self.nearest_freq_idx(freq_mhz)\n    elif freq_idx is None:\n        freq_idx = 0\n\n    # Resolve time selection: time_mjd takes precedence over time_idx\n    if time_mjd is not None:\n        time_idx = self.nearest_time_idx(time_mjd)\n    elif time_idx is None:\n        time_idx = 0\n\n    # Extract the 2D slice for plotting\n    da = self._obj[var].isel(\n        time=time_idx,\n        frequency=freq_idx,\n        polarization=pol,\n    )\n\n    # Build title with metadata\n    title = self._build_plot_title(var, time_idx, freq_idx, pol)\n\n    # Create figure and axis\n    fig, ax = plt.subplots(figsize=figsize)\n\n    # Compute data for plotting (triggers dask computation if needed)\n    data = da.values.copy()  # Copy to allow modification for masking\n\n    # Apply circular mask if requested\n    if mask_radius is not None:\n        ny, nx = data.shape\n        cy, cx = ny // 2, nx // 2\n        yy, xx = np.ogrid[:ny, :nx]\n        distance_from_center = np.sqrt((yy - cy) ** 2 + (xx - cx) ** 2)\n        data[distance_from_center &gt; mask_radius] = np.nan\n\n    # Handle robust scaling (after masking, so we only consider valid pixels)\n    if robust and vmin is None and vmax is None:\n        finite_data = data[np.isfinite(data)]\n        if finite_data.size &gt; 0:\n            vmin = float(np.percentile(finite_data, 2))\n            vmax = float(np.percentile(finite_data, 98))\n\n    # Get coordinate extents for proper axis labeling\n    l_vals = da.coords[\"l\"].values\n    m_vals = da.coords[\"m\"].values\n    extent = [float(l_vals.min()), float(l_vals.max()),\n              float(m_vals.min()), float(m_vals.max())]\n\n    # Plot the image\n    im = ax.imshow(\n        data,\n        origin=\"lower\",\n        cmap=cmap,\n        vmin=vmin,\n        vmax=vmax,\n        extent=extent,\n        aspect=\"equal\",\n        **kwargs,\n    )\n\n    # Add colorbar\n    if add_colorbar:\n        cbar = fig.colorbar(im, ax=ax)\n        cbar.set_label(\"Jy/beam\")\n\n    # Set labels and title\n    ax.set_xlabel(\"l (direction cosine)\")\n    ax.set_ylabel(\"m (direction cosine)\")\n    ax.set_title(title)\n\n    fig.tight_layout()\n\n    return fig\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.cutout","title":"<code>cutout(l_center, m_center, dl, dm, var='SKY', time_idx=None, freq_idx=None, pol=0, freq_mhz=None, time_mjd=None)</code>","text":"<p>Extract a spatial cutout (rectangular region) from the data.</p> <p>Returns a 2D DataArray containing data within the specified (l, m) bounding box for a given time, frequency, and polarization.</p> <p>Parameters:</p> Name Type Description Default <code>l_center</code> <code>float</code> <p>Center l coordinate of the cutout region.</p> required <code>m_center</code> <code>float</code> <p>Center m coordinate of the cutout region.</p> required <code>dl</code> <code>float</code> <p>Half-width of the cutout in the l direction. The cutout spans [l_center - dl, l_center + dl].</p> required <code>dm</code> <code>float</code> <p>Half-width of the cutout in the m direction. The cutout spans [m_center - dm, m_center + dm].</p> required <code>var</code> <code>('SKY', 'BEAM')</code> <p>Data variable to extract.</p> <code>'SKY'</code> <code>time_idx</code> <code>int</code> <p>Time index. Default is 0. Ignored if <code>time_mjd</code> is provided.</p> <code>None</code> <code>freq_idx</code> <code>int</code> <p>Frequency index. Default is 0. Ignored if <code>freq_mhz</code> is provided.</p> <code>None</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>freq_mhz</code> <code>float</code> <p>Select frequency by value in MHz (overrides <code>freq_idx</code>).</p> <code>None</code> <code>time_mjd</code> <code>float</code> <p>Select time by MJD value (overrides <code>time_idx</code>).</p> <code>None</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>2D DataArray with dimensions (l, m) containing the cutout data. Includes metadata attributes: cutout_l_center, cutout_m_center, cutout_dl, cutout_dm.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the requested variable does not exist or cutout is empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Extract 0.2 x 0.2 region centered at (0, 0)\n&gt;&gt;&gt; cutout = ds.radport.cutout(l_center=0.0, m_center=0.0, dl=0.1, dm=0.1)\n</code></pre> <pre><code>&gt;&gt;&gt; # Extract at specific frequency\n&gt;&gt;&gt; cutout = ds.radport.cutout(0.0, 0.0, 0.1, 0.1, freq_mhz=50.0)\n</code></pre> <pre><code>&gt;&gt;&gt; # Plot the cutout\n&gt;&gt;&gt; cutout.plot()\n</code></pre> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def cutout(\n    self,\n    l_center: float,\n    m_center: float,\n    dl: float,\n    dm: float,\n    var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n    time_idx: int | None = None,\n    freq_idx: int | None = None,\n    pol: int = 0,\n    freq_mhz: float | None = None,\n    time_mjd: float | None = None,\n) -&gt; xr.DataArray:\n    \"\"\"Extract a spatial cutout (rectangular region) from the data.\n\n    Returns a 2D DataArray containing data within the specified (l, m)\n    bounding box for a given time, frequency, and polarization.\n\n    Parameters\n    ----------\n    l_center : float\n        Center l coordinate of the cutout region.\n    m_center : float\n        Center m coordinate of the cutout region.\n    dl : float\n        Half-width of the cutout in the l direction.\n        The cutout spans [l_center - dl, l_center + dl].\n    dm : float\n        Half-width of the cutout in the m direction.\n        The cutout spans [m_center - dm, m_center + dm].\n    var : {'SKY', 'BEAM'}, default 'SKY'\n        Data variable to extract.\n    time_idx : int, optional\n        Time index. Default is 0. Ignored if `time_mjd` is provided.\n    freq_idx : int, optional\n        Frequency index. Default is 0. Ignored if `freq_mhz` is provided.\n    pol : int, default 0\n        Polarization index.\n    freq_mhz : float, optional\n        Select frequency by value in MHz (overrides `freq_idx`).\n    time_mjd : float, optional\n        Select time by MJD value (overrides `time_idx`).\n\n    Returns\n    -------\n    xr.DataArray\n        2D DataArray with dimensions (l, m) containing the cutout data.\n        Includes metadata attributes: cutout_l_center, cutout_m_center,\n        cutout_dl, cutout_dm.\n\n    Raises\n    ------\n    ValueError\n        If the requested variable does not exist or cutout is empty.\n\n    Examples\n    --------\n    &gt;&gt;&gt; # Extract 0.2 x 0.2 region centered at (0, 0)\n    &gt;&gt;&gt; cutout = ds.radport.cutout(l_center=0.0, m_center=0.0, dl=0.1, dm=0.1)\n\n    &gt;&gt;&gt; # Extract at specific frequency\n    &gt;&gt;&gt; cutout = ds.radport.cutout(0.0, 0.0, 0.1, 0.1, freq_mhz=50.0)\n\n    &gt;&gt;&gt; # Plot the cutout\n    &gt;&gt;&gt; cutout.plot()\n    \"\"\"\n    # Validate variable\n    if var not in self._obj.data_vars:\n        available = sorted(self._obj.data_vars)\n        raise ValueError(\n            f\"Variable '{var}' not found. Available: {available}\"\n        )\n\n    # Resolve indices\n    if freq_mhz is not None:\n        freq_idx = self.nearest_freq_idx(freq_mhz)\n    elif freq_idx is None:\n        freq_idx = 0\n\n    if time_mjd is not None:\n        time_idx = self.nearest_time_idx(time_mjd)\n    elif time_idx is None:\n        time_idx = 0\n\n    # Extract 2D slice\n    da = self._obj[var].isel(\n        time=time_idx,\n        frequency=freq_idx,\n        polarization=pol,\n    )\n\n    # Compute l/m bounds\n    l_min, l_max = l_center - dl, l_center + dl\n    m_min, m_max = m_center - dm, m_center + dm\n\n    # Handle coordinate ordering (ascending or descending)\n    l_coords = da.coords[\"l\"]\n    m_coords = da.coords[\"m\"]\n\n    # Determine slice direction based on coordinate ordering\n    if float(l_coords[0]) &lt;= float(l_coords[-1]):\n        l_slice = slice(l_min, l_max)\n    else:\n        l_slice = slice(l_max, l_min)\n\n    if float(m_coords[0]) &lt;= float(m_coords[-1]):\n        m_slice = slice(m_min, m_max)\n    else:\n        m_slice = slice(m_max, m_min)\n\n    # Select the cutout region\n    cutout = da.sel(l=l_slice, m=m_slice)\n\n    # Check if cutout is empty\n    if cutout.size == 0:\n        raise ValueError(\n            f\"Cutout region is empty. Requested l=[{l_min:.3f}, {l_max:.3f}], \"\n            f\"m=[{m_min:.3f}, {m_max:.3f}]. \"\n            f\"Dataset l range: [{float(l_coords.min()):.3f}, {float(l_coords.max()):.3f}], \"\n            f\"m range: [{float(m_coords.min()):.3f}, {float(m_coords.max()):.3f}].\"\n        )\n\n    # Add metadata attributes\n    cutout.attrs[\"cutout_l_center\"] = l_center\n    cutout.attrs[\"cutout_m_center\"] = m_center\n    cutout.attrs[\"cutout_dl\"] = dl\n    cutout.attrs[\"cutout_dm\"] = dm\n    cutout.attrs[\"time_idx\"] = time_idx\n    cutout.attrs[\"freq_idx\"] = freq_idx\n    cutout.attrs[\"pol\"] = pol\n\n    return cutout\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.plot_cutout","title":"<code>plot_cutout(l_center, m_center, dl, dm, var='SKY', time_idx=None, freq_idx=None, pol=0, freq_mhz=None, time_mjd=None, cmap='inferno', vmin=None, vmax=None, robust=True, figsize=(6, 5), add_colorbar=True, **kwargs)</code>","text":"<p>Extract and plot a spatial cutout.</p> <p>Convenience method that combines <code>cutout()</code> with plotting.</p> <p>Parameters:</p> Name Type Description Default <code>l_center</code> <code>float</code> <p>Center coordinates of the cutout region.</p> required <code>m_center</code> <code>float</code> <p>Center coordinates of the cutout region.</p> required <code>dl</code> <code>float</code> <p>Half-widths of the cutout in l and m directions.</p> required <code>dm</code> <code>float</code> <p>Half-widths of the cutout in l and m directions.</p> required <code>var</code> <code>('SKY', 'BEAM')</code> <p>Data variable to plot.</p> <code>'SKY'</code> <code>time_idx</code> <code>int</code> <p>Time index. Default is 0.</p> <code>None</code> <code>freq_idx</code> <code>int</code> <p>Frequency index. Default is 0.</p> <code>None</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>freq_mhz</code> <code>float</code> <p>Select frequency by value in MHz.</p> <code>None</code> <code>time_mjd</code> <code>float</code> <p>Select time by MJD value.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>Matplotlib colormap.</p> <code>'inferno'</code> <code>vmin</code> <code>float</code> <p>Color scale limits.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>Color scale limits.</p> <code>None</code> <code>robust</code> <code>bool</code> <p>Use percentile-based color scaling.</p> <code>True</code> <code>figsize</code> <code>tuple</code> <p>Figure size in inches.</p> <code>(6, 5)</code> <code>add_colorbar</code> <code>bool</code> <p>Whether to add a colorbar.</p> <code>True</code> <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to imshow.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>The figure containing the cutout plot.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fig = ds.radport.plot_cutout(0.0, 0.0, 0.1, 0.1, freq_mhz=50.0)\n</code></pre> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def plot_cutout(\n    self,\n    l_center: float,\n    m_center: float,\n    dl: float,\n    dm: float,\n    var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n    time_idx: int | None = None,\n    freq_idx: int | None = None,\n    pol: int = 0,\n    freq_mhz: float | None = None,\n    time_mjd: float | None = None,\n    cmap: str = \"inferno\",\n    vmin: float | None = None,\n    vmax: float | None = None,\n    robust: bool = True,\n    figsize: tuple[float, float] = (6, 5),\n    add_colorbar: bool = True,\n    **kwargs: Any,\n) -&gt; Figure:\n    \"\"\"Extract and plot a spatial cutout.\n\n    Convenience method that combines `cutout()` with plotting.\n\n    Parameters\n    ----------\n    l_center, m_center : float\n        Center coordinates of the cutout region.\n    dl, dm : float\n        Half-widths of the cutout in l and m directions.\n    var : {'SKY', 'BEAM'}, default 'SKY'\n        Data variable to plot.\n    time_idx : int, optional\n        Time index. Default is 0.\n    freq_idx : int, optional\n        Frequency index. Default is 0.\n    pol : int, default 0\n        Polarization index.\n    freq_mhz : float, optional\n        Select frequency by value in MHz.\n    time_mjd : float, optional\n        Select time by MJD value.\n    cmap : str, default 'inferno'\n        Matplotlib colormap.\n    vmin, vmax : float, optional\n        Color scale limits.\n    robust : bool, default True\n        Use percentile-based color scaling.\n    figsize : tuple, default (6, 5)\n        Figure size in inches.\n    add_colorbar : bool, default True\n        Whether to add a colorbar.\n    **kwargs : dict\n        Additional arguments passed to imshow.\n\n    Returns\n    -------\n    matplotlib.figure.Figure\n        The figure containing the cutout plot.\n\n    Examples\n    --------\n    &gt;&gt;&gt; fig = ds.radport.plot_cutout(0.0, 0.0, 0.1, 0.1, freq_mhz=50.0)\n    \"\"\"\n    # Get cutout data\n    cutout = self.cutout(\n        l_center=l_center,\n        m_center=m_center,\n        dl=dl,\n        dm=dm,\n        var=var,\n        time_idx=time_idx,\n        freq_idx=freq_idx,\n        pol=pol,\n        freq_mhz=freq_mhz,\n        time_mjd=time_mjd,\n    )\n\n    # Resolve actual indices for title\n    actual_time_idx = cutout.attrs[\"time_idx\"]\n    actual_freq_idx = cutout.attrs[\"freq_idx\"]\n\n    # Create figure\n    fig, ax = plt.subplots(figsize=figsize)\n\n    # Compute data\n    data = cutout.values\n\n    # Handle robust scaling\n    if robust and vmin is None and vmax is None:\n        finite_data = data[np.isfinite(data)]\n        if finite_data.size &gt; 0:\n            vmin = float(np.percentile(finite_data, 2))\n            vmax = float(np.percentile(finite_data, 98))\n\n    # Get coordinate extents\n    l_vals = cutout.coords[\"l\"].values\n    m_vals = cutout.coords[\"m\"].values\n    extent = [\n        float(l_vals.min()), float(l_vals.max()),\n        float(m_vals.min()), float(m_vals.max()),\n    ]\n\n    # Plot\n    im = ax.imshow(\n        data,\n        origin=\"lower\",\n        cmap=cmap,\n        vmin=vmin,\n        vmax=vmax,\n        extent=extent,\n        aspect=\"equal\",\n        **kwargs,\n    )\n\n    if add_colorbar:\n        cbar = fig.colorbar(im, ax=ax)\n        cbar.set_label(\"Jy/beam\")\n\n    # Build title\n    title = self._build_plot_title(var, actual_time_idx, actual_freq_idx, pol)\n    title += f\"\\nl=[{l_center-dl:+.2f},{l_center+dl:+.2f}], m=[{m_center-dm:+.2f},{m_center+dm:+.2f}]\"\n\n    ax.set_xlabel(\"l (direction cosine)\")\n    ax.set_ylabel(\"m (direction cosine)\")\n    ax.set_title(title)\n\n    fig.tight_layout()\n    return fig\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.dynamic_spectrum","title":"<code>dynamic_spectrum(l, m, var='SKY', pol=0)</code>","text":"<p>Extract a dynamic spectrum (time vs frequency) for a single pixel.</p> <p>Returns a 2D DataArray showing how intensity varies across time and frequency at the pixel nearest to the specified (l, m) location.</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>float</code> <p>Target l coordinate for pixel selection.</p> required <code>m</code> <code>float</code> <p>Target m coordinate for pixel selection.</p> required <code>var</code> <code>('SKY', 'BEAM')</code> <p>Data variable to extract.</p> <code>'SKY'</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>2D DataArray with dimensions (time, frequency). Includes metadata: pixel_l, pixel_m, l_idx, m_idx, pol.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Get dynamic spectrum at image center\n&gt;&gt;&gt; dynspec = ds.radport.dynamic_spectrum(l=0.0, m=0.0)\n</code></pre> <pre><code>&gt;&gt;&gt; # Plot it\n&gt;&gt;&gt; dynspec.plot(x='time', y='frequency')\n</code></pre> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def dynamic_spectrum(\n    self,\n    l: float,\n    m: float,\n    var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n    pol: int = 0,\n) -&gt; xr.DataArray:\n    \"\"\"Extract a dynamic spectrum (time vs frequency) for a single pixel.\n\n    Returns a 2D DataArray showing how intensity varies across time\n    and frequency at the pixel nearest to the specified (l, m) location.\n\n    Parameters\n    ----------\n    l : float\n        Target l coordinate for pixel selection.\n    m : float\n        Target m coordinate for pixel selection.\n    var : {'SKY', 'BEAM'}, default 'SKY'\n        Data variable to extract.\n    pol : int, default 0\n        Polarization index.\n\n    Returns\n    -------\n    xr.DataArray\n        2D DataArray with dimensions (time, frequency).\n        Includes metadata: pixel_l, pixel_m, l_idx, m_idx, pol.\n\n    Examples\n    --------\n    &gt;&gt;&gt; # Get dynamic spectrum at image center\n    &gt;&gt;&gt; dynspec = ds.radport.dynamic_spectrum(l=0.0, m=0.0)\n\n    &gt;&gt;&gt; # Plot it\n    &gt;&gt;&gt; dynspec.plot(x='time', y='frequency')\n    \"\"\"\n    # Validate variable\n    if var not in self._obj.data_vars:\n        available = sorted(self._obj.data_vars)\n        raise ValueError(\n            f\"Variable '{var}' not found. Available: {available}\"\n        )\n\n    # Find nearest pixel\n    l_idx, m_idx = self.nearest_lm_idx(l, m)\n\n    # Extract (time, frequency) slice at this pixel\n    da = self._obj[var].isel(l=l_idx, m=m_idx, polarization=pol)\n\n    # Sort by time and frequency for consistent plotting\n    if \"time\" in da.dims:\n        da = da.sortby(\"time\")\n    if \"frequency\" in da.dims:\n        da = da.sortby(\"frequency\")\n\n    # Add metadata\n    da.attrs[\"pixel_l\"] = float(self._obj.coords[\"l\"].values[l_idx])\n    da.attrs[\"pixel_m\"] = float(self._obj.coords[\"m\"].values[m_idx])\n    da.attrs[\"l_idx\"] = l_idx\n    da.attrs[\"m_idx\"] = m_idx\n    da.attrs[\"pol\"] = pol\n\n    return da\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.plot_dynamic_spectrum","title":"<code>plot_dynamic_spectrum(l, m, var='SKY', pol=0, cmap='inferno', vmin=None, vmax=None, robust=True, figsize=(8, 5), add_colorbar=True, **kwargs)</code>","text":"<p>Plot a dynamic spectrum (time vs frequency) for a single pixel.</p> <p>Creates a 2D visualization showing intensity variations across time and frequency at a specified (l, m) location.</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>float</code> <p>Target l coordinate for pixel selection.</p> required <code>m</code> <code>float</code> <p>Target m coordinate for pixel selection.</p> required <code>var</code> <code>('SKY', 'BEAM')</code> <p>Data variable to plot.</p> <code>'SKY'</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>cmap</code> <code>str</code> <p>Matplotlib colormap.</p> <code>'inferno'</code> <code>vmin</code> <code>float</code> <p>Color scale limits.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>Color scale limits.</p> <code>None</code> <code>robust</code> <code>bool</code> <p>Use percentile-based color scaling.</p> <code>True</code> <code>figsize</code> <code>tuple</code> <p>Figure size in inches.</p> <code>(8, 5)</code> <code>add_colorbar</code> <code>bool</code> <p>Whether to add a colorbar.</p> <code>True</code> <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to imshow.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>The figure containing the dynamic spectrum plot.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fig = ds.radport.plot_dynamic_spectrum(l=0.0, m=0.0)\n</code></pre> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def plot_dynamic_spectrum(\n    self,\n    l: float,\n    m: float,\n    var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n    pol: int = 0,\n    cmap: str = \"inferno\",\n    vmin: float | None = None,\n    vmax: float | None = None,\n    robust: bool = True,\n    figsize: tuple[float, float] = (8, 5),\n    add_colorbar: bool = True,\n    **kwargs: Any,\n) -&gt; Figure:\n    \"\"\"Plot a dynamic spectrum (time vs frequency) for a single pixel.\n\n    Creates a 2D visualization showing intensity variations across\n    time and frequency at a specified (l, m) location.\n\n    Parameters\n    ----------\n    l : float\n        Target l coordinate for pixel selection.\n    m : float\n        Target m coordinate for pixel selection.\n    var : {'SKY', 'BEAM'}, default 'SKY'\n        Data variable to plot.\n    pol : int, default 0\n        Polarization index.\n    cmap : str, default 'inferno'\n        Matplotlib colormap.\n    vmin, vmax : float, optional\n        Color scale limits.\n    robust : bool, default True\n        Use percentile-based color scaling.\n    figsize : tuple, default (8, 5)\n        Figure size in inches.\n    add_colorbar : bool, default True\n        Whether to add a colorbar.\n    **kwargs : dict\n        Additional arguments passed to imshow.\n\n    Returns\n    -------\n    matplotlib.figure.Figure\n        The figure containing the dynamic spectrum plot.\n\n    Examples\n    --------\n    &gt;&gt;&gt; fig = ds.radport.plot_dynamic_spectrum(l=0.0, m=0.0)\n    \"\"\"\n    # Get dynamic spectrum\n    dynspec = self.dynamic_spectrum(l=l, m=m, var=var, pol=pol)\n\n    # Create figure\n    fig, ax = plt.subplots(figsize=figsize)\n\n    # Compute data\n    data = dynspec.values\n\n    # Handle robust scaling\n    if robust and vmin is None and vmax is None:\n        finite_data = data[np.isfinite(data)]\n        if finite_data.size &gt; 0:\n            vmin = float(np.percentile(finite_data, 2))\n            vmax = float(np.percentile(finite_data, 98))\n\n    # Get coordinate values\n    time_vals = dynspec.coords[\"time\"].values\n    freq_vals = dynspec.coords[\"frequency\"].values / 1e6  # Convert to MHz\n\n    # Compute extent for imshow\n    # extent = [xmin, xmax, ymin, ymax]\n    extent = [\n        float(time_vals.min()), float(time_vals.max()),\n        float(freq_vals.min()), float(freq_vals.max()),\n    ]\n\n    # Plot - transpose so time is x-axis and frequency is y-axis\n    im = ax.imshow(\n        data.T,\n        origin=\"lower\",\n        cmap=cmap,\n        vmin=vmin,\n        vmax=vmax,\n        extent=extent,\n        aspect=\"auto\",\n        **kwargs,\n    )\n\n    if add_colorbar:\n        cbar = fig.colorbar(im, ax=ax)\n        cbar.set_label(\"Jy/beam\")\n\n    # Labels and title\n    pixel_l = dynspec.attrs[\"pixel_l\"]\n    pixel_m = dynspec.attrs[\"pixel_m\"]\n    ax.set_xlabel(\"Time (MJD)\")\n    ax.set_ylabel(\"Frequency (MHz)\")\n    ax.set_title(\n        f\"{var} Dynamic Spectrum at l={pixel_l:+.4f}, m={pixel_m:+.4f}, pol={pol}\"\n    )\n\n    fig.tight_layout()\n    return fig\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.diff","title":"<code>diff(mode='time', var='SKY', time_idx=None, freq_idx=None, pol=0, freq_mhz=None, time_mjd=None)</code>","text":"<p>Compute a difference map between adjacent time or frequency slices.</p> <p>Useful for identifying transient sources or spectral features by subtracting consecutive frames.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>('time', 'frequency')</code> <p>Difference mode: - 'time': Subtract previous time step from current (at fixed freq) - 'frequency': Subtract previous frequency from current (at fixed time)</p> <code>'time'</code> <code>var</code> <code>('SKY', 'BEAM')</code> <p>Data variable to difference.</p> <code>'SKY'</code> <code>time_idx</code> <code>int</code> <p>Time index for the \"current\" frame. Default is 1. For mode='time', differences frame[time_idx] - frame[time_idx-1].</p> <code>None</code> <code>freq_idx</code> <code>int</code> <p>Frequency index for the \"current\" frame. Default is 1. For mode='frequency', differences frame[freq_idx] - frame[freq_idx-1].</p> <code>None</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>freq_mhz</code> <code>float</code> <p>Select frequency by value in MHz.</p> <code>None</code> <code>time_mjd</code> <code>float</code> <p>Select time by MJD value.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>2D DataArray with dimensions (l, m) containing the difference. Includes metadata: diff_mode, idx1, idx2.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If indices are out of bounds for differencing.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Time difference at fixed frequency\n&gt;&gt;&gt; diff = ds.radport.diff(mode='time', time_idx=5, freq_mhz=50.0)\n</code></pre> <pre><code>&gt;&gt;&gt; # Frequency difference at fixed time\n&gt;&gt;&gt; diff = ds.radport.diff(mode='frequency', freq_idx=10, time_idx=0)\n</code></pre> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def diff(\n    self,\n    mode: Literal[\"time\", \"frequency\"] = \"time\",\n    var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n    time_idx: int | None = None,\n    freq_idx: int | None = None,\n    pol: int = 0,\n    freq_mhz: float | None = None,\n    time_mjd: float | None = None,\n) -&gt; xr.DataArray:\n    \"\"\"Compute a difference map between adjacent time or frequency slices.\n\n    Useful for identifying transient sources or spectral features by\n    subtracting consecutive frames.\n\n    Parameters\n    ----------\n    mode : {'time', 'frequency'}, default 'time'\n        Difference mode:\n        - 'time': Subtract previous time step from current (at fixed freq)\n        - 'frequency': Subtract previous frequency from current (at fixed time)\n    var : {'SKY', 'BEAM'}, default 'SKY'\n        Data variable to difference.\n    time_idx : int, optional\n        Time index for the \"current\" frame. Default is 1.\n        For mode='time', differences frame[time_idx] - frame[time_idx-1].\n    freq_idx : int, optional\n        Frequency index for the \"current\" frame. Default is 1.\n        For mode='frequency', differences frame[freq_idx] - frame[freq_idx-1].\n    pol : int, default 0\n        Polarization index.\n    freq_mhz : float, optional\n        Select frequency by value in MHz.\n    time_mjd : float, optional\n        Select time by MJD value.\n\n    Returns\n    -------\n    xr.DataArray\n        2D DataArray with dimensions (l, m) containing the difference.\n        Includes metadata: diff_mode, idx1, idx2.\n\n    Raises\n    ------\n    ValueError\n        If indices are out of bounds for differencing.\n\n    Examples\n    --------\n    &gt;&gt;&gt; # Time difference at fixed frequency\n    &gt;&gt;&gt; diff = ds.radport.diff(mode='time', time_idx=5, freq_mhz=50.0)\n\n    &gt;&gt;&gt; # Frequency difference at fixed time\n    &gt;&gt;&gt; diff = ds.radport.diff(mode='frequency', freq_idx=10, time_idx=0)\n    \"\"\"\n    # Validate variable\n    if var not in self._obj.data_vars:\n        available = sorted(self._obj.data_vars)\n        raise ValueError(\n            f\"Variable '{var}' not found. Available: {available}\"\n        )\n\n    # Resolve indices\n    if freq_mhz is not None:\n        freq_idx = self.nearest_freq_idx(freq_mhz)\n    elif freq_idx is None:\n        freq_idx = 1 if mode == \"frequency\" else 0\n\n    if time_mjd is not None:\n        time_idx = self.nearest_time_idx(time_mjd)\n    elif time_idx is None:\n        time_idx = 1 if mode == \"time\" else 0\n\n    # Compute difference based on mode\n    if mode == \"time\":\n        if time_idx &lt; 1:\n            raise ValueError(\n                f\"time_idx must be &gt;= 1 for time differencing. Got {time_idx}.\"\n            )\n        n_times = self._obj.sizes[\"time\"]\n        if time_idx &gt;= n_times:\n            raise ValueError(\n                f\"time_idx {time_idx} out of bounds (dataset has {n_times} times).\"\n            )\n\n        frame_current = self._obj[var].isel(\n            time=time_idx, frequency=freq_idx, polarization=pol\n        )\n        frame_prev = self._obj[var].isel(\n            time=time_idx - 1, frequency=freq_idx, polarization=pol\n        )\n        diff = frame_current - frame_prev\n\n        diff.attrs[\"diff_mode\"] = \"time\"\n        diff.attrs[\"time_idx_current\"] = time_idx\n        diff.attrs[\"time_idx_prev\"] = time_idx - 1\n        diff.attrs[\"freq_idx\"] = freq_idx\n\n    else:  # mode == \"frequency\"\n        if freq_idx &lt; 1:\n            raise ValueError(\n                f\"freq_idx must be &gt;= 1 for frequency differencing. Got {freq_idx}.\"\n            )\n        n_freqs = self._obj.sizes[\"frequency\"]\n        if freq_idx &gt;= n_freqs:\n            raise ValueError(\n                f\"freq_idx {freq_idx} out of bounds (dataset has {n_freqs} frequencies).\"\n            )\n\n        frame_current = self._obj[var].isel(\n            time=time_idx, frequency=freq_idx, polarization=pol\n        )\n        frame_prev = self._obj[var].isel(\n            time=time_idx, frequency=freq_idx - 1, polarization=pol\n        )\n        diff = frame_current - frame_prev\n\n        diff.attrs[\"diff_mode\"] = \"frequency\"\n        diff.attrs[\"freq_idx_current\"] = freq_idx\n        diff.attrs[\"freq_idx_prev\"] = freq_idx - 1\n        diff.attrs[\"time_idx\"] = time_idx\n\n    diff.attrs[\"pol\"] = pol\n    return diff\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.plot_diff","title":"<code>plot_diff(mode='time', var='SKY', time_idx=None, freq_idx=None, pol=0, freq_mhz=None, time_mjd=None, cmap='RdBu_r', vmin=None, vmax=None, symmetric=True, figsize=(8, 6), add_colorbar=True, **kwargs)</code>","text":"<p>Plot a difference map between adjacent time or frequency slices.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>('time', 'frequency')</code> <p>Difference mode.</p> <code>'time'</code> <code>var</code> <code>('SKY', 'BEAM')</code> <p>Data variable to difference.</p> <code>'SKY'</code> <code>time_idx</code> <code>int</code> <p>Time index for the \"current\" frame.</p> <code>None</code> <code>freq_idx</code> <code>int</code> <p>Frequency index for the \"current\" frame.</p> <code>None</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>freq_mhz</code> <code>float</code> <p>Select frequency by value in MHz.</p> <code>None</code> <code>time_mjd</code> <code>float</code> <p>Select time by MJD value.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>Colormap (diverging colormaps work well for differences).</p> <code>'RdBu_r'</code> <code>vmin</code> <code>float</code> <p>Color scale limits.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>Color scale limits.</p> <code>None</code> <code>symmetric</code> <code>bool</code> <p>If True and vmin/vmax not specified, use symmetric color scale centered on zero.</p> <code>True</code> <code>figsize</code> <code>tuple</code> <p>Figure size in inches.</p> <code>(8, 6)</code> <code>add_colorbar</code> <code>bool</code> <p>Whether to add a colorbar.</p> <code>True</code> <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to imshow.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>The figure containing the difference plot.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fig = ds.radport.plot_diff(mode='time', time_idx=5, freq_mhz=50.0)\n</code></pre> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def plot_diff(\n    self,\n    mode: Literal[\"time\", \"frequency\"] = \"time\",\n    var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n    time_idx: int | None = None,\n    freq_idx: int | None = None,\n    pol: int = 0,\n    freq_mhz: float | None = None,\n    time_mjd: float | None = None,\n    cmap: str = \"RdBu_r\",\n    vmin: float | None = None,\n    vmax: float | None = None,\n    symmetric: bool = True,\n    figsize: tuple[float, float] = (8, 6),\n    add_colorbar: bool = True,\n    **kwargs: Any,\n) -&gt; Figure:\n    \"\"\"Plot a difference map between adjacent time or frequency slices.\n\n    Parameters\n    ----------\n    mode : {'time', 'frequency'}, default 'time'\n        Difference mode.\n    var : {'SKY', 'BEAM'}, default 'SKY'\n        Data variable to difference.\n    time_idx : int, optional\n        Time index for the \"current\" frame.\n    freq_idx : int, optional\n        Frequency index for the \"current\" frame.\n    pol : int, default 0\n        Polarization index.\n    freq_mhz : float, optional\n        Select frequency by value in MHz.\n    time_mjd : float, optional\n        Select time by MJD value.\n    cmap : str, default 'RdBu_r'\n        Colormap (diverging colormaps work well for differences).\n    vmin, vmax : float, optional\n        Color scale limits.\n    symmetric : bool, default True\n        If True and vmin/vmax not specified, use symmetric color scale\n        centered on zero.\n    figsize : tuple, default (8, 6)\n        Figure size in inches.\n    add_colorbar : bool, default True\n        Whether to add a colorbar.\n    **kwargs : dict\n        Additional arguments passed to imshow.\n\n    Returns\n    -------\n    matplotlib.figure.Figure\n        The figure containing the difference plot.\n\n    Examples\n    --------\n    &gt;&gt;&gt; fig = ds.radport.plot_diff(mode='time', time_idx=5, freq_mhz=50.0)\n    \"\"\"\n    # Get difference data\n    diff = self.diff(\n        mode=mode,\n        var=var,\n        time_idx=time_idx,\n        freq_idx=freq_idx,\n        pol=pol,\n        freq_mhz=freq_mhz,\n        time_mjd=time_mjd,\n    )\n\n    # Create figure\n    fig, ax = plt.subplots(figsize=figsize)\n\n    # Compute data\n    data = diff.values\n\n    # Handle symmetric scaling\n    if symmetric and vmin is None and vmax is None:\n        finite_data = data[np.isfinite(data)]\n        if finite_data.size &gt; 0:\n            max_abs = float(np.percentile(np.abs(finite_data), 98))\n            vmin, vmax = -max_abs, max_abs\n\n    # Get coordinate extents\n    l_vals = diff.coords[\"l\"].values\n    m_vals = diff.coords[\"m\"].values\n    extent = [\n        float(l_vals.min()), float(l_vals.max()),\n        float(m_vals.min()), float(m_vals.max()),\n    ]\n\n    # Plot\n    im = ax.imshow(\n        data,\n        origin=\"lower\",\n        cmap=cmap,\n        vmin=vmin,\n        vmax=vmax,\n        extent=extent,\n        aspect=\"equal\",\n        **kwargs,\n    )\n\n    if add_colorbar:\n        cbar = fig.colorbar(im, ax=ax)\n        cbar.set_label(\"\u0394Jy/beam\")\n\n    # Build title\n    if mode == \"time\":\n        t_curr = diff.attrs[\"time_idx_current\"]\n        t_prev = diff.attrs[\"time_idx_prev\"]\n        f_idx = diff.attrs[\"freq_idx\"]\n        freq_mhz_val = float(self._obj.coords[\"frequency\"].values[f_idx]) / 1e6\n        title = f\"{var} Time Diff (t{t_curr} - t{t_prev}) at f={freq_mhz_val:.2f} MHz\"\n    else:\n        f_curr = diff.attrs[\"freq_idx_current\"]\n        f_prev = diff.attrs[\"freq_idx_prev\"]\n        t_idx = diff.attrs[\"time_idx\"]\n        freq_curr_mhz = float(self._obj.coords[\"frequency\"].values[f_curr]) / 1e6\n        freq_prev_mhz = float(self._obj.coords[\"frequency\"].values[f_prev]) / 1e6\n        time_val = self._obj.coords[\"time\"].values[t_idx]\n        title = f\"{var} Freq Diff ({freq_curr_mhz:.1f} - {freq_prev_mhz:.1f} MHz) at t={float(time_val):.6f}\"\n\n    ax.set_xlabel(\"l (direction cosine)\")\n    ax.set_ylabel(\"m (direction cosine)\")\n    ax.set_title(title)\n\n    fig.tight_layout()\n    return fig\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.find_valid_frame","title":"<code>find_valid_frame(var='SKY', pol=0, min_finite_fraction=0.1)</code>","text":"<p>Find the first (time, freq) frame with sufficient finite data.</p> <p>Searches through time and frequency indices to find a frame where at least <code>min_finite_fraction</code> of pixels contain finite (non-NaN) values. Useful for automatically selecting a valid frame for visualization.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>('SKY', 'BEAM')</code> <p>Data variable to check.</p> <code>'SKY'</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>min_finite_fraction</code> <code>float</code> <p>Minimum fraction of finite pixels required (0 to 1).</p> <code>0.1</code> <p>Returns:</p> Type Description <code>tuple of int</code> <p>(time_idx, freq_idx) of the first valid frame.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no valid frame is found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; time_idx, freq_idx = ds.radport.find_valid_frame()\n&gt;&gt;&gt; fig = ds.radport.plot(time_idx=time_idx, freq_idx=freq_idx)\n</code></pre> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def find_valid_frame(\n    self,\n    var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n    pol: int = 0,\n    min_finite_fraction: float = 0.1,\n) -&gt; tuple[int, int]:\n    \"\"\"Find the first (time, freq) frame with sufficient finite data.\n\n    Searches through time and frequency indices to find a frame where\n    at least `min_finite_fraction` of pixels contain finite (non-NaN) values.\n    Useful for automatically selecting a valid frame for visualization.\n\n    Parameters\n    ----------\n    var : {'SKY', 'BEAM'}, default 'SKY'\n        Data variable to check.\n    pol : int, default 0\n        Polarization index.\n    min_finite_fraction : float, default 0.1\n        Minimum fraction of finite pixels required (0 to 1).\n\n    Returns\n    -------\n    tuple of int\n        (time_idx, freq_idx) of the first valid frame.\n\n    Raises\n    ------\n    ValueError\n        If no valid frame is found.\n\n    Examples\n    --------\n    &gt;&gt;&gt; time_idx, freq_idx = ds.radport.find_valid_frame()\n    &gt;&gt;&gt; fig = ds.radport.plot(time_idx=time_idx, freq_idx=freq_idx)\n    \"\"\"\n    if var not in self._obj.data_vars:\n        available = sorted(self._obj.data_vars)\n        raise ValueError(f\"Variable '{var}' not found. Available: {available}\")\n\n    da = self._obj[var].isel(polarization=pol)\n\n    # Compute fraction of finite values for each (time, freq) plane\n    finite_frac = np.isfinite(da).mean(dim=(\"l\", \"m\"))\n\n    # If data is lazy (dask), compute it\n    if hasattr(finite_frac, \"compute\"):\n        finite_frac = finite_frac.compute()\n\n    arr = finite_frac.values\n\n    # Search for first valid frame\n    for ti in range(arr.shape[0]):\n        for fi in range(arr.shape[1]):\n            if arr[ti, fi] &gt;= min_finite_fraction:\n                return ti, fi\n\n    raise ValueError(\n        f\"No valid frame found with at least {min_finite_fraction:.0%} finite pixels. \"\n        f\"Dataset may contain all NaN values.\"\n    )\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.finite_fraction","title":"<code>finite_fraction(var='SKY', pol=0)</code>","text":"<p>Compute the fraction of finite (non-NaN) pixels for each (time, freq).</p> <p>Returns a 2D DataArray showing data availability across all time and frequency combinations. Useful for identifying which frames contain valid data.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>('SKY', 'BEAM')</code> <p>Data variable to check.</p> <code>'SKY'</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>2D array with dimensions (time, frequency) containing fractions from 0 (all NaN) to 1 (all finite).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; frac = ds.radport.finite_fraction()\n&gt;&gt;&gt; frac.plot()  # Visualize data availability\n</code></pre> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def finite_fraction(\n    self,\n    var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n    pol: int = 0,\n) -&gt; xr.DataArray:\n    \"\"\"Compute the fraction of finite (non-NaN) pixels for each (time, freq).\n\n    Returns a 2D DataArray showing data availability across all\n    time and frequency combinations. Useful for identifying which\n    frames contain valid data.\n\n    Parameters\n    ----------\n    var : {'SKY', 'BEAM'}, default 'SKY'\n        Data variable to check.\n    pol : int, default 0\n        Polarization index.\n\n    Returns\n    -------\n    xr.DataArray\n        2D array with dimensions (time, frequency) containing fractions\n        from 0 (all NaN) to 1 (all finite).\n\n    Examples\n    --------\n    &gt;&gt;&gt; frac = ds.radport.finite_fraction()\n    &gt;&gt;&gt; frac.plot()  # Visualize data availability\n    \"\"\"\n    if var not in self._obj.data_vars:\n        available = sorted(self._obj.data_vars)\n        raise ValueError(f\"Variable '{var}' not found. Available: {available}\")\n\n    da = self._obj[var].isel(polarization=pol)\n    finite_frac = np.isfinite(da).mean(dim=(\"l\", \"m\"))\n\n    finite_frac.attrs[\"variable\"] = var\n    finite_frac.attrs[\"pol\"] = pol\n\n    return finite_frac\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.plot_grid","title":"<code>plot_grid(time_indices=None, freq_indices=None, freq_mhz_list=None, var='SKY', pol=0, ncols=4, panel_size=(3.0, 2.6), cmap='inferno', vmin=None, vmax=None, robust=True, mask_radius=None, share_colorbar=True, **kwargs)</code>","text":"<p>Create a grid of plots showing multiple time/frequency combinations.</p> <p>Useful for comparing observations across time or frequency in a single figure with consistent scaling.</p> <p>Parameters:</p> Name Type Description Default <code>time_indices</code> <code>list of int</code> <p>Time indices to plot. If None, uses all available times.</p> <code>None</code> <code>freq_indices</code> <code>list of int</code> <p>Frequency indices to plot. If None, uses all available frequencies. Ignored if <code>freq_mhz_list</code> is provided.</p> <code>None</code> <code>freq_mhz_list</code> <code>list of float</code> <p>Frequencies in MHz to plot. Overrides <code>freq_indices</code>.</p> <code>None</code> <code>var</code> <code>('SKY', 'BEAM')</code> <p>Data variable to plot.</p> <code>'SKY'</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>ncols</code> <code>int</code> <p>Number of columns in the grid.</p> <code>4</code> <code>panel_size</code> <code>tuple of float</code> <p>Size of each panel in inches as (width, height).</p> <code>(3.0, 2.6)</code> <code>cmap</code> <code>str</code> <p>Matplotlib colormap.</p> <code>'inferno'</code> <code>vmin</code> <code>float</code> <p>Color scale limits. Applied to all panels.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>Color scale limits. Applied to all panels.</p> <code>None</code> <code>robust</code> <code>bool</code> <p>If True and vmin/vmax not specified, compute global percentile scaling across all panels.</p> <code>True</code> <code>mask_radius</code> <code>int</code> <p>Circular mask radius in pixels.</p> <code>None</code> <code>share_colorbar</code> <code>bool</code> <p>If True, show a single shared colorbar for all panels.</p> <code>True</code> <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to imshow.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>The figure containing the grid of plots.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Plot all times at a single frequency\n&gt;&gt;&gt; fig = ds.radport.plot_grid(freq_mhz_list=[50.0])\n</code></pre> <pre><code>&gt;&gt;&gt; # Plot specific times and frequencies\n&gt;&gt;&gt; fig = ds.radport.plot_grid(\n...     time_indices=[0, 1, 2],\n...     freq_mhz_list=[46.0, 50.0, 54.0],\n... )\n</code></pre> <pre><code>&gt;&gt;&gt; # Plot first 4 times at all frequencies\n&gt;&gt;&gt; fig = ds.radport.plot_grid(time_indices=[0, 1, 2, 3])\n</code></pre> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def plot_grid(\n    self,\n    time_indices: list[int] | None = None,\n    freq_indices: list[int] | None = None,\n    freq_mhz_list: list[float] | None = None,\n    var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n    pol: int = 0,\n    ncols: int = 4,\n    panel_size: tuple[float, float] = (3.0, 2.6),\n    cmap: str = \"inferno\",\n    vmin: float | None = None,\n    vmax: float | None = None,\n    robust: bool = True,\n    mask_radius: int | None = None,\n    share_colorbar: bool = True,\n    **kwargs: Any,\n) -&gt; Figure:\n    \"\"\"Create a grid of plots showing multiple time/frequency combinations.\n\n    Useful for comparing observations across time or frequency in a\n    single figure with consistent scaling.\n\n    Parameters\n    ----------\n    time_indices : list of int, optional\n        Time indices to plot. If None, uses all available times.\n    freq_indices : list of int, optional\n        Frequency indices to plot. If None, uses all available frequencies.\n        Ignored if `freq_mhz_list` is provided.\n    freq_mhz_list : list of float, optional\n        Frequencies in MHz to plot. Overrides `freq_indices`.\n    var : {'SKY', 'BEAM'}, default 'SKY'\n        Data variable to plot.\n    pol : int, default 0\n        Polarization index.\n    ncols : int, default 4\n        Number of columns in the grid.\n    panel_size : tuple of float, default (3.0, 2.6)\n        Size of each panel in inches as (width, height).\n    cmap : str, default 'inferno'\n        Matplotlib colormap.\n    vmin, vmax : float, optional\n        Color scale limits. Applied to all panels.\n    robust : bool, default True\n        If True and vmin/vmax not specified, compute global percentile\n        scaling across all panels.\n    mask_radius : int, optional\n        Circular mask radius in pixels.\n    share_colorbar : bool, default True\n        If True, show a single shared colorbar for all panels.\n    **kwargs : dict\n        Additional arguments passed to imshow.\n\n    Returns\n    -------\n    matplotlib.figure.Figure\n        The figure containing the grid of plots.\n\n    Examples\n    --------\n    &gt;&gt;&gt; # Plot all times at a single frequency\n    &gt;&gt;&gt; fig = ds.radport.plot_grid(freq_mhz_list=[50.0])\n\n    &gt;&gt;&gt; # Plot specific times and frequencies\n    &gt;&gt;&gt; fig = ds.radport.plot_grid(\n    ...     time_indices=[0, 1, 2],\n    ...     freq_mhz_list=[46.0, 50.0, 54.0],\n    ... )\n\n    &gt;&gt;&gt; # Plot first 4 times at all frequencies\n    &gt;&gt;&gt; fig = ds.radport.plot_grid(time_indices=[0, 1, 2, 3])\n    \"\"\"\n    # Validate variable\n    if var not in self._obj.data_vars:\n        available = sorted(self._obj.data_vars)\n        raise ValueError(f\"Variable '{var}' not found. Available: {available}\")\n\n    # Resolve time indices\n    if time_indices is None:\n        time_indices = list(range(self._obj.sizes[\"time\"]))\n\n    # Resolve frequency indices\n    if freq_mhz_list is not None:\n        freq_indices = [self.nearest_freq_idx(f) for f in freq_mhz_list]\n    elif freq_indices is None:\n        freq_indices = list(range(self._obj.sizes[\"frequency\"]))\n\n    # Calculate grid dimensions\n    n_panels = len(time_indices) * len(freq_indices)\n    if n_panels == 0:\n        raise ValueError(\"No panels to plot. Check time_indices and freq_indices.\")\n\n    nrows = int(np.ceil(n_panels / ncols))\n\n    # Create figure\n    fig_width = panel_size[0] * ncols\n    fig_height = panel_size[1] * nrows\n    fig, axes = plt.subplots(\n        nrows, ncols,\n        figsize=(fig_width, fig_height),\n        squeeze=False,\n    )\n\n    # Collect all data for global scaling if robust=True\n    all_data = []\n    panel_data = []\n\n    for ti in time_indices:\n        for fi in freq_indices:\n            da = self._obj[var].isel(\n                time=ti, frequency=fi, polarization=pol\n            )\n            data = da.values.copy()\n\n            # Apply mask if requested\n            if mask_radius is not None:\n                ny, nx = data.shape\n                cy, cx = ny // 2, nx // 2\n                yy, xx = np.ogrid[:ny, :nx]\n                dist = np.sqrt((yy - cy) ** 2 + (xx - cx) ** 2)\n                data[dist &gt; mask_radius] = np.nan\n\n            panel_data.append((ti, fi, data, da))\n            if robust and vmin is None and vmax is None:\n                finite = data[np.isfinite(data)]\n                if finite.size &gt; 0:\n                    all_data.append(finite)\n\n    # Compute global vmin/vmax if robust\n    if robust and vmin is None and vmax is None and all_data:\n        all_finite = np.concatenate(all_data)\n        vmin = float(np.percentile(all_finite, 2))\n        vmax = float(np.percentile(all_finite, 98))\n\n    # Plot each panel\n    im = None\n    for idx, (ti, fi, data, da) in enumerate(panel_data):\n        row, col = divmod(idx, ncols)\n        ax = axes[row, col]\n\n        # Get coordinate extents\n        l_vals = da.coords[\"l\"].values\n        m_vals = da.coords[\"m\"].values\n        extent = [\n            float(l_vals.min()), float(l_vals.max()),\n            float(m_vals.min()), float(m_vals.max()),\n        ]\n\n        # Check if panel has data\n        has_data = np.any(np.isfinite(data))\n\n        if has_data:\n            im = ax.imshow(\n                data,\n                origin=\"lower\",\n                cmap=cmap,\n                vmin=vmin,\n                vmax=vmax,\n                extent=extent,\n                aspect=\"equal\",\n                **kwargs,\n            )\n        else:\n            ax.text(\n                0.5, 0.5, \"No Data\",\n                ha=\"center\", va=\"center\",\n                transform=ax.transAxes,\n                fontsize=10,\n            )\n            ax.set_xlim(extent[0], extent[1])\n            ax.set_ylim(extent[2], extent[3])\n\n        # Build panel title\n        time_val = self._obj.coords[\"time\"].values[ti]\n        freq_val = self._obj.coords[\"frequency\"].values[fi] / 1e6\n        try:\n            time_str = f\"{float(time_val):.6f}\"\n        except (TypeError, ValueError):\n            time_str = str(time_val)\n\n        ax.set_title(f\"t={time_str}\\nf={freq_val:.2f} MHz\", fontsize=9)\n        ax.set_xticks([])\n        ax.set_yticks([])\n\n    # Hide unused panels\n    for idx in range(n_panels, nrows * ncols):\n        row, col = divmod(idx, ncols)\n        axes[row, col].axis(\"off\")\n\n    # Add shared colorbar\n    if share_colorbar and im is not None:\n        fig.subplots_adjust(right=0.9)\n        cbar_ax = fig.add_axes([0.92, 0.15, 0.02, 0.7])\n        cbar = fig.colorbar(im, cax=cbar_ax)\n        cbar.set_label(\"Jy/beam\")\n\n    fig.suptitle(f\"{var} Grid (pol={pol})\", fontsize=12, y=1.02)\n\n    return fig\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.plot_frequency_grid","title":"<code>plot_frequency_grid(time_idx=0, freq_mhz_list=None, var='SKY', pol=0, ncols=4, panel_size=(3.0, 2.6), cmap='inferno', vmin=None, vmax=None, robust=True, mask_radius=None, **kwargs)</code>","text":"<p>Create a grid showing all frequencies at a fixed time.</p> <p>Convenience method for comparing across frequency channels.</p> <p>Parameters:</p> Name Type Description Default <code>time_idx</code> <code>int</code> <p>Time index for all panels.</p> <code>0</code> <code>freq_mhz_list</code> <code>list of float</code> <p>Specific frequencies to plot. If None, plots all frequencies.</p> <code>None</code> <code>var</code> <code>('SKY', 'BEAM')</code> <p>Data variable to plot.</p> <code>'SKY'</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>ncols</code> <code>int</code> <p>Number of columns.</p> <code>4</code> <code>panel_size</code> <code>tuple</code> <p>Size of each panel.</p> <code>(3.0, 2.6)</code> <code>cmap</code> <code>str</code> <p>Colormap.</p> <code>'inferno'</code> <code>vmin</code> <code>float</code> <p>Color scale limits.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>Color scale limits.</p> <code>None</code> <code>robust</code> <code>bool</code> <p>Use percentile-based scaling.</p> <code>True</code> <code>mask_radius</code> <code>int</code> <p>Circular mask radius.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to imshow.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fig = ds.radport.plot_frequency_grid(time_idx=0)\n</code></pre> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def plot_frequency_grid(\n    self,\n    time_idx: int = 0,\n    freq_mhz_list: list[float] | None = None,\n    var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n    pol: int = 0,\n    ncols: int = 4,\n    panel_size: tuple[float, float] = (3.0, 2.6),\n    cmap: str = \"inferno\",\n    vmin: float | None = None,\n    vmax: float | None = None,\n    robust: bool = True,\n    mask_radius: int | None = None,\n    **kwargs: Any,\n) -&gt; Figure:\n    \"\"\"Create a grid showing all frequencies at a fixed time.\n\n    Convenience method for comparing across frequency channels.\n\n    Parameters\n    ----------\n    time_idx : int, default 0\n        Time index for all panels.\n    freq_mhz_list : list of float, optional\n        Specific frequencies to plot. If None, plots all frequencies.\n    var : {'SKY', 'BEAM'}, default 'SKY'\n        Data variable to plot.\n    pol : int, default 0\n        Polarization index.\n    ncols : int, default 4\n        Number of columns.\n    panel_size : tuple, default (3.0, 2.6)\n        Size of each panel.\n    cmap : str, default 'inferno'\n        Colormap.\n    vmin, vmax : float, optional\n        Color scale limits.\n    robust : bool, default True\n        Use percentile-based scaling.\n    mask_radius : int, optional\n        Circular mask radius.\n    **kwargs : dict\n        Additional arguments passed to imshow.\n\n    Returns\n    -------\n    matplotlib.figure.Figure\n\n    Examples\n    --------\n    &gt;&gt;&gt; fig = ds.radport.plot_frequency_grid(time_idx=0)\n    \"\"\"\n    return self.plot_grid(\n        time_indices=[time_idx],\n        freq_mhz_list=freq_mhz_list,\n        var=var,\n        pol=pol,\n        ncols=ncols,\n        panel_size=panel_size,\n        cmap=cmap,\n        vmin=vmin,\n        vmax=vmax,\n        robust=robust,\n        mask_radius=mask_radius,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.plot_time_grid","title":"<code>plot_time_grid(freq_idx=None, freq_mhz=None, time_indices=None, var='SKY', pol=0, ncols=4, panel_size=(3.0, 2.6), cmap='inferno', vmin=None, vmax=None, robust=True, mask_radius=None, **kwargs)</code>","text":"<p>Create a grid showing all times at a fixed frequency.</p> <p>Convenience method for comparing across time steps (time evolution).</p> <p>Parameters:</p> Name Type Description Default <code>freq_idx</code> <code>int</code> <p>Frequency index. Default is 0. Ignored if <code>freq_mhz</code> is provided.</p> <code>None</code> <code>freq_mhz</code> <code>float</code> <p>Frequency in MHz (overrides freq_idx).</p> <code>None</code> <code>time_indices</code> <code>list of int</code> <p>Specific time indices to plot. If None, plots all times.</p> <code>None</code> <code>var</code> <code>('SKY', 'BEAM')</code> <p>Data variable to plot.</p> <code>'SKY'</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>ncols</code> <code>int</code> <p>Number of columns.</p> <code>4</code> <code>panel_size</code> <code>tuple</code> <p>Size of each panel.</p> <code>(3.0, 2.6)</code> <code>cmap</code> <code>str</code> <p>Colormap.</p> <code>'inferno'</code> <code>vmin</code> <code>float</code> <p>Color scale limits.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>Color scale limits.</p> <code>None</code> <code>robust</code> <code>bool</code> <p>Use percentile-based scaling.</p> <code>True</code> <code>mask_radius</code> <code>int</code> <p>Circular mask radius.</p> <code>None</code> <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to imshow.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fig = ds.radport.plot_time_grid(freq_mhz=50.0)\n</code></pre> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def plot_time_grid(\n    self,\n    freq_idx: int | None = None,\n    freq_mhz: float | None = None,\n    time_indices: list[int] | None = None,\n    var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n    pol: int = 0,\n    ncols: int = 4,\n    panel_size: tuple[float, float] = (3.0, 2.6),\n    cmap: str = \"inferno\",\n    vmin: float | None = None,\n    vmax: float | None = None,\n    robust: bool = True,\n    mask_radius: int | None = None,\n    **kwargs: Any,\n) -&gt; Figure:\n    \"\"\"Create a grid showing all times at a fixed frequency.\n\n    Convenience method for comparing across time steps (time evolution).\n\n    Parameters\n    ----------\n    freq_idx : int, optional\n        Frequency index. Default is 0. Ignored if `freq_mhz` is provided.\n    freq_mhz : float, optional\n        Frequency in MHz (overrides freq_idx).\n    time_indices : list of int, optional\n        Specific time indices to plot. If None, plots all times.\n    var : {'SKY', 'BEAM'}, default 'SKY'\n        Data variable to plot.\n    pol : int, default 0\n        Polarization index.\n    ncols : int, default 4\n        Number of columns.\n    panel_size : tuple, default (3.0, 2.6)\n        Size of each panel.\n    cmap : str, default 'inferno'\n        Colormap.\n    vmin, vmax : float, optional\n        Color scale limits.\n    robust : bool, default True\n        Use percentile-based scaling.\n    mask_radius : int, optional\n        Circular mask radius.\n    **kwargs : dict\n        Additional arguments passed to imshow.\n\n    Returns\n    -------\n    matplotlib.figure.Figure\n\n    Examples\n    --------\n    &gt;&gt;&gt; fig = ds.radport.plot_time_grid(freq_mhz=50.0)\n    \"\"\"\n    # Resolve frequency\n    if freq_mhz is not None:\n        freq_indices = [self.nearest_freq_idx(freq_mhz)]\n    elif freq_idx is not None:\n        freq_indices = [freq_idx]\n    else:\n        freq_indices = [0]\n\n    return self.plot_grid(\n        time_indices=time_indices,\n        freq_indices=freq_indices,\n        var=var,\n        pol=pol,\n        ncols=ncols,\n        panel_size=panel_size,\n        cmap=cmap,\n        vmin=vmin,\n        vmax=vmax,\n        robust=robust,\n        mask_radius=mask_radius,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.light_curve","title":"<code>light_curve(l, m, freq_idx=None, freq_mhz=None, var='SKY', pol=0)</code>","text":"<p>Extract a light curve (time series) at a specific spatial location.</p> <p>Returns intensity as a function of time at the pixel nearest to the specified (l, m) coordinates and frequency.</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>float</code> <p>Direction cosine l coordinate.</p> required <code>m</code> <code>float</code> <p>Direction cosine m coordinate.</p> required <code>freq_idx</code> <code>int</code> <p>Frequency index. Default is 0. Ignored if <code>freq_mhz</code> is provided.</p> <code>None</code> <code>freq_mhz</code> <code>float</code> <p>Frequency in MHz (overrides freq_idx).</p> <code>None</code> <code>var</code> <code>('SKY', 'BEAM')</code> <p>Data variable to extract.</p> <code>'SKY'</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>1D array with dimension 'time' containing the light curve.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lc = ds.radport.light_curve(l=0.0, m=0.0, freq_mhz=50.0)\n&gt;&gt;&gt; lc.plot()  # Plot intensity vs time\n</code></pre> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def light_curve(\n    self,\n    l: float,\n    m: float,\n    freq_idx: int | None = None,\n    freq_mhz: float | None = None,\n    var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n    pol: int = 0,\n) -&gt; xr.DataArray:\n    \"\"\"Extract a light curve (time series) at a specific spatial location.\n\n    Returns intensity as a function of time at the pixel nearest to\n    the specified (l, m) coordinates and frequency.\n\n    Parameters\n    ----------\n    l : float\n        Direction cosine l coordinate.\n    m : float\n        Direction cosine m coordinate.\n    freq_idx : int, optional\n        Frequency index. Default is 0. Ignored if `freq_mhz` is provided.\n    freq_mhz : float, optional\n        Frequency in MHz (overrides freq_idx).\n    var : {'SKY', 'BEAM'}, default 'SKY'\n        Data variable to extract.\n    pol : int, default 0\n        Polarization index.\n\n    Returns\n    -------\n    xr.DataArray\n        1D array with dimension 'time' containing the light curve.\n\n    Examples\n    --------\n    &gt;&gt;&gt; lc = ds.radport.light_curve(l=0.0, m=0.0, freq_mhz=50.0)\n    &gt;&gt;&gt; lc.plot()  # Plot intensity vs time\n    \"\"\"\n    if var not in self._obj.data_vars:\n        available = sorted(self._obj.data_vars)\n        raise ValueError(f\"Variable '{var}' not found. Available: {available}\")\n\n    # Resolve frequency index\n    if freq_mhz is not None:\n        fi = self.nearest_freq_idx(freq_mhz)\n    elif freq_idx is not None:\n        fi = freq_idx\n    else:\n        fi = 0\n\n    # Find nearest pixel\n    l_idx, m_idx = self.nearest_lm_idx(l, m)\n\n    # Extract light curve\n    lc = self._obj[var].isel(\n        frequency=fi,\n        polarization=pol,\n        l=l_idx,\n        m=m_idx,\n    )\n\n    # Add metadata\n    freq_hz = float(self._obj.coords[\"frequency\"].values[fi])\n    l_val = float(self._obj.coords[\"l\"].values[l_idx])\n    m_val = float(self._obj.coords[\"m\"].values[m_idx])\n\n    lc.attrs[\"variable\"] = var\n    lc.attrs[\"freq_idx\"] = fi\n    lc.attrs[\"freq_mhz\"] = freq_hz / 1e6\n    lc.attrs[\"pol\"] = pol\n    lc.attrs[\"l\"] = l_val\n    lc.attrs[\"m\"] = m_val\n    lc.attrs[\"l_idx\"] = l_idx\n    lc.attrs[\"m_idx\"] = m_idx\n\n    return lc\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.plot_light_curve","title":"<code>plot_light_curve(l, m, freq_idx=None, freq_mhz=None, var='SKY', pol=0, figsize=(10, 4), marker='o', linestyle='-', **kwargs)</code>","text":"<p>Plot a light curve (time series) at a specific spatial location.</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>float</code> <p>Direction cosine l coordinate.</p> required <code>m</code> <code>float</code> <p>Direction cosine m coordinate.</p> required <code>freq_idx</code> <code>int</code> <p>Frequency index. Default is 0. Ignored if <code>freq_mhz</code> is provided.</p> <code>None</code> <code>freq_mhz</code> <code>float</code> <p>Frequency in MHz (overrides freq_idx).</p> <code>None</code> <code>var</code> <code>('SKY', 'BEAM')</code> <p>Data variable to plot.</p> <code>'SKY'</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>figsize</code> <code>tuple</code> <p>Figure size in inches.</p> <code>(10, 4)</code> <code>marker</code> <code>str</code> <p>Marker style for data points.</p> <code>'o'</code> <code>linestyle</code> <code>str</code> <p>Line style connecting points.</p> <code>'-'</code> <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to plt.plot.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fig = ds.radport.plot_light_curve(l=0.0, m=0.0, freq_mhz=50.0)\n</code></pre> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def plot_light_curve(\n    self,\n    l: float,\n    m: float,\n    freq_idx: int | None = None,\n    freq_mhz: float | None = None,\n    var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n    pol: int = 0,\n    figsize: tuple[float, float] = (10, 4),\n    marker: str = \"o\",\n    linestyle: str = \"-\",\n    **kwargs: Any,\n) -&gt; Figure:\n    \"\"\"Plot a light curve (time series) at a specific spatial location.\n\n    Parameters\n    ----------\n    l : float\n        Direction cosine l coordinate.\n    m : float\n        Direction cosine m coordinate.\n    freq_idx : int, optional\n        Frequency index. Default is 0. Ignored if `freq_mhz` is provided.\n    freq_mhz : float, optional\n        Frequency in MHz (overrides freq_idx).\n    var : {'SKY', 'BEAM'}, default 'SKY'\n        Data variable to plot.\n    pol : int, default 0\n        Polarization index.\n    figsize : tuple, default (10, 4)\n        Figure size in inches.\n    marker : str, default 'o'\n        Marker style for data points.\n    linestyle : str, default '-'\n        Line style connecting points.\n    **kwargs : dict\n        Additional arguments passed to plt.plot.\n\n    Returns\n    -------\n    matplotlib.figure.Figure\n\n    Examples\n    --------\n    &gt;&gt;&gt; fig = ds.radport.plot_light_curve(l=0.0, m=0.0, freq_mhz=50.0)\n    \"\"\"\n    lc = self.light_curve(\n        l=l, m=m, freq_idx=freq_idx, freq_mhz=freq_mhz, var=var, pol=pol\n    )\n\n    fig, ax = plt.subplots(figsize=figsize)\n\n    time_vals = lc.coords[\"time\"].values\n    ax.plot(time_vals, lc.values, marker=marker, linestyle=linestyle, **kwargs)\n\n    ax.set_xlabel(\"Time (MJD)\")\n    ax.set_ylabel(f\"{var} Intensity (Jy/beam)\")\n\n    freq_mhz_val = lc.attrs[\"freq_mhz\"]\n    l_val = lc.attrs[\"l\"]\n    m_val = lc.attrs[\"m\"]\n    ax.set_title(\n        f\"{var} Light Curve at (l={l_val:.3f}, m={m_val:.3f}), \"\n        f\"f={freq_mhz_val:.2f} MHz, pol={pol}\"\n    )\n\n    ax.grid(True, alpha=0.3)\n    fig.tight_layout()\n\n    return fig\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.spectrum","title":"<code>spectrum(l, m, time_idx=None, time_mjd=None, var='SKY', pol=0)</code>","text":"<p>Extract a frequency spectrum at a specific spatial location and time.</p> <p>Returns intensity as a function of frequency at the pixel nearest to the specified (l, m) coordinates and time.</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>float</code> <p>Direction cosine l coordinate.</p> required <code>m</code> <code>float</code> <p>Direction cosine m coordinate.</p> required <code>time_idx</code> <code>int</code> <p>Time index. Default is 0. Ignored if <code>time_mjd</code> is provided.</p> <code>None</code> <code>time_mjd</code> <code>float</code> <p>Time in MJD (overrides time_idx).</p> <code>None</code> <code>var</code> <code>('SKY', 'BEAM')</code> <p>Data variable to extract.</p> <code>'SKY'</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>1D array with dimension 'frequency' containing the spectrum.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; spec = ds.radport.spectrum(l=0.0, m=0.0, time_idx=0)\n&gt;&gt;&gt; spec.plot()  # Plot intensity vs frequency\n</code></pre> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def spectrum(\n    self,\n    l: float,\n    m: float,\n    time_idx: int | None = None,\n    time_mjd: float | None = None,\n    var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n    pol: int = 0,\n) -&gt; xr.DataArray:\n    \"\"\"Extract a frequency spectrum at a specific spatial location and time.\n\n    Returns intensity as a function of frequency at the pixel nearest to\n    the specified (l, m) coordinates and time.\n\n    Parameters\n    ----------\n    l : float\n        Direction cosine l coordinate.\n    m : float\n        Direction cosine m coordinate.\n    time_idx : int, optional\n        Time index. Default is 0. Ignored if `time_mjd` is provided.\n    time_mjd : float, optional\n        Time in MJD (overrides time_idx).\n    var : {'SKY', 'BEAM'}, default 'SKY'\n        Data variable to extract.\n    pol : int, default 0\n        Polarization index.\n\n    Returns\n    -------\n    xr.DataArray\n        1D array with dimension 'frequency' containing the spectrum.\n\n    Examples\n    --------\n    &gt;&gt;&gt; spec = ds.radport.spectrum(l=0.0, m=0.0, time_idx=0)\n    &gt;&gt;&gt; spec.plot()  # Plot intensity vs frequency\n    \"\"\"\n    if var not in self._obj.data_vars:\n        available = sorted(self._obj.data_vars)\n        raise ValueError(f\"Variable '{var}' not found. Available: {available}\")\n\n    # Resolve time index\n    if time_mjd is not None:\n        ti = self.nearest_time_idx(time_mjd)\n    elif time_idx is not None:\n        ti = time_idx\n    else:\n        ti = 0\n\n    # Find nearest pixel\n    l_idx, m_idx = self.nearest_lm_idx(l, m)\n\n    # Extract spectrum\n    spec = self._obj[var].isel(\n        time=ti,\n        polarization=pol,\n        l=l_idx,\n        m=m_idx,\n    )\n\n    # Add metadata\n    time_val = float(self._obj.coords[\"time\"].values[ti])\n    l_val = float(self._obj.coords[\"l\"].values[l_idx])\n    m_val = float(self._obj.coords[\"m\"].values[m_idx])\n\n    spec.attrs[\"variable\"] = var\n    spec.attrs[\"time_idx\"] = ti\n    spec.attrs[\"time_mjd\"] = time_val\n    spec.attrs[\"pol\"] = pol\n    spec.attrs[\"l\"] = l_val\n    spec.attrs[\"m\"] = m_val\n    spec.attrs[\"l_idx\"] = l_idx\n    spec.attrs[\"m_idx\"] = m_idx\n\n    return spec\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.plot_spectrum","title":"<code>plot_spectrum(l, m, time_idx=None, time_mjd=None, var='SKY', pol=0, figsize=(10, 4), marker='o', linestyle='-', freq_unit='MHz', **kwargs)</code>","text":"<p>Plot a frequency spectrum at a specific spatial location and time.</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>float</code> <p>Direction cosine l coordinate.</p> required <code>m</code> <code>float</code> <p>Direction cosine m coordinate.</p> required <code>time_idx</code> <code>int</code> <p>Time index. Default is 0. Ignored if <code>time_mjd</code> is provided.</p> <code>None</code> <code>time_mjd</code> <code>float</code> <p>Time in MJD (overrides time_idx).</p> <code>None</code> <code>var</code> <code>('SKY', 'BEAM')</code> <p>Data variable to plot.</p> <code>'SKY'</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>figsize</code> <code>tuple</code> <p>Figure size in inches.</p> <code>(10, 4)</code> <code>marker</code> <code>str</code> <p>Marker style for data points.</p> <code>'o'</code> <code>linestyle</code> <code>str</code> <p>Line style connecting points.</p> <code>'-'</code> <code>freq_unit</code> <code>('Hz', 'MHz')</code> <p>Unit for frequency axis.</p> <code>'Hz'</code> <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to plt.plot.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fig = ds.radport.plot_spectrum(l=0.0, m=0.0, time_idx=0)\n</code></pre> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def plot_spectrum(\n    self,\n    l: float,\n    m: float,\n    time_idx: int | None = None,\n    time_mjd: float | None = None,\n    var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n    pol: int = 0,\n    figsize: tuple[float, float] = (10, 4),\n    marker: str = \"o\",\n    linestyle: str = \"-\",\n    freq_unit: Literal[\"Hz\", \"MHz\"] = \"MHz\",\n    **kwargs: Any,\n) -&gt; Figure:\n    \"\"\"Plot a frequency spectrum at a specific spatial location and time.\n\n    Parameters\n    ----------\n    l : float\n        Direction cosine l coordinate.\n    m : float\n        Direction cosine m coordinate.\n    time_idx : int, optional\n        Time index. Default is 0. Ignored if `time_mjd` is provided.\n    time_mjd : float, optional\n        Time in MJD (overrides time_idx).\n    var : {'SKY', 'BEAM'}, default 'SKY'\n        Data variable to plot.\n    pol : int, default 0\n        Polarization index.\n    figsize : tuple, default (10, 4)\n        Figure size in inches.\n    marker : str, default 'o'\n        Marker style for data points.\n    linestyle : str, default '-'\n        Line style connecting points.\n    freq_unit : {'Hz', 'MHz'}, default 'MHz'\n        Unit for frequency axis.\n    **kwargs : dict\n        Additional arguments passed to plt.plot.\n\n    Returns\n    -------\n    matplotlib.figure.Figure\n\n    Examples\n    --------\n    &gt;&gt;&gt; fig = ds.radport.plot_spectrum(l=0.0, m=0.0, time_idx=0)\n    \"\"\"\n    spec = self.spectrum(\n        l=l, m=m, time_idx=time_idx, time_mjd=time_mjd, var=var, pol=pol\n    )\n\n    fig, ax = plt.subplots(figsize=figsize)\n\n    freq_vals = spec.coords[\"frequency\"].values\n    if freq_unit == \"MHz\":\n        freq_vals = freq_vals / 1e6\n        xlabel = \"Frequency (MHz)\"\n    else:\n        xlabel = \"Frequency (Hz)\"\n\n    ax.plot(freq_vals, spec.values, marker=marker, linestyle=linestyle, **kwargs)\n\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(f\"{var} Intensity (Jy/beam)\")\n\n    time_mjd_val = spec.attrs[\"time_mjd\"]\n    l_val = spec.attrs[\"l\"]\n    m_val = spec.attrs[\"m\"]\n    ax.set_title(\n        f\"{var} Spectrum at (l={l_val:.3f}, m={m_val:.3f}), \"\n        f\"t={time_mjd_val:.6f} MJD, pol={pol}\"\n    )\n\n    ax.grid(True, alpha=0.3)\n    fig.tight_layout()\n\n    return fig\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.time_average","title":"<code>time_average(var='SKY', pol=0, time_indices=None)</code>","text":"<p>Compute the time-averaged image.</p> <p>Averages the data across the time dimension, returning a 3D array with dimensions (frequency, l, m).</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>('SKY', 'BEAM')</code> <p>Data variable to average.</p> <code>'SKY'</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>time_indices</code> <code>list of int</code> <p>Specific time indices to include in the average. If None, averages over all times.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>3D array with dimensions (frequency, l, m).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; avg = ds.radport.time_average()\n&gt;&gt;&gt; avg.isel(frequency=0).plot()  # Plot mean image at first frequency\n</code></pre> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def time_average(\n    self,\n    var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n    pol: int = 0,\n    time_indices: list[int] | None = None,\n) -&gt; xr.DataArray:\n    \"\"\"Compute the time-averaged image.\n\n    Averages the data across the time dimension, returning a 3D array\n    with dimensions (frequency, l, m).\n\n    Parameters\n    ----------\n    var : {'SKY', 'BEAM'}, default 'SKY'\n        Data variable to average.\n    pol : int, default 0\n        Polarization index.\n    time_indices : list of int, optional\n        Specific time indices to include in the average.\n        If None, averages over all times.\n\n    Returns\n    -------\n    xr.DataArray\n        3D array with dimensions (frequency, l, m).\n\n    Examples\n    --------\n    &gt;&gt;&gt; avg = ds.radport.time_average()\n    &gt;&gt;&gt; avg.isel(frequency=0).plot()  # Plot mean image at first frequency\n    \"\"\"\n    if var not in self._obj.data_vars:\n        available = sorted(self._obj.data_vars)\n        raise ValueError(f\"Variable '{var}' not found. Available: {available}\")\n\n    da = self._obj[var].isel(polarization=pol)\n\n    if time_indices is not None:\n        da = da.isel(time=time_indices)\n\n    avg = da.mean(dim=\"time\")\n\n    avg.attrs[\"variable\"] = var\n    avg.attrs[\"pol\"] = pol\n    avg.attrs[\"operation\"] = \"time_average\"\n    if time_indices is not None:\n        avg.attrs[\"time_indices\"] = time_indices\n    else:\n        avg.attrs[\"n_times\"] = self._obj.sizes[\"time\"]\n\n    return avg\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.frequency_average","title":"<code>frequency_average(var='SKY', pol=0, freq_indices=None, freq_min_mhz=None, freq_max_mhz=None)</code>","text":"<p>Compute the frequency-averaged image.</p> <p>Averages the data across the frequency dimension, returning a 3D array with dimensions (time, l, m).</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>('SKY', 'BEAM')</code> <p>Data variable to average.</p> <code>'SKY'</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>freq_indices</code> <code>list of int</code> <p>Specific frequency indices to include in the average. If None (and freq_min/max not set), averages over all frequencies.</p> <code>None</code> <code>freq_min_mhz</code> <code>float</code> <p>Minimum frequency in MHz for averaging band.</p> <code>None</code> <code>freq_max_mhz</code> <code>float</code> <p>Maximum frequency in MHz for averaging band.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>3D array with dimensions (time, l, m).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; avg = ds.radport.frequency_average()\n&gt;&gt;&gt; avg.isel(time=0).plot()  # Plot mean image at first time\n</code></pre> <pre><code>&gt;&gt;&gt; # Average only 45-55 MHz band\n&gt;&gt;&gt; band_avg = ds.radport.frequency_average(freq_min_mhz=45.0, freq_max_mhz=55.0)\n</code></pre> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def frequency_average(\n    self,\n    var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n    pol: int = 0,\n    freq_indices: list[int] | None = None,\n    freq_min_mhz: float | None = None,\n    freq_max_mhz: float | None = None,\n) -&gt; xr.DataArray:\n    \"\"\"Compute the frequency-averaged image.\n\n    Averages the data across the frequency dimension, returning a 3D array\n    with dimensions (time, l, m).\n\n    Parameters\n    ----------\n    var : {'SKY', 'BEAM'}, default 'SKY'\n        Data variable to average.\n    pol : int, default 0\n        Polarization index.\n    freq_indices : list of int, optional\n        Specific frequency indices to include in the average.\n        If None (and freq_min/max not set), averages over all frequencies.\n    freq_min_mhz : float, optional\n        Minimum frequency in MHz for averaging band.\n    freq_max_mhz : float, optional\n        Maximum frequency in MHz for averaging band.\n\n    Returns\n    -------\n    xr.DataArray\n        3D array with dimensions (time, l, m).\n\n    Examples\n    --------\n    &gt;&gt;&gt; avg = ds.radport.frequency_average()\n    &gt;&gt;&gt; avg.isel(time=0).plot()  # Plot mean image at first time\n\n    &gt;&gt;&gt; # Average only 45-55 MHz band\n    &gt;&gt;&gt; band_avg = ds.radport.frequency_average(freq_min_mhz=45.0, freq_max_mhz=55.0)\n    \"\"\"\n    if var not in self._obj.data_vars:\n        available = sorted(self._obj.data_vars)\n        raise ValueError(f\"Variable '{var}' not found. Available: {available}\")\n\n    da = self._obj[var].isel(polarization=pol)\n\n    # Handle frequency selection\n    if freq_min_mhz is not None or freq_max_mhz is not None:\n        freq_hz = self._obj.coords[\"frequency\"].values\n        freq_mhz = freq_hz / 1e6\n\n        if freq_min_mhz is None:\n            freq_min_mhz = freq_mhz.min()\n        if freq_max_mhz is None:\n            freq_max_mhz = freq_mhz.max()\n\n        mask = (freq_mhz &gt;= freq_min_mhz) &amp; (freq_mhz &lt;= freq_max_mhz)\n        freq_indices = list(np.where(mask)[0])\n\n        if len(freq_indices) == 0:\n            raise ValueError(\n                f\"No frequencies in range [{freq_min_mhz}, {freq_max_mhz}] MHz. \"\n                f\"Available range: [{freq_mhz.min():.2f}, {freq_mhz.max():.2f}] MHz\"\n            )\n\n    if freq_indices is not None:\n        da = da.isel(frequency=freq_indices)\n\n    avg = da.mean(dim=\"frequency\")\n\n    avg.attrs[\"variable\"] = var\n    avg.attrs[\"pol\"] = pol\n    avg.attrs[\"operation\"] = \"frequency_average\"\n    if freq_indices is not None:\n        avg.attrs[\"freq_indices\"] = freq_indices\n    else:\n        avg.attrs[\"n_frequencies\"] = self._obj.sizes[\"frequency\"]\n    if freq_min_mhz is not None:\n        avg.attrs[\"freq_min_mhz\"] = freq_min_mhz\n    if freq_max_mhz is not None:\n        avg.attrs[\"freq_max_mhz\"] = freq_max_mhz\n\n    return avg\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.plot_time_average","title":"<code>plot_time_average(freq_idx=None, freq_mhz=None, var='SKY', pol=0, time_indices=None, cmap='inferno', vmin=None, vmax=None, robust=True, mask_radius=None, figsize=(8, 6), add_colorbar=True, **kwargs)</code>","text":"<p>Plot the time-averaged image at a specific frequency.</p> <p>Parameters:</p> Name Type Description Default <code>freq_idx</code> <code>int</code> <p>Frequency index. Default is 0. Ignored if <code>freq_mhz</code> is provided.</p> <code>None</code> <code>freq_mhz</code> <code>float</code> <p>Frequency in MHz (overrides freq_idx).</p> <code>None</code> <code>var</code> <code>('SKY', 'BEAM')</code> <p>Data variable to plot.</p> <code>'SKY'</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>time_indices</code> <code>list of int</code> <p>Specific time indices to include in the average.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>Colormap.</p> <code>'inferno'</code> <code>vmin</code> <code>float</code> <p>Color scale limits.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>Color scale limits.</p> <code>None</code> <code>robust</code> <code>bool</code> <p>Use 2nd/98th percentile for scaling.</p> <code>True</code> <code>mask_radius</code> <code>int</code> <p>Circular mask radius in pixels.</p> <code>None</code> <code>figsize</code> <code>tuple</code> <p>Figure size in inches.</p> <code>(8, 6)</code> <code>add_colorbar</code> <code>bool</code> <p>Whether to add colorbar.</p> <code>True</code> <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to imshow.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fig = ds.radport.plot_time_average(freq_mhz=50.0)\n</code></pre> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def plot_time_average(\n    self,\n    freq_idx: int | None = None,\n    freq_mhz: float | None = None,\n    var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n    pol: int = 0,\n    time_indices: list[int] | None = None,\n    cmap: str = \"inferno\",\n    vmin: float | None = None,\n    vmax: float | None = None,\n    robust: bool = True,\n    mask_radius: int | None = None,\n    figsize: tuple[float, float] = (8, 6),\n    add_colorbar: bool = True,\n    **kwargs: Any,\n) -&gt; Figure:\n    \"\"\"Plot the time-averaged image at a specific frequency.\n\n    Parameters\n    ----------\n    freq_idx : int, optional\n        Frequency index. Default is 0. Ignored if `freq_mhz` is provided.\n    freq_mhz : float, optional\n        Frequency in MHz (overrides freq_idx).\n    var : {'SKY', 'BEAM'}, default 'SKY'\n        Data variable to plot.\n    pol : int, default 0\n        Polarization index.\n    time_indices : list of int, optional\n        Specific time indices to include in the average.\n    cmap : str, default 'inferno'\n        Colormap.\n    vmin, vmax : float, optional\n        Color scale limits.\n    robust : bool, default True\n        Use 2nd/98th percentile for scaling.\n    mask_radius : int, optional\n        Circular mask radius in pixels.\n    figsize : tuple, default (8, 6)\n        Figure size in inches.\n    add_colorbar : bool, default True\n        Whether to add colorbar.\n    **kwargs : dict\n        Additional arguments passed to imshow.\n\n    Returns\n    -------\n    matplotlib.figure.Figure\n\n    Examples\n    --------\n    &gt;&gt;&gt; fig = ds.radport.plot_time_average(freq_mhz=50.0)\n    \"\"\"\n    avg = self.time_average(var=var, pol=pol, time_indices=time_indices)\n\n    # Resolve frequency index\n    if freq_mhz is not None:\n        fi = self.nearest_freq_idx(freq_mhz)\n    elif freq_idx is not None:\n        fi = freq_idx\n    else:\n        fi = 0\n\n    # Select frequency slice\n    data = avg.isel(frequency=fi).values.copy()\n\n    # Apply mask if requested\n    if mask_radius is not None:\n        ny, nx = data.shape\n        cy, cx = ny // 2, nx // 2\n        yy, xx = np.ogrid[:ny, :nx]\n        dist = np.sqrt((yy - cy) ** 2 + (xx - cx) ** 2)\n        data[dist &gt; mask_radius] = np.nan\n\n    # Compute vmin/vmax if robust\n    if robust and vmin is None and vmax is None:\n        finite = data[np.isfinite(data)]\n        if finite.size &gt; 0:\n            vmin = float(np.percentile(finite, 2))\n            vmax = float(np.percentile(finite, 98))\n\n    # Create plot\n    fig, ax = plt.subplots(figsize=figsize)\n\n    l_vals = avg.coords[\"l\"].values\n    m_vals = avg.coords[\"m\"].values\n    extent = [\n        float(l_vals.min()), float(l_vals.max()),\n        float(m_vals.min()), float(m_vals.max()),\n    ]\n\n    im = ax.imshow(\n        data,\n        origin=\"lower\",\n        cmap=cmap,\n        vmin=vmin,\n        vmax=vmax,\n        extent=extent,\n        aspect=\"equal\",\n        **kwargs,\n    )\n\n    if add_colorbar:\n        cbar = fig.colorbar(im, ax=ax)\n        cbar.set_label(\"Jy/beam\")\n\n    freq_hz = float(self._obj.coords[\"frequency\"].values[fi])\n    n_times = len(time_indices) if time_indices else self._obj.sizes[\"time\"]\n    ax.set_xlabel(\"l (direction cosine)\")\n    ax.set_ylabel(\"m (direction cosine)\")\n    ax.set_title(\n        f\"{var} Time Average ({n_times} frames) at f={freq_hz/1e6:.2f} MHz, pol={pol}\"\n    )\n\n    fig.tight_layout()\n    return fig\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.plot_frequency_average","title":"<code>plot_frequency_average(time_idx=None, time_mjd=None, var='SKY', pol=0, freq_indices=None, freq_min_mhz=None, freq_max_mhz=None, cmap='inferno', vmin=None, vmax=None, robust=True, mask_radius=None, figsize=(8, 6), add_colorbar=True, **kwargs)</code>","text":"<p>Plot the frequency-averaged image at a specific time.</p> <p>Parameters:</p> Name Type Description Default <code>time_idx</code> <code>int</code> <p>Time index. Default is 0. Ignored if <code>time_mjd</code> is provided.</p> <code>None</code> <code>time_mjd</code> <code>float</code> <p>Time in MJD (overrides time_idx).</p> <code>None</code> <code>var</code> <code>('SKY', 'BEAM')</code> <p>Data variable to plot.</p> <code>'SKY'</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>freq_indices</code> <code>list of int</code> <p>Specific frequency indices to include in the average.</p> <code>None</code> <code>freq_min_mhz</code> <code>float</code> <p>Minimum frequency in MHz for averaging band.</p> <code>None</code> <code>freq_max_mhz</code> <code>float</code> <p>Maximum frequency in MHz for averaging band.</p> <code>None</code> <code>cmap</code> <code>str</code> <p>Colormap.</p> <code>'inferno'</code> <code>vmin</code> <code>float</code> <p>Color scale limits.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>Color scale limits.</p> <code>None</code> <code>robust</code> <code>bool</code> <p>Use 2nd/98th percentile for scaling.</p> <code>True</code> <code>mask_radius</code> <code>int</code> <p>Circular mask radius in pixels.</p> <code>None</code> <code>figsize</code> <code>tuple</code> <p>Figure size in inches.</p> <code>(8, 6)</code> <code>add_colorbar</code> <code>bool</code> <p>Whether to add colorbar.</p> <code>True</code> <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to imshow.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fig = ds.radport.plot_frequency_average(time_idx=0)\n</code></pre> <pre><code>&gt;&gt;&gt; # Average 45-55 MHz band\n&gt;&gt;&gt; fig = ds.radport.plot_frequency_average(\n...     time_idx=0, freq_min_mhz=45.0, freq_max_mhz=55.0\n... )\n</code></pre> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def plot_frequency_average(\n    self,\n    time_idx: int | None = None,\n    time_mjd: float | None = None,\n    var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n    pol: int = 0,\n    freq_indices: list[int] | None = None,\n    freq_min_mhz: float | None = None,\n    freq_max_mhz: float | None = None,\n    cmap: str = \"inferno\",\n    vmin: float | None = None,\n    vmax: float | None = None,\n    robust: bool = True,\n    mask_radius: int | None = None,\n    figsize: tuple[float, float] = (8, 6),\n    add_colorbar: bool = True,\n    **kwargs: Any,\n) -&gt; Figure:\n    \"\"\"Plot the frequency-averaged image at a specific time.\n\n    Parameters\n    ----------\n    time_idx : int, optional\n        Time index. Default is 0. Ignored if `time_mjd` is provided.\n    time_mjd : float, optional\n        Time in MJD (overrides time_idx).\n    var : {'SKY', 'BEAM'}, default 'SKY'\n        Data variable to plot.\n    pol : int, default 0\n        Polarization index.\n    freq_indices : list of int, optional\n        Specific frequency indices to include in the average.\n    freq_min_mhz : float, optional\n        Minimum frequency in MHz for averaging band.\n    freq_max_mhz : float, optional\n        Maximum frequency in MHz for averaging band.\n    cmap : str, default 'inferno'\n        Colormap.\n    vmin, vmax : float, optional\n        Color scale limits.\n    robust : bool, default True\n        Use 2nd/98th percentile for scaling.\n    mask_radius : int, optional\n        Circular mask radius in pixels.\n    figsize : tuple, default (8, 6)\n        Figure size in inches.\n    add_colorbar : bool, default True\n        Whether to add colorbar.\n    **kwargs : dict\n        Additional arguments passed to imshow.\n\n    Returns\n    -------\n    matplotlib.figure.Figure\n\n    Examples\n    --------\n    &gt;&gt;&gt; fig = ds.radport.plot_frequency_average(time_idx=0)\n\n    &gt;&gt;&gt; # Average 45-55 MHz band\n    &gt;&gt;&gt; fig = ds.radport.plot_frequency_average(\n    ...     time_idx=0, freq_min_mhz=45.0, freq_max_mhz=55.0\n    ... )\n    \"\"\"\n    avg = self.frequency_average(\n        var=var,\n        pol=pol,\n        freq_indices=freq_indices,\n        freq_min_mhz=freq_min_mhz,\n        freq_max_mhz=freq_max_mhz,\n    )\n\n    # Resolve time index\n    if time_mjd is not None:\n        ti = self.nearest_time_idx(time_mjd)\n    elif time_idx is not None:\n        ti = time_idx\n    else:\n        ti = 0\n\n    # Select time slice\n    data = avg.isel(time=ti).values.copy()\n\n    # Apply mask if requested\n    if mask_radius is not None:\n        ny, nx = data.shape\n        cy, cx = ny // 2, nx // 2\n        yy, xx = np.ogrid[:ny, :nx]\n        dist = np.sqrt((yy - cy) ** 2 + (xx - cx) ** 2)\n        data[dist &gt; mask_radius] = np.nan\n\n    # Compute vmin/vmax if robust\n    if robust and vmin is None and vmax is None:\n        finite = data[np.isfinite(data)]\n        if finite.size &gt; 0:\n            vmin = float(np.percentile(finite, 2))\n            vmax = float(np.percentile(finite, 98))\n\n    # Create plot\n    fig, ax = plt.subplots(figsize=figsize)\n\n    l_vals = avg.coords[\"l\"].values\n    m_vals = avg.coords[\"m\"].values\n    extent = [\n        float(l_vals.min()), float(l_vals.max()),\n        float(m_vals.min()), float(m_vals.max()),\n    ]\n\n    im = ax.imshow(\n        data,\n        origin=\"lower\",\n        cmap=cmap,\n        vmin=vmin,\n        vmax=vmax,\n        extent=extent,\n        aspect=\"equal\",\n        **kwargs,\n    )\n\n    if add_colorbar:\n        cbar = fig.colorbar(im, ax=ax)\n        cbar.set_label(\"Jy/beam\")\n\n    time_val = float(self._obj.coords[\"time\"].values[ti])\n\n    # Build title with frequency info\n    if freq_min_mhz is not None and freq_max_mhz is not None:\n        freq_info = f\"{freq_min_mhz:.1f}-{freq_max_mhz:.1f} MHz\"\n    elif freq_indices is not None:\n        freq_info = f\"{len(freq_indices)} channels\"\n    else:\n        freq_info = f\"{self._obj.sizes['frequency']} channels\"\n\n    ax.set_xlabel(\"l (direction cosine)\")\n    ax.set_ylabel(\"m (direction cosine)\")\n    ax.set_title(\n        f\"{var} Frequency Average ({freq_info}) at t={time_val:.6f} MJD, pol={pol}\"\n    )\n\n    fig.tight_layout()\n    return fig\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.pixel_to_coords","title":"<code>pixel_to_coords(l_idx, m_idx)</code>","text":"<p>Convert pixel indices to celestial coordinates (RA, Dec).</p> <p>Parameters:</p> Name Type Description Default <code>l_idx</code> <code>int</code> <p>Index along the l dimension.</p> required <code>m_idx</code> <code>int</code> <p>Index along the m dimension.</p> required <p>Returns:</p> Type Description <code>tuple of float</code> <p>(ra, dec) in degrees. RA is in range [0, 360).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If WCS is not available or indices are out of bounds.</p> Example <p>ra, dec = ds.radport.pixel_to_coords(100, 100) print(f\"RA={ra:.2f}\u00b0, Dec={dec:.2f}\u00b0\")</p> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def pixel_to_coords(\n    self,\n    l_idx: int,\n    m_idx: int,\n) -&gt; tuple[float, float]:\n    \"\"\"Convert pixel indices to celestial coordinates (RA, Dec).\n\n    Parameters\n    ----------\n    l_idx : int\n        Index along the l dimension.\n    m_idx : int\n        Index along the m dimension.\n\n    Returns\n    -------\n    tuple of float\n        (ra, dec) in degrees. RA is in range [0, 360).\n\n    Raises\n    ------\n    ValueError\n        If WCS is not available or indices are out of bounds.\n\n    Example\n    -------\n    &gt;&gt;&gt; ra, dec = ds.radport.pixel_to_coords(100, 100)\n    &gt;&gt;&gt; print(f\"RA={ra:.2f}\u00b0, Dec={dec:.2f}\u00b0\")\n    \"\"\"\n    wcs = self._get_wcs()\n\n    # Validate indices\n    n_l = self._obj.sizes[\"l\"]\n    n_m = self._obj.sizes[\"m\"]\n    if not (0 &lt;= l_idx &lt; n_l):\n        raise ValueError(f\"l_idx={l_idx} out of bounds [0, {n_l})\")\n    if not (0 &lt;= m_idx &lt; n_m):\n        raise ValueError(f\"m_idx={m_idx} out of bounds [0, {n_m})\")\n\n    # WCS pixel_to_world expects (x, y) which is (l, m) in our convention\n    coord = wcs.pixel_to_world(l_idx, m_idx)\n    ra = float(coord.ra.wrap_at(\"360d\").deg)\n    dec = float(coord.dec.deg)\n\n    return ra, dec\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.coords_to_pixel","title":"<code>coords_to_pixel(ra, dec)</code>","text":"<p>Convert celestial coordinates (RA, Dec) to pixel indices.</p> <p>Parameters:</p> Name Type Description Default <code>ra</code> <code>float</code> <p>Right Ascension in degrees.</p> required <code>dec</code> <code>float</code> <p>Declination in degrees.</p> required <p>Returns:</p> Type Description <code>tuple of int</code> <p>(l_idx, m_idx) pixel indices (rounded to nearest integer).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If WCS is not available or coordinates are outside the image.</p> Example <p>l_idx, m_idx = ds.radport.coords_to_pixel(180.0, 45.0)</p> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def coords_to_pixel(\n    self,\n    ra: float,\n    dec: float,\n) -&gt; tuple[int, int]:\n    \"\"\"Convert celestial coordinates (RA, Dec) to pixel indices.\n\n    Parameters\n    ----------\n    ra : float\n        Right Ascension in degrees.\n    dec : float\n        Declination in degrees.\n\n    Returns\n    -------\n    tuple of int\n        (l_idx, m_idx) pixel indices (rounded to nearest integer).\n\n    Raises\n    ------\n    ValueError\n        If WCS is not available or coordinates are outside the image.\n\n    Example\n    -------\n    &gt;&gt;&gt; l_idx, m_idx = ds.radport.coords_to_pixel(180.0, 45.0)\n    \"\"\"\n    try:\n        from astropy.coordinates import SkyCoord\n        from astropy import units as u\n    except ImportError as e:\n        raise ImportError(\n            \"astropy is required for coordinate transformations.\"\n        ) from e\n\n    wcs = self._get_wcs()\n\n    coord = SkyCoord(ra=ra * u.deg, dec=dec * u.deg, frame=\"fk5\")\n    x, y = wcs.world_to_pixel(coord)\n\n    l_idx = int(round(float(x)))\n    m_idx = int(round(float(y)))\n\n    # Validate result is within bounds\n    n_l = self._obj.sizes[\"l\"]\n    n_m = self._obj.sizes[\"m\"]\n    if not (0 &lt;= l_idx &lt; n_l) or not (0 &lt;= m_idx &lt; n_m):\n        raise ValueError(\n            f\"Coordinates (RA={ra}, Dec={dec}) map to pixel ({l_idx}, {m_idx}) \"\n            f\"which is outside image bounds [0, {n_l}) x [0, {n_m})\"\n        )\n\n    return l_idx, m_idx\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.plot_wcs","title":"<code>plot_wcs(var='SKY', time_idx=0, freq_idx=0, freq_mhz=None, pol=0, cmap='inferno', vmin=None, vmax=None, robust=True, mask_radius=None, figsize=(10, 10), add_colorbar=True, grid_color='white', grid_alpha=0.6, grid_linestyle=':', label_color='white', facecolor='black', **kwargs)</code>","text":"<p>Plot with WCS projection and celestial coordinate grid.</p> <p>Creates a publication-quality plot with RA/Dec coordinate axes and optional grid overlay.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>('SKY', 'BEAM')</code> <p>Data variable to plot.</p> <code>'SKY'</code> <code>time_idx</code> <code>int</code> <p>Time index.</p> <code>0</code> <code>freq_idx</code> <code>int</code> <p>Frequency index. Ignored if <code>freq_mhz</code> is provided.</p> <code>0</code> <code>freq_mhz</code> <code>float</code> <p>Frequency in MHz (overrides freq_idx).</p> <code>None</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>cmap</code> <code>str</code> <p>Colormap name.</p> <code>'inferno'</code> <code>vmin</code> <code>float</code> <p>Color scale limits.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>Color scale limits.</p> <code>None</code> <code>robust</code> <code>bool</code> <p>Use 2nd/98th percentile for scaling.</p> <code>True</code> <code>mask_radius</code> <code>int</code> <p>Circular mask radius in pixels.</p> <code>None</code> <code>figsize</code> <code>tuple</code> <p>Figure size in inches.</p> <code>(10, 10)</code> <code>add_colorbar</code> <code>bool</code> <p>Whether to add colorbar.</p> <code>True</code> <code>grid_color</code> <code>str</code> <p>Color of coordinate grid lines.</p> <code>'white'</code> <code>grid_alpha</code> <code>float</code> <p>Transparency of grid lines.</p> <code>0.6</code> <code>grid_linestyle</code> <code>str</code> <p>Line style for grid.</p> <code>':'</code> <code>label_color</code> <code>str</code> <p>Color for axis labels and ticks.</p> <code>'white'</code> <code>facecolor</code> <code>str</code> <p>Background color for the plot.</p> <code>'black'</code> <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to imshow.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If WCS is not available in the dataset.</p> Example <p>fig = ds.radport.plot_wcs(freq_mhz=50.0, mask_radius=1800)</p> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def plot_wcs(\n    self,\n    var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n    time_idx: int = 0,\n    freq_idx: int = 0,\n    freq_mhz: float | None = None,\n    pol: int = 0,\n    cmap: str = \"inferno\",\n    vmin: float | None = None,\n    vmax: float | None = None,\n    robust: bool = True,\n    mask_radius: int | None = None,\n    figsize: tuple[float, float] = (10, 10),\n    add_colorbar: bool = True,\n    grid_color: str = \"white\",\n    grid_alpha: float = 0.6,\n    grid_linestyle: str = \":\",\n    label_color: str = \"white\",\n    facecolor: str = \"black\",\n    **kwargs: Any,\n) -&gt; Figure:\n    \"\"\"Plot with WCS projection and celestial coordinate grid.\n\n    Creates a publication-quality plot with RA/Dec coordinate axes\n    and optional grid overlay.\n\n    Parameters\n    ----------\n    var : {'SKY', 'BEAM'}, default 'SKY'\n        Data variable to plot.\n    time_idx : int, default 0\n        Time index.\n    freq_idx : int, default 0\n        Frequency index. Ignored if `freq_mhz` is provided.\n    freq_mhz : float, optional\n        Frequency in MHz (overrides freq_idx).\n    pol : int, default 0\n        Polarization index.\n    cmap : str, default 'inferno'\n        Colormap name.\n    vmin, vmax : float, optional\n        Color scale limits.\n    robust : bool, default True\n        Use 2nd/98th percentile for scaling.\n    mask_radius : int, optional\n        Circular mask radius in pixels.\n    figsize : tuple, default (10, 10)\n        Figure size in inches.\n    add_colorbar : bool, default True\n        Whether to add colorbar.\n    grid_color : str, default 'white'\n        Color of coordinate grid lines.\n    grid_alpha : float, default 0.6\n        Transparency of grid lines.\n    grid_linestyle : str, default ':'\n        Line style for grid.\n    label_color : str, default 'white'\n        Color for axis labels and ticks.\n    facecolor : str, default 'black'\n        Background color for the plot.\n    **kwargs : dict\n        Additional arguments passed to imshow.\n\n    Returns\n    -------\n    matplotlib.figure.Figure\n\n    Raises\n    ------\n    ValueError\n        If WCS is not available in the dataset.\n\n    Example\n    -------\n    &gt;&gt;&gt; fig = ds.radport.plot_wcs(freq_mhz=50.0, mask_radius=1800)\n    \"\"\"\n    try:\n        from astropy import units as u\n    except ImportError as e:\n        raise ImportError(\n            \"astropy is required for WCS plotting.\"\n        ) from e\n\n    if var not in self._obj.data_vars:\n        available = sorted(self._obj.data_vars)\n        raise ValueError(f\"Variable '{var}' not found. Available: {available}\")\n\n    wcs = self._get_wcs(var)\n\n    # Resolve frequency index\n    if freq_mhz is not None:\n        fi = self.nearest_freq_idx(freq_mhz)\n    else:\n        fi = freq_idx\n\n    # Extract data\n    da = self._obj[var].isel(\n        time=time_idx, frequency=fi, polarization=pol\n    )\n\n    # Ensure proper dimension order (m, l) for imshow\n    if set(da.dims) == {\"m\", \"l\"}:\n        da = da.transpose(\"m\", \"l\")\n\n    data = da.values.astype(float).copy()\n\n    # Apply mask if requested\n    if mask_radius is not None:\n        ny, nx = data.shape\n        cy, cx = ny // 2, nx // 2\n        yy, xx = np.ogrid[:ny, :nx]\n        dist = np.sqrt((yy - cy) ** 2 + (xx - cx) ** 2)\n        data[dist &gt; mask_radius] = np.nan\n\n    # Compute vmin/vmax if robust\n    if robust and vmin is None and vmax is None:\n        finite = data[np.isfinite(data)]\n        if finite.size &gt; 0:\n            vmin = float(np.percentile(finite, 2))\n            vmax = float(np.percentile(finite, 98))\n\n    # Set up colormap with bad values as black\n    cmap_obj = plt.get_cmap(cmap).copy()\n    cmap_obj.set_bad(facecolor, 1.0)\n\n    # Create figure with WCS projection\n    fig = plt.figure(figsize=figsize, facecolor=facecolor)\n    ax = fig.add_subplot(111, projection=wcs, facecolor=facecolor)\n\n    # Plot image\n    im = ax.imshow(\n        data,\n        origin=\"lower\",\n        cmap=cmap_obj,\n        vmin=vmin,\n        vmax=vmax,\n        **kwargs,\n    )\n\n    # Configure axes\n    ax.set_xlabel(\"RA\", color=label_color, fontsize=12)\n    ax.set_ylabel(\"Dec\", color=label_color, fontsize=12)\n\n    # Check if RA needs to be inverted (increases to left in sky)\n    try:\n        cdelt1 = float(wcs.wcs.cdelt[0])\n        if np.isfinite(cdelt1) and cdelt1 &gt; 0:\n            ax.invert_xaxis()\n    except (AttributeError, IndexError):\n        pass\n\n    # Add coordinate grid\n    overlay = ax.get_coords_overlay(\"fk5\")\n    overlay.grid(color=grid_color, ls=grid_linestyle, lw=1.0, alpha=grid_alpha)\n\n    # Configure tick labels\n    for coord in overlay:\n        coord.set_ticklabel_visible(True)\n        coord.set_ticklabel(color=label_color, size=10)\n        coord.tick_params(width=1, color=label_color)\n\n    # Add colorbar\n    if add_colorbar:\n        cbar = fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04)\n        cbar.set_label(\"Jy/beam\", color=label_color, fontsize=11)\n        cbar.ax.tick_params(color=label_color, labelcolor=label_color)\n        cbar.outline.set_edgecolor(label_color)\n\n    # Add title\n    freq_hz = float(self._obj.coords[\"frequency\"].values[fi])\n    time_val = self._obj.coords[\"time\"].values[time_idx]\n    try:\n        time_str = f\"{float(time_val):.6f}\"\n    except (TypeError, ValueError):\n        time_str = str(time_val)\n\n    ax.set_title(\n        f\"{var} at t={time_str} MJD, f={freq_hz/1e6:.2f} MHz, pol={pol}\",\n        color=label_color,\n        fontsize=12,\n        pad=10,\n    )\n\n    return fig\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.animate_time","title":"<code>animate_time(freq_idx=None, freq_mhz=None, var='SKY', pol=0, output_file=None, fps=5, cmap='inferno', vmin=None, vmax=None, robust=True, mask_radius=None, figsize=(8, 6), dpi=100, **kwargs)</code>","text":"<p>Create an animation showing time evolution at a fixed frequency.</p> <p>Parameters:</p> Name Type Description Default <code>freq_idx</code> <code>int</code> <p>Frequency index to animate. Defaults to 0 if neither freq_idx nor freq_mhz is provided.</p> <code>None</code> <code>freq_mhz</code> <code>float</code> <p>Select frequency by value in MHz. Overrides freq_idx if provided.</p> <code>None</code> <code>var</code> <code>str</code> <p>Data variable to animate (\"SKY\" or \"BEAM\").</p> <code>\"SKY\"</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>output_file</code> <code>str</code> <p>Path to save the animation. Supported formats: .mp4, .gif. If None, returns the animation object for display in notebooks.</p> <code>None</code> <code>fps</code> <code>int</code> <p>Frames per second for the animation.</p> <code>5</code> <code>cmap</code> <code>str</code> <p>Matplotlib colormap name.</p> <code>\"inferno\"</code> <code>vmin</code> <code>float</code> <p>Minimum value for color scaling. If None and robust=True, uses 2nd percentile across all frames.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>Maximum value for color scaling. If None and robust=True, uses 98th percentile across all frames.</p> <code>None</code> <code>robust</code> <code>bool</code> <p>Use percentile-based color scaling across all frames.</p> <code>True</code> <code>mask_radius</code> <code>int</code> <p>Apply circular mask with this radius in pixels.</p> <code>None</code> <code>figsize</code> <code>tuple</code> <p>Figure size in inches.</p> <code>(8, 6)</code> <code>dpi</code> <code>int</code> <p>Resolution for saved animation.</p> <code>100</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to FuncAnimation.</p> <code>{}</code> <p>Returns:</p> Type Description <code>FuncAnimation</code> <p>Animation object. Can be displayed in notebooks with HTML(anim.to_jshtml()) or saved to file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified variable doesn't exist in the dataset.</p> Example Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def animate_time(\n    self,\n    freq_idx: int | None = None,\n    freq_mhz: float | None = None,\n    var: str = \"SKY\",\n    pol: int = 0,\n    output_file: str | None = None,\n    fps: int = 5,\n    cmap: str = \"inferno\",\n    vmin: float | None = None,\n    vmax: float | None = None,\n    robust: bool = True,\n    mask_radius: int | None = None,\n    figsize: tuple[float, float] = (8, 6),\n    dpi: int = 100,\n    **kwargs: Any,\n) -&gt; Any:\n    \"\"\"Create an animation showing time evolution at a fixed frequency.\n\n    Parameters\n    ----------\n    freq_idx : int, optional\n        Frequency index to animate. Defaults to 0 if neither freq_idx\n        nor freq_mhz is provided.\n    freq_mhz : float, optional\n        Select frequency by value in MHz. Overrides freq_idx if provided.\n    var : str, default \"SKY\"\n        Data variable to animate (\"SKY\" or \"BEAM\").\n    pol : int, default 0\n        Polarization index.\n    output_file : str, optional\n        Path to save the animation. Supported formats: .mp4, .gif.\n        If None, returns the animation object for display in notebooks.\n    fps : int, default 5\n        Frames per second for the animation.\n    cmap : str, default \"inferno\"\n        Matplotlib colormap name.\n    vmin : float, optional\n        Minimum value for color scaling. If None and robust=True,\n        uses 2nd percentile across all frames.\n    vmax : float, optional\n        Maximum value for color scaling. If None and robust=True,\n        uses 98th percentile across all frames.\n    robust : bool, default True\n        Use percentile-based color scaling across all frames.\n    mask_radius : int, optional\n        Apply circular mask with this radius in pixels.\n    figsize : tuple, default (8, 6)\n        Figure size in inches.\n    dpi : int, default 100\n        Resolution for saved animation.\n    **kwargs\n        Additional arguments passed to FuncAnimation.\n\n    Returns\n    -------\n    matplotlib.animation.FuncAnimation\n        Animation object. Can be displayed in notebooks with HTML(anim.to_jshtml())\n        or saved to file.\n\n    Raises\n    ------\n    ValueError\n        If the specified variable doesn't exist in the dataset.\n\n    Example\n    -------\n    &gt;&gt;&gt; # Create animation and save to file\n    &gt;&gt;&gt; anim = ds.radport.animate_time(freq_mhz=50.0, output_file=\"time_evolution.mp4\")\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Display in Jupyter notebook\n    &gt;&gt;&gt; from IPython.display import HTML\n    &gt;&gt;&gt; anim = ds.radport.animate_time(freq_mhz=50.0)\n    &gt;&gt;&gt; HTML(anim.to_jshtml())\n    \"\"\"\n    from matplotlib.animation import FuncAnimation\n\n    # Validate variable\n    if var not in self._obj.data_vars:\n        raise ValueError(\n            f\"Variable '{var}' not found in dataset. \"\n            f\"Available variables: {list(self._obj.data_vars)}.\"\n        )\n\n    # Resolve frequency index\n    if freq_mhz is not None:\n        fi = self.nearest_freq_idx(freq_mhz)\n    elif freq_idx is not None:\n        fi = freq_idx\n    else:\n        fi = 0\n\n    # Get data for all time steps\n    data = self._obj[var].isel(frequency=fi, polarization=pol)\n    n_times = len(self._obj.coords[\"time\"])\n\n    # Compute global color scale from all frames\n    if vmin is None or vmax is None:\n        all_values = data.values.ravel()\n        finite_values = all_values[np.isfinite(all_values)]\n        if len(finite_values) &gt; 0:\n            if robust:\n                computed_vmin = np.percentile(finite_values, 2)\n                computed_vmax = np.percentile(finite_values, 98)\n            else:\n                computed_vmin = np.nanmin(finite_values)\n                computed_vmax = np.nanmax(finite_values)\n        else:\n            computed_vmin, computed_vmax = 0, 1\n\n        if vmin is None:\n            vmin = computed_vmin\n        if vmax is None:\n            vmax = computed_vmax\n\n    # Create mask if requested\n    mask = None\n    if mask_radius is not None:\n        nl = len(self._obj.coords[\"l\"])\n        nm = len(self._obj.coords[\"m\"])\n        center_l, center_m = nl // 2, nm // 2\n        l_idx, m_idx = np.ogrid[:nl, :nm]\n        dist = np.sqrt((l_idx - center_l) ** 2 + (m_idx - center_m) ** 2)\n        mask = dist &gt; mask_radius\n\n    # Create figure and initial plot\n    fig, ax = plt.subplots(figsize=figsize)\n\n    frame_data = data.isel(time=0).values.copy()\n    if mask is not None:\n        frame_data[mask] = np.nan\n\n    im = ax.imshow(\n        frame_data.T,\n        origin=\"lower\",\n        cmap=cmap,\n        vmin=vmin,\n        vmax=vmax,\n        aspect=\"equal\",\n    )\n\n    # Add colorbar\n    cbar = fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04)\n    cbar.set_label(\"Jy/beam\", fontsize=11)\n\n    # Labels\n    ax.set_xlabel(\"l index\", fontsize=11)\n    ax.set_ylabel(\"m index\", fontsize=11)\n\n    freq_hz = float(self._obj.coords[\"frequency\"].values[fi])\n\n    def update(frame: int) -&gt; tuple:\n        \"\"\"Update function for animation.\"\"\"\n        frame_data = data.isel(time=frame).values.copy()\n        if mask is not None:\n            frame_data[mask] = np.nan\n        im.set_array(frame_data.T)\n\n        time_val = self._obj.coords[\"time\"].values[frame]\n        try:\n            time_str = f\"{float(time_val):.6f}\"\n        except (TypeError, ValueError):\n            time_str = str(time_val)\n\n        ax.set_title(\n            f\"{var} at f={freq_hz/1e6:.2f} MHz, pol={pol}\\n\"\n            f\"Time: {time_str} MJD (frame {frame + 1}/{n_times})\",\n            fontsize=11,\n        )\n        return (im,)\n\n    # Create animation\n    anim = FuncAnimation(\n        fig,\n        update,\n        frames=n_times,\n        interval=1000 // fps,\n        blit=True,\n        **kwargs,\n    )\n\n    # Save if output file specified\n    if output_file is not None:\n        if output_file.endswith(\".gif\"):\n            anim.save(output_file, writer=\"pillow\", fps=fps, dpi=dpi)\n        else:\n            anim.save(output_file, writer=\"ffmpeg\", fps=fps, dpi=dpi)\n        plt.close(fig)\n\n    return anim\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.animate_time--create-animation-and-save-to-file","title":"Create animation and save to file","text":"<p>anim = ds.radport.animate_time(freq_mhz=50.0, output_file=\"time_evolution.mp4\")</p>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.animate_time--display-in-jupyter-notebook","title":"Display in Jupyter notebook","text":"<p>from IPython.display import HTML anim = ds.radport.animate_time(freq_mhz=50.0) HTML(anim.to_jshtml())</p>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.animate_frequency","title":"<code>animate_frequency(time_idx=None, time_mjd=None, var='SKY', pol=0, output_file=None, fps=5, cmap='inferno', vmin=None, vmax=None, robust=True, mask_radius=None, figsize=(8, 6), dpi=100, **kwargs)</code>","text":"<p>Create an animation showing frequency sweep at a fixed time.</p> <p>Parameters:</p> Name Type Description Default <code>time_idx</code> <code>int</code> <p>Time index to animate. Defaults to 0 if neither time_idx nor time_mjd is provided.</p> <code>None</code> <code>time_mjd</code> <code>float</code> <p>Select time by MJD value. Overrides time_idx if provided.</p> <code>None</code> <code>var</code> <code>str</code> <p>Data variable to animate (\"SKY\" or \"BEAM\").</p> <code>\"SKY\"</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>output_file</code> <code>str</code> <p>Path to save the animation. Supported formats: .mp4, .gif. If None, returns the animation object for display in notebooks.</p> <code>None</code> <code>fps</code> <code>int</code> <p>Frames per second for the animation.</p> <code>5</code> <code>cmap</code> <code>str</code> <p>Matplotlib colormap name.</p> <code>\"inferno\"</code> <code>vmin</code> <code>float</code> <p>Minimum value for color scaling. If None and robust=True, uses 2nd percentile across all frames.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>Maximum value for color scaling. If None and robust=True, uses 98th percentile across all frames.</p> <code>None</code> <code>robust</code> <code>bool</code> <p>Use percentile-based color scaling across all frames.</p> <code>True</code> <code>mask_radius</code> <code>int</code> <p>Apply circular mask with this radius in pixels.</p> <code>None</code> <code>figsize</code> <code>tuple</code> <p>Figure size in inches.</p> <code>(8, 6)</code> <code>dpi</code> <code>int</code> <p>Resolution for saved animation.</p> <code>100</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments passed to FuncAnimation.</p> <code>{}</code> <p>Returns:</p> Type Description <code>FuncAnimation</code> <p>Animation object. Can be displayed in notebooks with HTML(anim.to_jshtml()) or saved to file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified variable doesn't exist in the dataset.</p> Example Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def animate_frequency(\n    self,\n    time_idx: int | None = None,\n    time_mjd: float | None = None,\n    var: str = \"SKY\",\n    pol: int = 0,\n    output_file: str | None = None,\n    fps: int = 5,\n    cmap: str = \"inferno\",\n    vmin: float | None = None,\n    vmax: float | None = None,\n    robust: bool = True,\n    mask_radius: int | None = None,\n    figsize: tuple[float, float] = (8, 6),\n    dpi: int = 100,\n    **kwargs: Any,\n) -&gt; Any:\n    \"\"\"Create an animation showing frequency sweep at a fixed time.\n\n    Parameters\n    ----------\n    time_idx : int, optional\n        Time index to animate. Defaults to 0 if neither time_idx\n        nor time_mjd is provided.\n    time_mjd : float, optional\n        Select time by MJD value. Overrides time_idx if provided.\n    var : str, default \"SKY\"\n        Data variable to animate (\"SKY\" or \"BEAM\").\n    pol : int, default 0\n        Polarization index.\n    output_file : str, optional\n        Path to save the animation. Supported formats: .mp4, .gif.\n        If None, returns the animation object for display in notebooks.\n    fps : int, default 5\n        Frames per second for the animation.\n    cmap : str, default \"inferno\"\n        Matplotlib colormap name.\n    vmin : float, optional\n        Minimum value for color scaling. If None and robust=True,\n        uses 2nd percentile across all frames.\n    vmax : float, optional\n        Maximum value for color scaling. If None and robust=True,\n        uses 98th percentile across all frames.\n    robust : bool, default True\n        Use percentile-based color scaling across all frames.\n    mask_radius : int, optional\n        Apply circular mask with this radius in pixels.\n    figsize : tuple, default (8, 6)\n        Figure size in inches.\n    dpi : int, default 100\n        Resolution for saved animation.\n    **kwargs\n        Additional arguments passed to FuncAnimation.\n\n    Returns\n    -------\n    matplotlib.animation.FuncAnimation\n        Animation object. Can be displayed in notebooks with HTML(anim.to_jshtml())\n        or saved to file.\n\n    Raises\n    ------\n    ValueError\n        If the specified variable doesn't exist in the dataset.\n\n    Example\n    -------\n    &gt;&gt;&gt; # Create animation and save to file\n    &gt;&gt;&gt; anim = ds.radport.animate_frequency(time_idx=0, output_file=\"freq_sweep.gif\")\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Display in Jupyter notebook\n    &gt;&gt;&gt; from IPython.display import HTML\n    &gt;&gt;&gt; anim = ds.radport.animate_frequency(time_idx=0)\n    &gt;&gt;&gt; HTML(anim.to_jshtml())\n    \"\"\"\n    from matplotlib.animation import FuncAnimation\n\n    # Validate variable\n    if var not in self._obj.data_vars:\n        raise ValueError(\n            f\"Variable '{var}' not found in dataset. \"\n            f\"Available variables: {list(self._obj.data_vars)}.\"\n        )\n\n    # Resolve time index\n    if time_mjd is not None:\n        ti = self.nearest_time_idx(time_mjd)\n    elif time_idx is not None:\n        ti = time_idx\n    else:\n        ti = 0\n\n    # Get data for all frequencies\n    data = self._obj[var].isel(time=ti, polarization=pol)\n    n_freqs = len(self._obj.coords[\"frequency\"])\n    freqs_hz = self._obj.coords[\"frequency\"].values\n\n    # Compute global color scale from all frames\n    if vmin is None or vmax is None:\n        all_values = data.values.ravel()\n        finite_values = all_values[np.isfinite(all_values)]\n        if len(finite_values) &gt; 0:\n            if robust:\n                computed_vmin = np.percentile(finite_values, 2)\n                computed_vmax = np.percentile(finite_values, 98)\n            else:\n                computed_vmin = np.nanmin(finite_values)\n                computed_vmax = np.nanmax(finite_values)\n        else:\n            computed_vmin, computed_vmax = 0, 1\n\n        if vmin is None:\n            vmin = computed_vmin\n        if vmax is None:\n            vmax = computed_vmax\n\n    # Create mask if requested\n    mask = None\n    if mask_radius is not None:\n        nl = len(self._obj.coords[\"l\"])\n        nm = len(self._obj.coords[\"m\"])\n        center_l, center_m = nl // 2, nm // 2\n        l_idx, m_idx = np.ogrid[:nl, :nm]\n        dist = np.sqrt((l_idx - center_l) ** 2 + (m_idx - center_m) ** 2)\n        mask = dist &gt; mask_radius\n\n    # Create figure and initial plot\n    fig, ax = plt.subplots(figsize=figsize)\n\n    frame_data = data.isel(frequency=0).values.copy()\n    if mask is not None:\n        frame_data[mask] = np.nan\n\n    im = ax.imshow(\n        frame_data.T,\n        origin=\"lower\",\n        cmap=cmap,\n        vmin=vmin,\n        vmax=vmax,\n        aspect=\"equal\",\n    )\n\n    # Add colorbar\n    cbar = fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04)\n    cbar.set_label(\"Jy/beam\", fontsize=11)\n\n    # Labels\n    ax.set_xlabel(\"l index\", fontsize=11)\n    ax.set_ylabel(\"m index\", fontsize=11)\n\n    time_val = self._obj.coords[\"time\"].values[ti]\n    try:\n        time_str = f\"{float(time_val):.6f}\"\n    except (TypeError, ValueError):\n        time_str = str(time_val)\n\n    def update(frame: int) -&gt; tuple:\n        \"\"\"Update function for animation.\"\"\"\n        frame_data = data.isel(frequency=frame).values.copy()\n        if mask is not None:\n            frame_data[mask] = np.nan\n        im.set_array(frame_data.T)\n\n        freq_hz = float(freqs_hz[frame])\n        ax.set_title(\n            f\"{var} at t={time_str} MJD, pol={pol}\\n\"\n            f\"Frequency: {freq_hz/1e6:.2f} MHz (channel {frame + 1}/{n_freqs})\",\n            fontsize=11,\n        )\n        return (im,)\n\n    # Create animation\n    anim = FuncAnimation(\n        fig,\n        update,\n        frames=n_freqs,\n        interval=1000 // fps,\n        blit=True,\n        **kwargs,\n    )\n\n    # Save if output file specified\n    if output_file is not None:\n        if output_file.endswith(\".gif\"):\n            anim.save(output_file, writer=\"pillow\", fps=fps, dpi=dpi)\n        else:\n            anim.save(output_file, writer=\"ffmpeg\", fps=fps, dpi=dpi)\n        plt.close(fig)\n\n    return anim\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.animate_frequency--create-animation-and-save-to-file","title":"Create animation and save to file","text":"<p>anim = ds.radport.animate_frequency(time_idx=0, output_file=\"freq_sweep.gif\")</p>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.animate_frequency--display-in-jupyter-notebook","title":"Display in Jupyter notebook","text":"<p>from IPython.display import HTML anim = ds.radport.animate_frequency(time_idx=0) HTML(anim.to_jshtml())</p>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.export_frames","title":"<code>export_frames(output_dir, var='SKY', pol=0, time_indices=None, freq_indices=None, format='png', cmap='inferno', vmin=None, vmax=None, robust=True, mask_radius=None, figsize=(8, 6), dpi=150, filename_template='{var}_t{time_idx:04d}_f{freq_idx:04d}.{format}')</code>","text":"<p>Export all (time, freq) frames as individual image files.</p> <p>Parameters:</p> Name Type Description Default <code>output_dir</code> <code>str</code> <p>Directory to save the image files. Will be created if it doesn't exist.</p> required <code>var</code> <code>str</code> <p>Data variable to export (\"SKY\" or \"BEAM\").</p> <code>\"SKY\"</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>time_indices</code> <code>list of int</code> <p>Time indices to export. If None, exports all times.</p> <code>None</code> <code>freq_indices</code> <code>list of int</code> <p>Frequency indices to export. If None, exports all frequencies.</p> <code>None</code> <code>format</code> <code>str</code> <p>Image format (e.g., \"png\", \"jpg\", \"pdf\").</p> <code>\"png\"</code> <code>cmap</code> <code>str</code> <p>Matplotlib colormap name.</p> <code>\"inferno\"</code> <code>vmin</code> <code>float</code> <p>Minimum value for color scaling. If None and robust=True, uses 2nd percentile across all exported frames.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>Maximum value for color scaling. If None and robust=True, uses 98th percentile across all exported frames.</p> <code>None</code> <code>robust</code> <code>bool</code> <p>Use percentile-based color scaling across all exported frames.</p> <code>True</code> <code>mask_radius</code> <code>int</code> <p>Apply circular mask with this radius in pixels.</p> <code>None</code> <code>figsize</code> <code>tuple</code> <p>Figure size in inches.</p> <code>(8, 6)</code> <code>dpi</code> <code>int</code> <p>Resolution for saved images.</p> <code>150</code> <code>filename_template</code> <code>str</code> <p>Template for filenames. Available placeholders: {var}, {time_idx}, {freq_idx}, {time_mjd}, {freq_mhz}, {format}.</p> <code>\"{var}_t{time_idx:04d}_f{freq_idx:04d}.{format}\"</code> <p>Returns:</p> Type Description <code>list of str</code> <p>List of paths to the saved image files.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified variable doesn't exist in the dataset.</p> Example Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def export_frames(\n    self,\n    output_dir: str,\n    var: str = \"SKY\",\n    pol: int = 0,\n    time_indices: list[int] | None = None,\n    freq_indices: list[int] | None = None,\n    format: str = \"png\",\n    cmap: str = \"inferno\",\n    vmin: float | None = None,\n    vmax: float | None = None,\n    robust: bool = True,\n    mask_radius: int | None = None,\n    figsize: tuple[float, float] = (8, 6),\n    dpi: int = 150,\n    filename_template: str = \"{var}_t{time_idx:04d}_f{freq_idx:04d}.{format}\",\n) -&gt; list[str]:\n    \"\"\"Export all (time, freq) frames as individual image files.\n\n    Parameters\n    ----------\n    output_dir : str\n        Directory to save the image files. Will be created if it doesn't exist.\n    var : str, default \"SKY\"\n        Data variable to export (\"SKY\" or \"BEAM\").\n    pol : int, default 0\n        Polarization index.\n    time_indices : list of int, optional\n        Time indices to export. If None, exports all times.\n    freq_indices : list of int, optional\n        Frequency indices to export. If None, exports all frequencies.\n    format : str, default \"png\"\n        Image format (e.g., \"png\", \"jpg\", \"pdf\").\n    cmap : str, default \"inferno\"\n        Matplotlib colormap name.\n    vmin : float, optional\n        Minimum value for color scaling. If None and robust=True,\n        uses 2nd percentile across all exported frames.\n    vmax : float, optional\n        Maximum value for color scaling. If None and robust=True,\n        uses 98th percentile across all exported frames.\n    robust : bool, default True\n        Use percentile-based color scaling across all exported frames.\n    mask_radius : int, optional\n        Apply circular mask with this radius in pixels.\n    figsize : tuple, default (8, 6)\n        Figure size in inches.\n    dpi : int, default 150\n        Resolution for saved images.\n    filename_template : str, default \"{var}_t{time_idx:04d}_f{freq_idx:04d}.{format}\"\n        Template for filenames. Available placeholders: {var}, {time_idx},\n        {freq_idx}, {time_mjd}, {freq_mhz}, {format}.\n\n    Returns\n    -------\n    list of str\n        List of paths to the saved image files.\n\n    Raises\n    ------\n    ValueError\n        If the specified variable doesn't exist in the dataset.\n\n    Example\n    -------\n    &gt;&gt;&gt; # Export all frames\n    &gt;&gt;&gt; files = ds.radport.export_frames(\"./frames\")\n    &gt;&gt;&gt; print(f\"Exported {len(files)} frames\")\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Export specific time/frequency combinations\n    &gt;&gt;&gt; files = ds.radport.export_frames(\n    ...     \"./frames\",\n    ...     time_indices=[0, 1, 2],\n    ...     freq_indices=[0, 5, 10],\n    ... )\n    \"\"\"\n    import os\n\n    # Validate variable\n    if var not in self._obj.data_vars:\n        raise ValueError(\n            f\"Variable '{var}' not found in dataset. \"\n            f\"Available variables: {list(self._obj.data_vars)}.\"\n        )\n\n    # Create output directory\n    os.makedirs(output_dir, exist_ok=True)\n\n    # Get indices to export\n    if time_indices is None:\n        time_indices = list(range(len(self._obj.coords[\"time\"])))\n    if freq_indices is None:\n        freq_indices = list(range(len(self._obj.coords[\"frequency\"])))\n\n    # Get coordinate values for labels\n    time_values = self._obj.coords[\"time\"].values\n    freq_values = self._obj.coords[\"frequency\"].values\n\n    # Compute global color scale from all frames to export\n    if vmin is None or vmax is None:\n        all_values = []\n        for ti in time_indices:\n            for fi in freq_indices:\n                frame_data = self._obj[var].isel(\n                    time=ti, frequency=fi, polarization=pol\n                ).values\n                all_values.extend(frame_data.ravel())\n\n        all_values = np.array(all_values)\n        finite_values = all_values[np.isfinite(all_values)]\n        if len(finite_values) &gt; 0:\n            if robust:\n                computed_vmin = np.percentile(finite_values, 2)\n                computed_vmax = np.percentile(finite_values, 98)\n            else:\n                computed_vmin = np.nanmin(finite_values)\n                computed_vmax = np.nanmax(finite_values)\n        else:\n            computed_vmin, computed_vmax = 0, 1\n\n        if vmin is None:\n            vmin = computed_vmin\n        if vmax is None:\n            vmax = computed_vmax\n\n    # Create mask if requested\n    mask = None\n    if mask_radius is not None:\n        nl = len(self._obj.coords[\"l\"])\n        nm = len(self._obj.coords[\"m\"])\n        center_l, center_m = nl // 2, nm // 2\n        l_idx, m_idx = np.ogrid[:nl, :nm]\n        dist = np.sqrt((l_idx - center_l) ** 2 + (m_idx - center_m) ** 2)\n        mask = dist &gt; mask_radius\n\n    # Export frames\n    exported_files = []\n\n    for ti in time_indices:\n        for fi in freq_indices:\n            # Get frame data\n            frame_data = self._obj[var].isel(\n                time=ti, frequency=fi, polarization=pol\n            ).values.copy()\n\n            if mask is not None:\n                frame_data[mask] = np.nan\n\n            # Create figure\n            fig, ax = plt.subplots(figsize=figsize)\n\n            im = ax.imshow(\n                frame_data.T,\n                origin=\"lower\",\n                cmap=cmap,\n                vmin=vmin,\n                vmax=vmax,\n                aspect=\"equal\",\n            )\n\n            # Add colorbar\n            cbar = fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04)\n            cbar.set_label(\"Jy/beam\", fontsize=11)\n\n            # Labels\n            ax.set_xlabel(\"l index\", fontsize=11)\n            ax.set_ylabel(\"m index\", fontsize=11)\n\n            # Title\n            time_val = time_values[ti]\n            freq_hz = float(freq_values[fi])\n            try:\n                time_str = f\"{float(time_val):.6f}\"\n            except (TypeError, ValueError):\n                time_str = str(time_val)\n\n            ax.set_title(\n                f\"{var} at t={time_str} MJD, f={freq_hz/1e6:.2f} MHz, pol={pol}\",\n                fontsize=11,\n            )\n\n            # Generate filename\n            try:\n                time_mjd = float(time_val)\n            except (TypeError, ValueError):\n                time_mjd = 0.0\n\n            filename = filename_template.format(\n                var=var,\n                time_idx=ti,\n                freq_idx=fi,\n                time_mjd=time_mjd,\n                freq_mhz=freq_hz / 1e6,\n                format=format,\n            )\n            filepath = os.path.join(output_dir, filename)\n\n            # Save figure\n            fig.savefig(filepath, dpi=dpi, bbox_inches=\"tight\")\n            plt.close(fig)\n\n            exported_files.append(filepath)\n\n    return exported_files\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.export_frames--export-all-frames","title":"Export all frames","text":"<p>files = ds.radport.export_frames(\"./frames\") print(f\"Exported {len(files)} frames\")</p>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.export_frames--export-specific-timefrequency-combinations","title":"Export specific time/frequency combinations","text":"<p>files = ds.radport.export_frames( ...     \"./frames\", ...     time_indices=[0, 1, 2], ...     freq_indices=[0, 5, 10], ... )</p>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.rms_map","title":"<code>rms_map(time_idx=0, freq_idx=None, freq_mhz=None, var='SKY', pol=0, box_size=50)</code>","text":"<p>Compute local RMS noise estimate map using a sliding box.</p> <p>The RMS is computed using a uniform filter approach where each pixel's RMS is estimated from the surrounding box_size x box_size region.</p> <p>Parameters:</p> Name Type Description Default <code>time_idx</code> <code>int</code> <p>Time index for the frame.</p> <code>0</code> <code>freq_idx</code> <code>int</code> <p>Frequency index for the frame. Defaults to 0 if neither freq_idx nor freq_mhz is provided.</p> <code>None</code> <code>freq_mhz</code> <code>float</code> <p>Select frequency by value in MHz. Overrides freq_idx if provided.</p> <code>None</code> <code>var</code> <code>str</code> <p>Data variable to analyze (\"SKY\" or \"BEAM\").</p> <code>\"SKY\"</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>box_size</code> <code>int</code> <p>Size of the sliding box for local RMS computation.</p> <code>50</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>2D array of local RMS values with dimensions (l, m).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified variable doesn't exist in the dataset.</p> Example <p>rms = ds.radport.rms_map(freq_mhz=50.0, box_size=100) rms.plot()</p> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def rms_map(\n    self,\n    time_idx: int = 0,\n    freq_idx: int | None = None,\n    freq_mhz: float | None = None,\n    var: str = \"SKY\",\n    pol: int = 0,\n    box_size: int = 50,\n) -&gt; xr.DataArray:\n    \"\"\"Compute local RMS noise estimate map using a sliding box.\n\n    The RMS is computed using a uniform filter approach where each pixel's\n    RMS is estimated from the surrounding box_size x box_size region.\n\n    Parameters\n    ----------\n    time_idx : int, default 0\n        Time index for the frame.\n    freq_idx : int, optional\n        Frequency index for the frame. Defaults to 0 if neither freq_idx\n        nor freq_mhz is provided.\n    freq_mhz : float, optional\n        Select frequency by value in MHz. Overrides freq_idx if provided.\n    var : str, default \"SKY\"\n        Data variable to analyze (\"SKY\" or \"BEAM\").\n    pol : int, default 0\n        Polarization index.\n    box_size : int, default 50\n        Size of the sliding box for local RMS computation.\n\n    Returns\n    -------\n    xr.DataArray\n        2D array of local RMS values with dimensions (l, m).\n\n    Raises\n    ------\n    ValueError\n        If the specified variable doesn't exist in the dataset.\n\n    Example\n    -------\n    &gt;&gt;&gt; rms = ds.radport.rms_map(freq_mhz=50.0, box_size=100)\n    &gt;&gt;&gt; rms.plot()\n    \"\"\"\n    from scipy.ndimage import uniform_filter\n\n    # Validate variable\n    if var not in self._obj.data_vars:\n        raise ValueError(\n            f\"Variable '{var}' not found in dataset. \"\n            f\"Available variables: {list(self._obj.data_vars)}.\"\n        )\n\n    # Resolve frequency index\n    if freq_mhz is not None:\n        fi = self.nearest_freq_idx(freq_mhz)\n    elif freq_idx is not None:\n        fi = freq_idx\n    else:\n        fi = 0\n\n    # Get frame data\n    data = self._obj[var].isel(\n        time=time_idx, frequency=fi, polarization=pol\n    ).values.astype(float)\n\n    # Replace NaN with 0 for filtering (we'll handle NaN regions later)\n    nan_mask = ~np.isfinite(data)\n    data_filled = np.where(nan_mask, 0.0, data)\n\n    # Compute local mean and mean of squares\n    local_mean = uniform_filter(data_filled, size=box_size, mode=\"constant\")\n    local_mean_sq = uniform_filter(data_filled**2, size=box_size, mode=\"constant\")\n\n    # Count valid pixels in each box\n    valid_count = uniform_filter(\n        (~nan_mask).astype(float), size=box_size, mode=\"constant\"\n    )\n    valid_count = np.maximum(valid_count, 1e-10)  # Avoid division by zero\n\n    # Correct for the fact that we filled NaN with 0\n    local_mean = local_mean / valid_count * (box_size**2)\n    local_mean_sq = local_mean_sq / valid_count * (box_size**2)\n\n    # Compute variance: E[X^2] - E[X]^2\n    local_var = local_mean_sq - local_mean**2\n    local_var = np.maximum(local_var, 0.0)  # Ensure non-negative\n\n    # RMS is sqrt of variance\n    rms = np.sqrt(local_var)\n\n    # Restore NaN where original was NaN\n    rms[nan_mask] = np.nan\n\n    # Create DataArray with coordinates\n    return xr.DataArray(\n        rms,\n        dims=[\"l\", \"m\"],\n        coords={\n            \"l\": self._obj.coords[\"l\"],\n            \"m\": self._obj.coords[\"m\"],\n        },\n        name=\"rms\",\n        attrs={\n            \"long_name\": \"Local RMS noise estimate\",\n            \"units\": \"Jy/beam\",\n            \"box_size\": box_size,\n        },\n    )\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.snr_map","title":"<code>snr_map(time_idx=0, freq_idx=None, freq_mhz=None, var='SKY', pol=0, box_size=50)</code>","text":"<p>Compute signal-to-noise ratio map.</p> <p>The SNR is computed as the signal divided by the local RMS noise estimate from a sliding box.</p> <p>Parameters:</p> Name Type Description Default <code>time_idx</code> <code>int</code> <p>Time index for the frame.</p> <code>0</code> <code>freq_idx</code> <code>int</code> <p>Frequency index for the frame. Defaults to 0 if neither freq_idx nor freq_mhz is provided.</p> <code>None</code> <code>freq_mhz</code> <code>float</code> <p>Select frequency by value in MHz. Overrides freq_idx if provided.</p> <code>None</code> <code>var</code> <code>str</code> <p>Data variable to analyze (\"SKY\" or \"BEAM\").</p> <code>\"SKY\"</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>box_size</code> <code>int</code> <p>Size of the sliding box for local RMS computation.</p> <code>50</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>2D array of SNR values with dimensions (l, m).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified variable doesn't exist in the dataset.</p> Example <p>snr = ds.radport.snr_map(freq_mhz=50.0)</p> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def snr_map(\n    self,\n    time_idx: int = 0,\n    freq_idx: int | None = None,\n    freq_mhz: float | None = None,\n    var: str = \"SKY\",\n    pol: int = 0,\n    box_size: int = 50,\n) -&gt; xr.DataArray:\n    \"\"\"Compute signal-to-noise ratio map.\n\n    The SNR is computed as the signal divided by the local RMS noise\n    estimate from a sliding box.\n\n    Parameters\n    ----------\n    time_idx : int, default 0\n        Time index for the frame.\n    freq_idx : int, optional\n        Frequency index for the frame. Defaults to 0 if neither freq_idx\n        nor freq_mhz is provided.\n    freq_mhz : float, optional\n        Select frequency by value in MHz. Overrides freq_idx if provided.\n    var : str, default \"SKY\"\n        Data variable to analyze (\"SKY\" or \"BEAM\").\n    pol : int, default 0\n        Polarization index.\n    box_size : int, default 50\n        Size of the sliding box for local RMS computation.\n\n    Returns\n    -------\n    xr.DataArray\n        2D array of SNR values with dimensions (l, m).\n\n    Raises\n    ------\n    ValueError\n        If the specified variable doesn't exist in the dataset.\n\n    Example\n    -------\n    &gt;&gt;&gt; snr = ds.radport.snr_map(freq_mhz=50.0)\n    &gt;&gt;&gt; # Find pixels with SNR &gt; 5\n    &gt;&gt;&gt; significant = snr.where(snr &gt; 5)\n    \"\"\"\n    # Validate variable\n    if var not in self._obj.data_vars:\n        raise ValueError(\n            f\"Variable '{var}' not found in dataset. \"\n            f\"Available variables: {list(self._obj.data_vars)}.\"\n        )\n\n    # Resolve frequency index\n    if freq_mhz is not None:\n        fi = self.nearest_freq_idx(freq_mhz)\n    elif freq_idx is not None:\n        fi = freq_idx\n    else:\n        fi = 0\n\n    # Get signal\n    signal = self._obj[var].isel(\n        time=time_idx, frequency=fi, polarization=pol\n    ).values.astype(float)\n\n    # Get RMS map\n    rms = self.rms_map(\n        time_idx=time_idx,\n        freq_idx=fi,\n        var=var,\n        pol=pol,\n        box_size=box_size,\n    ).values\n\n    # Compute SNR (avoiding division by zero)\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        snr = signal / rms\n        snr[~np.isfinite(snr)] = np.nan\n\n    # Create DataArray with coordinates\n    return xr.DataArray(\n        snr,\n        dims=[\"l\", \"m\"],\n        coords={\n            \"l\": self._obj.coords[\"l\"],\n            \"m\": self._obj.coords[\"m\"],\n        },\n        name=\"snr\",\n        attrs={\n            \"long_name\": \"Signal-to-noise ratio\",\n            \"units\": \"\",\n            \"box_size\": box_size,\n        },\n    )\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.snr_map--find-pixels-with-snr-5","title":"Find pixels with SNR &gt; 5","text":"<p>significant = snr.where(snr &gt; 5)</p>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.find_peaks","title":"<code>find_peaks(time_idx=0, freq_idx=None, freq_mhz=None, var='SKY', pol=0, threshold_sigma=5.0, box_size=50, min_separation=5)</code>","text":"<p>Find peaks above threshold in the image.</p> <p>Identifies local maxima that exceed the specified SNR threshold. Uses local maximum detection with minimum separation between peaks.</p> <p>Parameters:</p> Name Type Description Default <code>time_idx</code> <code>int</code> <p>Time index for the frame.</p> <code>0</code> <code>freq_idx</code> <code>int</code> <p>Frequency index for the frame. Defaults to 0 if neither freq_idx nor freq_mhz is provided.</p> <code>None</code> <code>freq_mhz</code> <code>float</code> <p>Select frequency by value in MHz. Overrides freq_idx if provided.</p> <code>None</code> <code>var</code> <code>str</code> <p>Data variable to analyze (\"SKY\" or \"BEAM\").</p> <code>\"SKY\"</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>threshold_sigma</code> <code>float</code> <p>Minimum SNR threshold for peak detection.</p> <code>5.0</code> <code>box_size</code> <code>int</code> <p>Size of the sliding box for local RMS computation.</p> <code>50</code> <code>min_separation</code> <code>int</code> <p>Minimum separation between peaks in pixels.</p> <code>5</code> <p>Returns:</p> Type Description <code>list of dict</code> <p>List of detected peaks, each with keys: - l: l coordinate value - m: m coordinate value - l_idx: l pixel index - m_idx: m pixel index - flux: peak flux value (Jy/beam) - snr: signal-to-noise ratio</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified variable doesn't exist in the dataset.</p> Example <p>peaks = ds.radport.find_peaks(freq_mhz=50.0, threshold_sigma=5.0) print(f\"Found {len(peaks)} peaks\") for p in peaks[:5]: ...     print(f\"  l={p['l']:.3f}, m={p['m']:.3f}, flux={p['flux']:.2f}, SNR={p['snr']:.1f}\")</p> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def find_peaks(\n    self,\n    time_idx: int = 0,\n    freq_idx: int | None = None,\n    freq_mhz: float | None = None,\n    var: str = \"SKY\",\n    pol: int = 0,\n    threshold_sigma: float = 5.0,\n    box_size: int = 50,\n    min_separation: int = 5,\n) -&gt; list[dict]:\n    \"\"\"Find peaks above threshold in the image.\n\n    Identifies local maxima that exceed the specified SNR threshold.\n    Uses local maximum detection with minimum separation between peaks.\n\n    Parameters\n    ----------\n    time_idx : int, default 0\n        Time index for the frame.\n    freq_idx : int, optional\n        Frequency index for the frame. Defaults to 0 if neither freq_idx\n        nor freq_mhz is provided.\n    freq_mhz : float, optional\n        Select frequency by value in MHz. Overrides freq_idx if provided.\n    var : str, default \"SKY\"\n        Data variable to analyze (\"SKY\" or \"BEAM\").\n    pol : int, default 0\n        Polarization index.\n    threshold_sigma : float, default 5.0\n        Minimum SNR threshold for peak detection.\n    box_size : int, default 50\n        Size of the sliding box for local RMS computation.\n    min_separation : int, default 5\n        Minimum separation between peaks in pixels.\n\n    Returns\n    -------\n    list of dict\n        List of detected peaks, each with keys:\n        - l: l coordinate value\n        - m: m coordinate value\n        - l_idx: l pixel index\n        - m_idx: m pixel index\n        - flux: peak flux value (Jy/beam)\n        - snr: signal-to-noise ratio\n\n    Raises\n    ------\n    ValueError\n        If the specified variable doesn't exist in the dataset.\n\n    Example\n    -------\n    &gt;&gt;&gt; peaks = ds.radport.find_peaks(freq_mhz=50.0, threshold_sigma=5.0)\n    &gt;&gt;&gt; print(f\"Found {len(peaks)} peaks\")\n    &gt;&gt;&gt; for p in peaks[:5]:\n    ...     print(f\"  l={p['l']:.3f}, m={p['m']:.3f}, flux={p['flux']:.2f}, SNR={p['snr']:.1f}\")\n    \"\"\"\n    from scipy.ndimage import maximum_filter\n\n    # Validate variable\n    if var not in self._obj.data_vars:\n        raise ValueError(\n            f\"Variable '{var}' not found in dataset. \"\n            f\"Available variables: {list(self._obj.data_vars)}.\"\n        )\n\n    # Resolve frequency index\n    if freq_mhz is not None:\n        fi = self.nearest_freq_idx(freq_mhz)\n    elif freq_idx is not None:\n        fi = freq_idx\n    else:\n        fi = 0\n\n    # Get signal and SNR maps\n    signal = self._obj[var].isel(\n        time=time_idx, frequency=fi, polarization=pol\n    ).values.astype(float)\n\n    snr = self.snr_map(\n        time_idx=time_idx,\n        freq_idx=fi,\n        var=var,\n        pol=pol,\n        box_size=box_size,\n    ).values\n\n    # Find local maxima using maximum filter\n    # A pixel is a local max if it equals the max in its neighborhood\n    local_max = maximum_filter(signal, size=min_separation * 2 + 1)\n    is_local_max = (signal == local_max) &amp; np.isfinite(signal)\n\n    # Apply SNR threshold\n    is_peak = is_local_max &amp; (snr &gt;= threshold_sigma)\n\n    # Get peak locations\n    l_indices, m_indices = np.where(is_peak)\n\n    # Get coordinate values\n    l_coords = self._obj.coords[\"l\"].values\n    m_coords = self._obj.coords[\"m\"].values\n\n    # Build list of peaks sorted by SNR (descending)\n    peaks = []\n    for l_idx, m_idx in zip(l_indices, m_indices):\n        peaks.append(\n            {\n                \"l\": float(l_coords[l_idx]),\n                \"m\": float(m_coords[m_idx]),\n                \"l_idx\": int(l_idx),\n                \"m_idx\": int(m_idx),\n                \"flux\": float(signal[l_idx, m_idx]),\n                \"snr\": float(snr[l_idx, m_idx]),\n            }\n        )\n\n    # Sort by SNR descending\n    peaks.sort(key=lambda p: p[\"snr\"], reverse=True)\n\n    return peaks\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.peak_flux_map","title":"<code>peak_flux_map(var='SKY', pol=0, freq_idx=None, freq_mhz=None)</code>","text":"<p>Compute peak flux at each pixel across all times.</p> <p>For each (l, m) pixel, finds the maximum flux value across all time steps at the specified frequency.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>str</code> <p>Data variable to analyze (\"SKY\" or \"BEAM\").</p> <code>\"SKY\"</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>freq_idx</code> <code>int</code> <p>Frequency index. Defaults to 0 if neither freq_idx nor freq_mhz is provided.</p> <code>None</code> <code>freq_mhz</code> <code>float</code> <p>Select frequency by value in MHz. Overrides freq_idx if provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>2D array of peak flux values with dimensions (l, m).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified variable doesn't exist in the dataset.</p> Example Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def peak_flux_map(\n    self,\n    var: str = \"SKY\",\n    pol: int = 0,\n    freq_idx: int | None = None,\n    freq_mhz: float | None = None,\n) -&gt; xr.DataArray:\n    \"\"\"Compute peak flux at each pixel across all times.\n\n    For each (l, m) pixel, finds the maximum flux value across\n    all time steps at the specified frequency.\n\n    Parameters\n    ----------\n    var : str, default \"SKY\"\n        Data variable to analyze (\"SKY\" or \"BEAM\").\n    pol : int, default 0\n        Polarization index.\n    freq_idx : int, optional\n        Frequency index. Defaults to 0 if neither freq_idx\n        nor freq_mhz is provided.\n    freq_mhz : float, optional\n        Select frequency by value in MHz. Overrides freq_idx if provided.\n\n    Returns\n    -------\n    xr.DataArray\n        2D array of peak flux values with dimensions (l, m).\n\n    Raises\n    ------\n    ValueError\n        If the specified variable doesn't exist in the dataset.\n\n    Example\n    -------\n    &gt;&gt;&gt; # Find brightest emission at each pixel across all times\n    &gt;&gt;&gt; peak_map = ds.radport.peak_flux_map(freq_mhz=50.0)\n    &gt;&gt;&gt; peak_map.plot()\n    \"\"\"\n    # Validate variable\n    if var not in self._obj.data_vars:\n        raise ValueError(\n            f\"Variable '{var}' not found in dataset. \"\n            f\"Available variables: {list(self._obj.data_vars)}.\"\n        )\n\n    # Resolve frequency index\n    if freq_mhz is not None:\n        fi = self.nearest_freq_idx(freq_mhz)\n    elif freq_idx is not None:\n        fi = freq_idx\n    else:\n        fi = 0\n\n    # Get data for all times at this frequency\n    data = self._obj[var].isel(frequency=fi, polarization=pol)\n\n    # Compute max across time dimension\n    peak_flux = data.max(dim=\"time\", skipna=True)\n\n    # Update attributes\n    peak_flux.name = \"peak_flux\"\n    peak_flux.attrs = {\n        \"long_name\": \"Peak flux across time\",\n        \"units\": \"Jy/beam\",\n    }\n\n    return peak_flux\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.peak_flux_map--find-brightest-emission-at-each-pixel-across-all-times","title":"Find brightest emission at each pixel across all times","text":"<p>peak_map = ds.radport.peak_flux_map(freq_mhz=50.0) peak_map.plot()</p>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.plot_snr_map","title":"<code>plot_snr_map(time_idx=0, freq_idx=None, freq_mhz=None, var='SKY', pol=0, box_size=50, cmap='RdBu_r', vmin=None, vmax=None, mask_radius=None, figsize=(8, 6), add_colorbar=True, symmetric=True)</code>","text":"<p>Plot the signal-to-noise ratio map.</p> <p>Parameters:</p> Name Type Description Default <code>time_idx</code> <code>int</code> <p>Time index for the frame.</p> <code>0</code> <code>freq_idx</code> <code>int</code> <p>Frequency index for the frame.</p> <code>None</code> <code>freq_mhz</code> <code>float</code> <p>Select frequency by value in MHz.</p> <code>None</code> <code>var</code> <code>str</code> <p>Data variable to analyze.</p> <code>\"SKY\"</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>box_size</code> <code>int</code> <p>Size of the sliding box for local RMS computation.</p> <code>50</code> <code>cmap</code> <code>str</code> <p>Colormap (diverging recommended for SNR).</p> <code>\"RdBu_r\"</code> <code>vmin</code> <code>float</code> <p>Minimum value for color scaling.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>Maximum value for color scaling.</p> <code>None</code> <code>mask_radius</code> <code>int</code> <p>Apply circular mask with this radius in pixels.</p> <code>None</code> <code>figsize</code> <code>tuple</code> <p>Figure size in inches.</p> <code>(8, 6)</code> <code>add_colorbar</code> <code>bool</code> <p>Whether to add a colorbar.</p> <code>True</code> <code>symmetric</code> <code>bool</code> <p>Use symmetric color scale centered at zero.</p> <code>True</code> <p>Returns:</p> Type Description <code>Figure</code> <p>The generated figure.</p> Example <p>fig = ds.radport.plot_snr_map(freq_mhz=50.0, mask_radius=1800)</p> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def plot_snr_map(\n    self,\n    time_idx: int = 0,\n    freq_idx: int | None = None,\n    freq_mhz: float | None = None,\n    var: str = \"SKY\",\n    pol: int = 0,\n    box_size: int = 50,\n    cmap: str = \"RdBu_r\",\n    vmin: float | None = None,\n    vmax: float | None = None,\n    mask_radius: int | None = None,\n    figsize: tuple[float, float] = (8, 6),\n    add_colorbar: bool = True,\n    symmetric: bool = True,\n) -&gt; \"Figure\":\n    \"\"\"Plot the signal-to-noise ratio map.\n\n    Parameters\n    ----------\n    time_idx : int, default 0\n        Time index for the frame.\n    freq_idx : int, optional\n        Frequency index for the frame.\n    freq_mhz : float, optional\n        Select frequency by value in MHz.\n    var : str, default \"SKY\"\n        Data variable to analyze.\n    pol : int, default 0\n        Polarization index.\n    box_size : int, default 50\n        Size of the sliding box for local RMS computation.\n    cmap : str, default \"RdBu_r\"\n        Colormap (diverging recommended for SNR).\n    vmin : float, optional\n        Minimum value for color scaling.\n    vmax : float, optional\n        Maximum value for color scaling.\n    mask_radius : int, optional\n        Apply circular mask with this radius in pixels.\n    figsize : tuple, default (8, 6)\n        Figure size in inches.\n    add_colorbar : bool, default True\n        Whether to add a colorbar.\n    symmetric : bool, default True\n        Use symmetric color scale centered at zero.\n\n    Returns\n    -------\n    matplotlib.figure.Figure\n        The generated figure.\n\n    Example\n    -------\n    &gt;&gt;&gt; fig = ds.radport.plot_snr_map(freq_mhz=50.0, mask_radius=1800)\n    \"\"\"\n    # Get SNR map\n    snr = self.snr_map(\n        time_idx=time_idx,\n        freq_idx=freq_idx,\n        freq_mhz=freq_mhz,\n        var=var,\n        pol=pol,\n        box_size=box_size,\n    )\n\n    snr_values = snr.values.copy()\n\n    # Apply mask if requested\n    if mask_radius is not None:\n        nl = len(self._obj.coords[\"l\"])\n        nm = len(self._obj.coords[\"m\"])\n        center_l, center_m = nl // 2, nm // 2\n        l_idx, m_idx = np.ogrid[:nl, :nm]\n        dist = np.sqrt((l_idx - center_l) ** 2 + (m_idx - center_m) ** 2)\n        mask = dist &gt; mask_radius\n        snr_values[mask] = np.nan\n\n    # Compute color scale\n    if symmetric and vmin is None and vmax is None:\n        finite_vals = snr_values[np.isfinite(snr_values)]\n        if len(finite_vals) &gt; 0:\n            max_abs = np.percentile(np.abs(finite_vals), 98)\n            vmin = -max_abs\n            vmax = max_abs\n\n    # Create figure\n    fig, ax = plt.subplots(figsize=figsize)\n\n    im = ax.imshow(\n        snr_values.T,\n        origin=\"lower\",\n        cmap=cmap,\n        vmin=vmin,\n        vmax=vmax,\n        aspect=\"equal\",\n    )\n\n    # Add colorbar\n    if add_colorbar:\n        cbar = fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04)\n        cbar.set_label(\"SNR (\u03c3)\", fontsize=11)\n\n    # Labels\n    ax.set_xlabel(\"l index\", fontsize=11)\n    ax.set_ylabel(\"m index\", fontsize=11)\n\n    # Get frequency for title\n    if freq_mhz is not None:\n        fi = self.nearest_freq_idx(freq_mhz)\n    elif freq_idx is not None:\n        fi = freq_idx\n    else:\n        fi = 0\n\n    freq_hz = float(self._obj.coords[\"frequency\"].values[fi])\n    time_val = self._obj.coords[\"time\"].values[time_idx]\n    try:\n        time_str = f\"{float(time_val):.6f}\"\n    except (TypeError, ValueError):\n        time_str = str(time_val)\n\n    ax.set_title(\n        f\"SNR Map at t={time_str} MJD, f={freq_hz/1e6:.2f} MHz\\n\"\n        f\"(box_size={box_size})\",\n        fontsize=11,\n    )\n\n    return fig\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.spectral_index","title":"<code>spectral_index(l, m, time_idx=0, pol=0, freq1_mhz=None, freq2_mhz=None, freq1_idx=None, freq2_idx=None, var='SKY')</code>","text":"<p>Compute spectral index (power-law slope) between two frequencies.</p> <p>The spectral index \u03b1 is defined by the power-law relationship S \u221d \u03bd^\u03b1, computed as: \u03b1 = log(S2/S1) / log(\u03bd2/\u03bd1)</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>float</code> <p>The l coordinate value for the pixel location.</p> required <code>m</code> <code>float</code> <p>The m coordinate value for the pixel location.</p> required <code>time_idx</code> <code>int</code> <p>Time index for the measurement.</p> <code>0</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>freq1_mhz</code> <code>float</code> <p>First frequency in MHz. If not provided, uses freq1_idx or first channel.</p> <code>None</code> <code>freq2_mhz</code> <code>float</code> <p>Second frequency in MHz. If not provided, uses freq2_idx or last channel.</p> <code>None</code> <code>freq1_idx</code> <code>int</code> <p>First frequency index. Overridden by freq1_mhz if provided.</p> <code>None</code> <code>freq2_idx</code> <code>int</code> <p>Second frequency index. Overridden by freq2_mhz if provided.</p> <code>None</code> <code>var</code> <code>str</code> <p>Data variable to analyze.</p> <code>\"SKY\"</code> <p>Returns:</p> Type Description <code>float</code> <p>Spectral index \u03b1 where S \u221d \u03bd^\u03b1. Returns NaN if calculation is not possible (e.g., non-positive flux values).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified variable doesn't exist in the dataset.</p> Example Notes <ul> <li>Assumes power-law spectrum: S \u221d \u03bd^\u03b1</li> <li>Returns NaN for non-positive flux values (cannot take log)</li> <li>Typical radio sources have \u03b1 \u2248 -0.7 (synchrotron emission)</li> </ul> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def spectral_index(\n    self,\n    l: float,\n    m: float,\n    time_idx: int = 0,\n    pol: int = 0,\n    freq1_mhz: float | None = None,\n    freq2_mhz: float | None = None,\n    freq1_idx: int | None = None,\n    freq2_idx: int | None = None,\n    var: str = \"SKY\",\n) -&gt; float:\n    \"\"\"Compute spectral index (power-law slope) between two frequencies.\n\n    The spectral index \u03b1 is defined by the power-law relationship S \u221d \u03bd^\u03b1,\n    computed as: \u03b1 = log(S2/S1) / log(\u03bd2/\u03bd1)\n\n    Parameters\n    ----------\n    l : float\n        The l coordinate value for the pixel location.\n    m : float\n        The m coordinate value for the pixel location.\n    time_idx : int, default 0\n        Time index for the measurement.\n    pol : int, default 0\n        Polarization index.\n    freq1_mhz : float, optional\n        First frequency in MHz. If not provided, uses freq1_idx or first channel.\n    freq2_mhz : float, optional\n        Second frequency in MHz. If not provided, uses freq2_idx or last channel.\n    freq1_idx : int, optional\n        First frequency index. Overridden by freq1_mhz if provided.\n    freq2_idx : int, optional\n        Second frequency index. Overridden by freq2_mhz if provided.\n    var : str, default \"SKY\"\n        Data variable to analyze.\n\n    Returns\n    -------\n    float\n        Spectral index \u03b1 where S \u221d \u03bd^\u03b1. Returns NaN if calculation\n        is not possible (e.g., non-positive flux values).\n\n    Raises\n    ------\n    ValueError\n        If the specified variable doesn't exist in the dataset.\n\n    Example\n    -------\n    &gt;&gt;&gt; # Compute spectral index at image center between 46 and 54 MHz\n    &gt;&gt;&gt; alpha = ds.radport.spectral_index(\n    ...     l=0.0, m=0.0,\n    ...     freq1_mhz=46.0,\n    ...     freq2_mhz=54.0,\n    ... )\n    &gt;&gt;&gt; print(f\"Spectral index: {alpha:.2f}\")\n\n    Notes\n    -----\n    - Assumes power-law spectrum: S \u221d \u03bd^\u03b1\n    - Returns NaN for non-positive flux values (cannot take log)\n    - Typical radio sources have \u03b1 \u2248 -0.7 (synchrotron emission)\n    \"\"\"\n    # Validate variable\n    if var not in self._obj.data_vars:\n        raise ValueError(\n            f\"Variable '{var}' not found in dataset. \"\n            f\"Available variables: {list(self._obj.data_vars)}.\"\n        )\n\n    # Get pixel indices\n    l_idx, m_idx = self.nearest_lm_idx(l, m)\n\n    # Resolve frequency indices\n    if freq1_mhz is not None:\n        fi1 = self.nearest_freq_idx(freq1_mhz)\n    elif freq1_idx is not None:\n        fi1 = freq1_idx\n    else:\n        fi1 = 0\n\n    if freq2_mhz is not None:\n        fi2 = self.nearest_freq_idx(freq2_mhz)\n    elif freq2_idx is not None:\n        fi2 = freq2_idx\n    else:\n        fi2 = len(self._obj.coords[\"frequency\"]) - 1\n\n    # Get flux values at both frequencies\n    s1 = float(\n        self._obj[var]\n        .isel(time=time_idx, frequency=fi1, polarization=pol, l=l_idx, m=m_idx)\n        .values\n    )\n    s2 = float(\n        self._obj[var]\n        .isel(time=time_idx, frequency=fi2, polarization=pol, l=l_idx, m=m_idx)\n        .values\n    )\n\n    # Get frequency values in Hz\n    nu1 = float(self._obj.coords[\"frequency\"].values[fi1])\n    nu2 = float(self._obj.coords[\"frequency\"].values[fi2])\n\n    # Compute spectral index: \u03b1 = log(S2/S1) / log(\u03bd2/\u03bd1)\n    # Handle non-positive flux values\n    if s1 &lt;= 0 or s2 &lt;= 0 or nu1 &lt;= 0 or nu2 &lt;= 0 or nu1 == nu2:\n        return float(\"nan\")\n\n    alpha = np.log(s2 / s1) / np.log(nu2 / nu1)\n    return float(alpha)\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.spectral_index--compute-spectral-index-at-image-center-between-46-and-54-mhz","title":"Compute spectral index at image center between 46 and 54 MHz","text":"<p>alpha = ds.radport.spectral_index( ...     l=0.0, m=0.0, ...     freq1_mhz=46.0, ...     freq2_mhz=54.0, ... ) print(f\"Spectral index: {alpha:.2f}\")</p>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.spectral_index_map","title":"<code>spectral_index_map(time_idx=0, pol=0, freq1_mhz=None, freq2_mhz=None, freq1_idx=None, freq2_idx=None, var='SKY')</code>","text":"<p>Compute spectral index map across the image.</p> <p>Computes the spectral index \u03b1 at each pixel, where S \u221d \u03bd^\u03b1.</p> <p>Parameters:</p> Name Type Description Default <code>time_idx</code> <code>int</code> <p>Time index for the measurement.</p> <code>0</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>freq1_mhz</code> <code>float</code> <p>First frequency in MHz. If not provided, uses freq1_idx or first channel.</p> <code>None</code> <code>freq2_mhz</code> <code>float</code> <p>Second frequency in MHz. If not provided, uses freq2_idx or last channel.</p> <code>None</code> <code>freq1_idx</code> <code>int</code> <p>First frequency index. Overridden by freq1_mhz if provided.</p> <code>None</code> <code>freq2_idx</code> <code>int</code> <p>Second frequency index. Overridden by freq2_mhz if provided.</p> <code>None</code> <code>var</code> <code>str</code> <p>Data variable to analyze.</p> <code>\"SKY\"</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>2D array of spectral index values with dimensions (l, m). NaN values indicate pixels where the calculation was not possible.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified variable doesn't exist in the dataset.</p> Example Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def spectral_index_map(\n    self,\n    time_idx: int = 0,\n    pol: int = 0,\n    freq1_mhz: float | None = None,\n    freq2_mhz: float | None = None,\n    freq1_idx: int | None = None,\n    freq2_idx: int | None = None,\n    var: str = \"SKY\",\n) -&gt; xr.DataArray:\n    \"\"\"Compute spectral index map across the image.\n\n    Computes the spectral index \u03b1 at each pixel, where S \u221d \u03bd^\u03b1.\n\n    Parameters\n    ----------\n    time_idx : int, default 0\n        Time index for the measurement.\n    pol : int, default 0\n        Polarization index.\n    freq1_mhz : float, optional\n        First frequency in MHz. If not provided, uses freq1_idx or first channel.\n    freq2_mhz : float, optional\n        Second frequency in MHz. If not provided, uses freq2_idx or last channel.\n    freq1_idx : int, optional\n        First frequency index. Overridden by freq1_mhz if provided.\n    freq2_idx : int, optional\n        Second frequency index. Overridden by freq2_mhz if provided.\n    var : str, default \"SKY\"\n        Data variable to analyze.\n\n    Returns\n    -------\n    xr.DataArray\n        2D array of spectral index values with dimensions (l, m).\n        NaN values indicate pixels where the calculation was not possible.\n\n    Raises\n    ------\n    ValueError\n        If the specified variable doesn't exist in the dataset.\n\n    Example\n    -------\n    &gt;&gt;&gt; # Compute spectral index map between first and last frequency\n    &gt;&gt;&gt; alpha_map = ds.radport.spectral_index_map()\n    &gt;&gt;&gt; alpha_map.plot(vmin=-3, vmax=1, cmap=\"RdBu_r\")\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Compute between specific frequencies\n    &gt;&gt;&gt; alpha_map = ds.radport.spectral_index_map(\n    ...     freq1_mhz=46.0,\n    ...     freq2_mhz=54.0,\n    ... )\n    \"\"\"\n    # Validate variable\n    if var not in self._obj.data_vars:\n        raise ValueError(\n            f\"Variable '{var}' not found in dataset. \"\n            f\"Available variables: {list(self._obj.data_vars)}.\"\n        )\n\n    # Resolve frequency indices\n    if freq1_mhz is not None:\n        fi1 = self.nearest_freq_idx(freq1_mhz)\n    elif freq1_idx is not None:\n        fi1 = freq1_idx\n    else:\n        fi1 = 0\n\n    if freq2_mhz is not None:\n        fi2 = self.nearest_freq_idx(freq2_mhz)\n    elif freq2_idx is not None:\n        fi2 = freq2_idx\n    else:\n        fi2 = len(self._obj.coords[\"frequency\"]) - 1\n\n    # Get flux arrays at both frequencies\n    s1 = self._obj[var].isel(\n        time=time_idx, frequency=fi1, polarization=pol\n    ).values.astype(float)\n    s2 = self._obj[var].isel(\n        time=time_idx, frequency=fi2, polarization=pol\n    ).values.astype(float)\n\n    # Get frequency values in Hz\n    nu1 = float(self._obj.coords[\"frequency\"].values[fi1])\n    nu2 = float(self._obj.coords[\"frequency\"].values[fi2])\n\n    # Compute spectral index: \u03b1 = log(S2/S1) / log(\u03bd2/\u03bd1)\n    with np.errstate(divide=\"ignore\", invalid=\"ignore\"):\n        # Mask non-positive values\n        valid_mask = (s1 &gt; 0) &amp; (s2 &gt; 0)\n        alpha = np.full_like(s1, np.nan)\n        alpha[valid_mask] = (\n            np.log(s2[valid_mask] / s1[valid_mask]) / np.log(nu2 / nu1)\n        )\n\n    # Create DataArray with coordinates\n    return xr.DataArray(\n        alpha,\n        dims=[\"l\", \"m\"],\n        coords={\n            \"l\": self._obj.coords[\"l\"],\n            \"m\": self._obj.coords[\"m\"],\n        },\n        name=\"spectral_index\",\n        attrs={\n            \"long_name\": \"Spectral index\",\n            \"units\": \"\",\n            \"freq1_hz\": nu1,\n            \"freq2_hz\": nu2,\n            \"freq1_mhz\": nu1 / 1e6,\n            \"freq2_mhz\": nu2 / 1e6,\n        },\n    )\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.spectral_index_map--compute-spectral-index-map-between-first-and-last-frequency","title":"Compute spectral index map between first and last frequency","text":"<p>alpha_map = ds.radport.spectral_index_map() alpha_map.plot(vmin=-3, vmax=1, cmap=\"RdBu_r\")</p>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.spectral_index_map--compute-between-specific-frequencies","title":"Compute between specific frequencies","text":"<p>alpha_map = ds.radport.spectral_index_map( ...     freq1_mhz=46.0, ...     freq2_mhz=54.0, ... )</p>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.integrated_flux","title":"<code>integrated_flux(l, m, time_idx=0, pol=0, freq_min_mhz=None, freq_max_mhz=None, freq_indices=None, var='SKY')</code>","text":"<p>Compute integrated flux density over a frequency band.</p> <p>Integrates the flux density across the specified frequency range using the trapezoidal rule.</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>float</code> <p>The l coordinate value for the pixel location.</p> required <code>m</code> <code>float</code> <p>The m coordinate value for the pixel location.</p> required <code>time_idx</code> <code>int</code> <p>Time index for the measurement.</p> <code>0</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>freq_min_mhz</code> <code>float</code> <p>Minimum frequency in MHz. If not provided, uses full range.</p> <code>None</code> <code>freq_max_mhz</code> <code>float</code> <p>Maximum frequency in MHz. If not provided, uses full range.</p> <code>None</code> <code>freq_indices</code> <code>list of int</code> <p>Specific frequency indices to include. Overrides freq_min/max_mhz.</p> <code>None</code> <code>var</code> <code>str</code> <p>Data variable to analyze.</p> <code>\"SKY\"</code> <p>Returns:</p> Type Description <code>float</code> <p>Integrated flux density in Jy\u00b7Hz. Divide by bandwidth to get average flux density.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified variable doesn't exist in the dataset.</p> Example Notes <p>Uses trapezoidal integration over the frequency axis.</p> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def integrated_flux(\n    self,\n    l: float,\n    m: float,\n    time_idx: int = 0,\n    pol: int = 0,\n    freq_min_mhz: float | None = None,\n    freq_max_mhz: float | None = None,\n    freq_indices: list[int] | None = None,\n    var: str = \"SKY\",\n) -&gt; float:\n    \"\"\"Compute integrated flux density over a frequency band.\n\n    Integrates the flux density across the specified frequency range\n    using the trapezoidal rule.\n\n    Parameters\n    ----------\n    l : float\n        The l coordinate value for the pixel location.\n    m : float\n        The m coordinate value for the pixel location.\n    time_idx : int, default 0\n        Time index for the measurement.\n    pol : int, default 0\n        Polarization index.\n    freq_min_mhz : float, optional\n        Minimum frequency in MHz. If not provided, uses full range.\n    freq_max_mhz : float, optional\n        Maximum frequency in MHz. If not provided, uses full range.\n    freq_indices : list of int, optional\n        Specific frequency indices to include. Overrides freq_min/max_mhz.\n    var : str, default \"SKY\"\n        Data variable to analyze.\n\n    Returns\n    -------\n    float\n        Integrated flux density in Jy\u00b7Hz. Divide by bandwidth to get\n        average flux density.\n\n    Raises\n    ------\n    ValueError\n        If the specified variable doesn't exist in the dataset.\n\n    Example\n    -------\n    &gt;&gt;&gt; # Compute integrated flux at image center across all frequencies\n    &gt;&gt;&gt; flux = ds.radport.integrated_flux(l=0.0, m=0.0)\n    &gt;&gt;&gt; print(f\"Integrated flux: {flux:.2e} Jy\u00b7Hz\")\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; # Compute over specific band\n    &gt;&gt;&gt; flux = ds.radport.integrated_flux(\n    ...     l=0.0, m=0.0,\n    ...     freq_min_mhz=45.0,\n    ...     freq_max_mhz=55.0,\n    ... )\n\n    Notes\n    -----\n    Uses trapezoidal integration over the frequency axis.\n    \"\"\"\n    # Validate variable\n    if var not in self._obj.data_vars:\n        raise ValueError(\n            f\"Variable '{var}' not found in dataset. \"\n            f\"Available variables: {list(self._obj.data_vars)}.\"\n        )\n\n    # Get pixel indices\n    l_idx, m_idx = self.nearest_lm_idx(l, m)\n\n    # Get all frequency values\n    freq_hz = self._obj.coords[\"frequency\"].values\n\n    # Determine which frequencies to include\n    if freq_indices is not None:\n        indices = freq_indices\n    else:\n        if freq_min_mhz is not None:\n            min_idx = self.nearest_freq_idx(freq_min_mhz)\n        else:\n            min_idx = 0\n\n        if freq_max_mhz is not None:\n            max_idx = self.nearest_freq_idx(freq_max_mhz)\n        else:\n            max_idx = len(freq_hz) - 1\n\n        # Ensure proper ordering\n        if min_idx &gt; max_idx:\n            min_idx, max_idx = max_idx, min_idx\n\n        indices = list(range(min_idx, max_idx + 1))\n\n    if len(indices) &lt; 2:\n        # Need at least 2 points for integration\n        if len(indices) == 1:\n            # Return single point value (no integration possible)\n            return float(\n                self._obj[var]\n                .isel(\n                    time=time_idx,\n                    frequency=indices[0],\n                    polarization=pol,\n                    l=l_idx,\n                    m=m_idx,\n                )\n                .values\n            )\n        return 0.0\n\n    # Get flux values at selected frequencies\n    flux_values = []\n    freq_values = []\n    for fi in indices:\n        flux = float(\n            self._obj[var]\n            .isel(time=time_idx, frequency=fi, polarization=pol, l=l_idx, m=m_idx)\n            .values\n        )\n        flux_values.append(flux)\n        freq_values.append(float(freq_hz[fi]))\n\n    flux_values = np.array(flux_values)\n    freq_values = np.array(freq_values)\n\n    # Integrate using trapezoidal rule\n    integrated = np.trapezoid(flux_values, freq_values)\n\n    return float(integrated)\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.integrated_flux--compute-integrated-flux-at-image-center-across-all-frequencies","title":"Compute integrated flux at image center across all frequencies","text":"<p>flux = ds.radport.integrated_flux(l=0.0, m=0.0) print(f\"Integrated flux: {flux:.2e} Jy\u00b7Hz\")</p>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.integrated_flux--compute-over-specific-band","title":"Compute over specific band","text":"<p>flux = ds.radport.integrated_flux( ...     l=0.0, m=0.0, ...     freq_min_mhz=45.0, ...     freq_max_mhz=55.0, ... )</p>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.plot_spectral_index_map","title":"<code>plot_spectral_index_map(time_idx=0, pol=0, freq1_mhz=None, freq2_mhz=None, freq1_idx=None, freq2_idx=None, var='SKY', cmap='RdBu_r', vmin=-3.0, vmax=1.0, mask_radius=None, figsize=(8, 6), add_colorbar=True)</code>","text":"<p>Plot the spectral index map.</p> <p>Parameters:</p> Name Type Description Default <code>time_idx</code> <code>int</code> <p>Time index for the measurement.</p> <code>0</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>freq1_mhz</code> <code>float</code> <p>First frequency in MHz.</p> <code>None</code> <code>freq2_mhz</code> <code>float</code> <p>Second frequency in MHz.</p> <code>None</code> <code>freq1_idx</code> <code>int</code> <p>First frequency index.</p> <code>None</code> <code>freq2_idx</code> <code>int</code> <p>Second frequency index.</p> <code>None</code> <code>var</code> <code>str</code> <p>Data variable to analyze.</p> <code>\"SKY\"</code> <code>cmap</code> <code>str</code> <p>Colormap (diverging recommended for spectral index).</p> <code>\"RdBu_r\"</code> <code>vmin</code> <code>float</code> <p>Minimum value for color scaling.</p> <code>-3.0</code> <code>vmax</code> <code>float</code> <p>Maximum value for color scaling.</p> <code>1.0</code> <code>mask_radius</code> <code>int</code> <p>Apply circular mask with this radius in pixels.</p> <code>None</code> <code>figsize</code> <code>tuple</code> <p>Figure size in inches.</p> <code>(8, 6)</code> <code>add_colorbar</code> <code>bool</code> <p>Whether to add a colorbar.</p> <code>True</code> <p>Returns:</p> Type Description <code>Figure</code> <p>The generated figure.</p> Example <p>fig = ds.radport.plot_spectral_index_map( ...     freq1_mhz=46.0, ...     freq2_mhz=54.0, ...     mask_radius=1800, ... )</p> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def plot_spectral_index_map(\n    self,\n    time_idx: int = 0,\n    pol: int = 0,\n    freq1_mhz: float | None = None,\n    freq2_mhz: float | None = None,\n    freq1_idx: int | None = None,\n    freq2_idx: int | None = None,\n    var: str = \"SKY\",\n    cmap: str = \"RdBu_r\",\n    vmin: float | None = -3.0,\n    vmax: float | None = 1.0,\n    mask_radius: int | None = None,\n    figsize: tuple[float, float] = (8, 6),\n    add_colorbar: bool = True,\n) -&gt; \"Figure\":\n    \"\"\"Plot the spectral index map.\n\n    Parameters\n    ----------\n    time_idx : int, default 0\n        Time index for the measurement.\n    pol : int, default 0\n        Polarization index.\n    freq1_mhz : float, optional\n        First frequency in MHz.\n    freq2_mhz : float, optional\n        Second frequency in MHz.\n    freq1_idx : int, optional\n        First frequency index.\n    freq2_idx : int, optional\n        Second frequency index.\n    var : str, default \"SKY\"\n        Data variable to analyze.\n    cmap : str, default \"RdBu_r\"\n        Colormap (diverging recommended for spectral index).\n    vmin : float, default -3.0\n        Minimum value for color scaling.\n    vmax : float, default 1.0\n        Maximum value for color scaling.\n    mask_radius : int, optional\n        Apply circular mask with this radius in pixels.\n    figsize : tuple, default (8, 6)\n        Figure size in inches.\n    add_colorbar : bool, default True\n        Whether to add a colorbar.\n\n    Returns\n    -------\n    matplotlib.figure.Figure\n        The generated figure.\n\n    Example\n    -------\n    &gt;&gt;&gt; fig = ds.radport.plot_spectral_index_map(\n    ...     freq1_mhz=46.0,\n    ...     freq2_mhz=54.0,\n    ...     mask_radius=1800,\n    ... )\n    \"\"\"\n    # Get spectral index map\n    alpha_map = self.spectral_index_map(\n        time_idx=time_idx,\n        pol=pol,\n        freq1_mhz=freq1_mhz,\n        freq2_mhz=freq2_mhz,\n        freq1_idx=freq1_idx,\n        freq2_idx=freq2_idx,\n        var=var,\n    )\n\n    alpha_values = alpha_map.values.copy()\n\n    # Apply mask if requested\n    if mask_radius is not None:\n        nl = len(self._obj.coords[\"l\"])\n        nm = len(self._obj.coords[\"m\"])\n        center_l, center_m = nl // 2, nm // 2\n        l_idx, m_idx = np.ogrid[:nl, :nm]\n        dist = np.sqrt((l_idx - center_l) ** 2 + (m_idx - center_m) ** 2)\n        mask = dist &gt; mask_radius\n        alpha_values[mask] = np.nan\n\n    # Create figure\n    fig, ax = plt.subplots(figsize=figsize)\n\n    im = ax.imshow(\n        alpha_values.T,\n        origin=\"lower\",\n        cmap=cmap,\n        vmin=vmin,\n        vmax=vmax,\n        aspect=\"equal\",\n    )\n\n    # Add colorbar\n    if add_colorbar:\n        cbar = fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04)\n        cbar.set_label(\"Spectral Index (\u03b1)\", fontsize=11)\n\n    # Labels\n    ax.set_xlabel(\"l index\", fontsize=11)\n    ax.set_ylabel(\"m index\", fontsize=11)\n\n    # Title\n    freq1_hz = alpha_map.attrs.get(\"freq1_hz\", 0)\n    freq2_hz = alpha_map.attrs.get(\"freq2_hz\", 0)\n    time_val = self._obj.coords[\"time\"].values[time_idx]\n    try:\n        time_str = f\"{float(time_val):.6f}\"\n    except (TypeError, ValueError):\n        time_str = str(time_val)\n\n    ax.set_title(\n        f\"Spectral Index Map at t={time_str} MJD\\n\"\n        f\"({freq1_hz/1e6:.1f} - {freq2_hz/1e6:.1f} MHz)\",\n        fontsize=11,\n    )\n\n    return fig\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.dispersion_delay","title":"<code>dispersion_delay(dm, freq_mhz=None, freq_ref_mhz=None)</code>","text":"<p>Calculate dispersion delay for a given DM and frequency.</p> <p>Radio signals experience frequency-dependent delays when propagating through the ionized interstellar medium. Lower frequencies arrive later than higher frequencies. This method computes the time delay using the cold plasma dispersion relation.</p> <p>Parameters:</p> Name Type Description Default <code>dm</code> <code>float</code> <p>Dispersion measure in pc cm^-3. Must be non-negative.</p> required <code>freq_mhz</code> <code>float or ndarray</code> <p>Frequency or array of frequencies in MHz at which to compute delays. If None, uses all frequencies in the dataset.</p> <code>None</code> <code>freq_ref_mhz</code> <code>float</code> <p>Reference frequency in MHz (typically the highest frequency). Delays are computed relative to this frequency. If None, uses the highest frequency in the dataset.</p> <code>None</code> <p>Returns:</p> Type Description <code>float or ndarray</code> <p>Time delay(s) in seconds. Positive values indicate the signal arrives later at lower frequencies. Returns the same shape as freq_mhz input.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dm is negative.</p> Notes <p>The dispersion delay is computed using:</p> <pre><code>\u0394t = K_DM \u00d7 DM \u00d7 (f_lo^-2 - f_hi^-2)\n</code></pre> <p>where: - K_DM = 4.148808 \u00d7 10^3 MHz^2 pc^-1 cm^3 s (dispersion constant) - DM is the dispersion measure in pc cm^-3 - f_lo, f_hi are frequencies in MHz</p> Example References <p>.. [1] Lorimer &amp; Kramer (2004), \"Handbook of Pulsar Astronomy\"</p> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def dispersion_delay(\n    self,\n    dm: float,\n    freq_mhz: float | np.ndarray | None = None,\n    freq_ref_mhz: float | None = None,\n) -&gt; float | np.ndarray:\n    \"\"\"Calculate dispersion delay for a given DM and frequency.\n\n    Radio signals experience frequency-dependent delays when propagating\n    through the ionized interstellar medium. Lower frequencies arrive\n    later than higher frequencies. This method computes the time delay\n    using the cold plasma dispersion relation.\n\n    Parameters\n    ----------\n    dm : float\n        Dispersion measure in pc cm^-3. Must be non-negative.\n    freq_mhz : float or np.ndarray, optional\n        Frequency or array of frequencies in MHz at which to compute\n        delays. If None, uses all frequencies in the dataset.\n    freq_ref_mhz : float, optional\n        Reference frequency in MHz (typically the highest frequency).\n        Delays are computed relative to this frequency.\n        If None, uses the highest frequency in the dataset.\n\n    Returns\n    -------\n    float or np.ndarray\n        Time delay(s) in seconds. Positive values indicate the signal\n        arrives later at lower frequencies. Returns the same shape as\n        freq_mhz input.\n\n    Raises\n    ------\n    ValueError\n        If dm is negative.\n\n    Notes\n    -----\n    The dispersion delay is computed using:\n\n        \u0394t = K_DM \u00d7 DM \u00d7 (f_lo^-2 - f_hi^-2)\n\n    where:\n    - K_DM = 4.148808 \u00d7 10^3 MHz^2 pc^-1 cm^3 s (dispersion constant)\n    - DM is the dispersion measure in pc cm^-3\n    - f_lo, f_hi are frequencies in MHz\n\n    Example\n    -------\n    &gt;&gt;&gt; # Crab pulsar DM = 56.8 pc cm^-3\n    &gt;&gt;&gt; dm = 56.8\n    &gt;&gt;&gt; delay = ds.radport.dispersion_delay(dm=dm, freq_mhz=46.0)\n    &gt;&gt;&gt; print(f\"Delay at 46 MHz: {delay:.3f} seconds\")\n\n    &gt;&gt;&gt; # Get delays at all dataset frequencies\n    &gt;&gt;&gt; delays = ds.radport.dispersion_delay(dm=56.8)\n\n    References\n    ----------\n    .. [1] Lorimer &amp; Kramer (2004), \"Handbook of Pulsar Astronomy\"\n    \"\"\"\n    # Validate DM\n    if dm &lt; 0:\n        raise ValueError(f\"DM must be non-negative, got {dm}\")\n\n    # Get frequencies\n    if freq_mhz is None:\n        freq_mhz = self._obj.coords[\"frequency\"].values / 1e6\n\n    freq_mhz = np.asarray(freq_mhz)\n\n    # Get reference frequency (highest frequency by default)\n    if freq_ref_mhz is None:\n        freq_ref_mhz = float(self._obj.coords[\"frequency\"].values.max() / 1e6)\n\n    # Validate reference frequency\n    if freq_ref_mhz &lt;= 0:\n        raise ValueError(f\"Reference frequency must be positive, got {freq_ref_mhz}\")\n\n    # Validate input frequencies\n    if np.any(freq_mhz &lt;= 0):\n        raise ValueError(\"All frequencies must be positive\")\n\n    # Compute delay: \u0394t = K_DM \u00d7 DM \u00d7 (f^-2 - f_ref^-2)\n    delay = self.K_DM * dm * (freq_mhz**-2 - freq_ref_mhz**-2)\n\n    return delay\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.dispersion_delay--crab-pulsar-dm-568-pc-cm-3","title":"Crab pulsar DM = 56.8 pc cm^-3","text":"<p>dm = 56.8 delay = ds.radport.dispersion_delay(dm=dm, freq_mhz=46.0) print(f\"Delay at 46 MHz: {delay:.3f} seconds\")</p>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.dispersion_delay--get-delays-at-all-dataset-frequencies","title":"Get delays at all dataset frequencies","text":"<p>delays = ds.radport.dispersion_delay(dm=56.8)</p>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.dynamic_spectrum_dedispersed","title":"<code>dynamic_spectrum_dedispersed(l, m, dm, var='SKY', pol=0, method='shift', fill_value=np.nan, trim=False)</code>","text":"<p>Extract a dedispersed dynamic spectrum for a single pixel.</p> <p>Corrects for interstellar dispersion by shifting or interpolating frequency channels according to the dispersion delay. This is essential for analyzing dispersed radio transients like pulsars and FRBs.</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>float</code> <p>Target l coordinate for pixel selection.</p> required <code>m</code> <code>float</code> <p>Target m coordinate for pixel selection.</p> required <code>dm</code> <code>float</code> <p>Dispersion measure in pc cm^-3. Must be non-negative.</p> required <code>var</code> <code>('SKY', 'BEAM')</code> <p>Data variable to extract.</p> <code>'SKY'</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>method</code> <code>('shift', 'interpolate')</code> <p>Dedispersion method: - 'shift': Fast integer-sample shifting (approximate).   Rounds delays to nearest time sample. - 'interpolate': Slower but precise sub-sample interpolation.   Uses linear interpolation for accurate delay correction.</p> <code>'shift'</code> <code>fill_value</code> <code>float</code> <p>Value to use for samples shifted outside the time range.</p> <code>np.nan</code> <code>trim</code> <code>bool</code> <p>If True, trim the time axis to only include valid data (removes NaN edges from shifting). If False, returns full time axis with NaN-filled edges.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>2D DataArray with dimensions (time, frequency) containing the dedispersed dynamic spectrum. Time axis represents arrival time at the reference frequency. Includes metadata: pixel_l, pixel_m, dm, method, freq_ref_mhz.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If dm is negative, variable doesn't exist, or method is invalid.</p> <p>Warns:</p> Type Description <code>UserWarning</code> <p>If the maximum dispersion shift exceeds 50% of the time span.</p> Notes <p>The dedispersion aligns all frequency channels to a common reference time (typically the highest frequency). Lower frequency channels are shifted backwards in time to compensate for the dispersion delay.</p> <p>For the 'shift' method, delays are rounded to the nearest integer number of time samples, which introduces quantization error. For precise analysis, use 'interpolate'.</p> Example See Also <p>dispersion_delay : Compute dispersion delays for given frequencies. dynamic_spectrum : Extract uncorrected dynamic spectrum. plot_dynamic_spectrum : Plot dynamic spectrum with optional dedispersion.</p> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def dynamic_spectrum_dedispersed(\n    self,\n    l: float,\n    m: float,\n    dm: float,\n    var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n    pol: int = 0,\n    method: Literal[\"shift\", \"interpolate\"] = \"shift\",\n    fill_value: float = np.nan,\n    trim: bool = False,\n) -&gt; xr.DataArray:\n    \"\"\"Extract a dedispersed dynamic spectrum for a single pixel.\n\n    Corrects for interstellar dispersion by shifting or interpolating\n    frequency channels according to the dispersion delay. This is essential\n    for analyzing dispersed radio transients like pulsars and FRBs.\n\n    Parameters\n    ----------\n    l : float\n        Target l coordinate for pixel selection.\n    m : float\n        Target m coordinate for pixel selection.\n    dm : float\n        Dispersion measure in pc cm^-3. Must be non-negative.\n    var : {'SKY', 'BEAM'}, default 'SKY'\n        Data variable to extract.\n    pol : int, default 0\n        Polarization index.\n    method : {'shift', 'interpolate'}, default 'shift'\n        Dedispersion method:\n        - 'shift': Fast integer-sample shifting (approximate).\n          Rounds delays to nearest time sample.\n        - 'interpolate': Slower but precise sub-sample interpolation.\n          Uses linear interpolation for accurate delay correction.\n    fill_value : float, default np.nan\n        Value to use for samples shifted outside the time range.\n    trim : bool, default False\n        If True, trim the time axis to only include valid data\n        (removes NaN edges from shifting). If False, returns full\n        time axis with NaN-filled edges.\n\n    Returns\n    -------\n    xr.DataArray\n        2D DataArray with dimensions (time, frequency) containing\n        the dedispersed dynamic spectrum. Time axis represents\n        arrival time at the reference frequency.\n        Includes metadata: pixel_l, pixel_m, dm, method, freq_ref_mhz.\n\n    Raises\n    ------\n    ValueError\n        If dm is negative, variable doesn't exist, or method is invalid.\n\n    Warns\n    -----\n    UserWarning\n        If the maximum dispersion shift exceeds 50% of the time span.\n\n    Notes\n    -----\n    The dedispersion aligns all frequency channels to a common reference\n    time (typically the highest frequency). Lower frequency channels are\n    shifted backwards in time to compensate for the dispersion delay.\n\n    For the 'shift' method, delays are rounded to the nearest integer\n    number of time samples, which introduces quantization error. For\n    precise analysis, use 'interpolate'.\n\n    Example\n    -------\n    &gt;&gt;&gt; # Dedisperse at Crab pulsar DM\n    &gt;&gt;&gt; dynspec = ds.radport.dynamic_spectrum_dedispersed(\n    ...     l=0.0, m=0.0, dm=56.8, method=\"interpolate\"\n    ... )\n\n    &gt;&gt;&gt; # Fast approximate dedispersion\n    &gt;&gt;&gt; dynspec_fast = ds.radport.dynamic_spectrum_dedispersed(\n    ...     l=0.0, m=0.0, dm=56.8, method=\"shift\", trim=True\n    ... )\n\n    See Also\n    --------\n    dispersion_delay : Compute dispersion delays for given frequencies.\n    dynamic_spectrum : Extract uncorrected dynamic spectrum.\n    plot_dynamic_spectrum : Plot dynamic spectrum with optional dedispersion.\n    \"\"\"\n    # Validate inputs\n    if dm &lt; 0:\n        raise ValueError(f\"DM must be non-negative, got {dm}\")\n\n    if method not in (\"shift\", \"interpolate\"):\n        raise ValueError(\n            f\"Method must be 'shift' or 'interpolate', got '{method}'\"\n        )\n\n    if var not in self._obj.data_vars:\n        available = sorted(self._obj.data_vars)\n        raise ValueError(\n            f\"Variable '{var}' not found. Available: {available}\"\n        )\n\n    # Get the uncorrected dynamic spectrum\n    dynspec = self.dynamic_spectrum(l=l, m=m, var=var, pol=pol)\n\n    # If DM is zero, return the original spectrum\n    if dm == 0:\n        dynspec.attrs[\"dm\"] = 0.0\n        dynspec.attrs[\"method\"] = method\n        dynspec.attrs[\"freq_ref_mhz\"] = float(\n            self._obj.coords[\"frequency\"].values.max() / 1e6\n        )\n        return dynspec\n\n    # Get coordinates\n    time_vals = dynspec.coords[\"time\"].values\n    freq_vals = dynspec.coords[\"frequency\"].values  # Hz\n    freq_mhz = freq_vals / 1e6\n\n    # Compute reference frequency (highest)\n    freq_ref_mhz = float(freq_mhz.max())\n\n    # Compute dispersion delays for each frequency channel\n    delays = self.dispersion_delay(dm=dm, freq_mhz=freq_mhz, freq_ref_mhz=freq_ref_mhz)\n\n    # Get time resolution\n    if len(time_vals) &lt; 2:\n        raise ValueError(\"Need at least 2 time samples for dedispersion\")\n\n    dt = float(time_vals[1] - time_vals[0])  # Time resolution in MJD\n    dt_seconds = dt * 86400.0  # Convert to seconds\n\n    # Convert delays to time samples\n    delay_samples = delays / dt_seconds\n\n    # Check for excessive delays\n    max_delay_samples = np.abs(delay_samples).max()\n    if max_delay_samples &gt; 0.5 * len(time_vals):\n        warnings.warn(\n            f\"Maximum dispersion shift ({max_delay_samples:.1f} samples) \"\n            f\"exceeds 50% of time span ({len(time_vals)} samples). \"\n            \"Consider using a smaller DM or longer observation.\",\n            UserWarning,\n            stacklevel=2,\n        )\n\n    # Get data values\n    data = dynspec.values.copy()  # Shape: (time, frequency)\n    n_time, n_freq = data.shape\n\n    # Create output array\n    dedispersed = np.full_like(data, fill_value)\n\n    if method == \"shift\":\n        # Integer sample shifting (fast, approximate)\n        for i_freq in range(n_freq):\n            shift = int(np.round(delay_samples[i_freq]))\n\n            if shift == 0:\n                dedispersed[:, i_freq] = data[:, i_freq]\n            elif shift &gt; 0:\n                # Signal arrives later at lower freq, shift backwards\n                if shift &lt; n_time:\n                    dedispersed[:-shift, i_freq] = data[shift:, i_freq]\n            else:\n                # Negative shift (shouldn't happen for positive DM)\n                shift = abs(shift)\n                if shift &lt; n_time:\n                    dedispersed[shift:, i_freq] = data[:-shift, i_freq]\n\n    else:  # method == \"interpolate\"\n        # Sub-sample interpolation (slower, precise)\n        for i_freq in range(n_freq):\n            delay_mjd = delays[i_freq] / 86400.0  # Convert to MJD\n\n            # Create interpolator for this frequency channel\n            interp_func = interpolate.interp1d(\n                time_vals,\n                data[:, i_freq],\n                kind=\"linear\",\n                bounds_error=False,\n                fill_value=fill_value,\n            )\n\n            # Interpolate at shifted times\n            # To correct for dispersion, we sample at time + delay\n            shifted_times = time_vals + delay_mjd\n            dedispersed[:, i_freq] = interp_func(shifted_times)\n\n    # Trim if requested\n    if trim:\n        # Find valid time range (where all frequencies have data)\n        valid_mask = ~np.all(np.isnan(dedispersed), axis=1)\n        if np.any(valid_mask):\n            first_valid = np.argmax(valid_mask)\n            last_valid = len(valid_mask) - np.argmax(valid_mask[::-1]) - 1\n            dedispersed = dedispersed[first_valid:last_valid + 1, :]\n            time_vals = time_vals[first_valid:last_valid + 1]\n\n    # Create output DataArray\n    result = xr.DataArray(\n        dedispersed,\n        dims=[\"time\", \"frequency\"],\n        coords={\n            \"time\": time_vals,\n            \"frequency\": freq_vals,\n        },\n        name=f\"{var}_dedispersed\",\n        attrs={\n            \"pixel_l\": dynspec.attrs[\"pixel_l\"],\n            \"pixel_m\": dynspec.attrs[\"pixel_m\"],\n            \"l_idx\": dynspec.attrs[\"l_idx\"],\n            \"m_idx\": dynspec.attrs[\"m_idx\"],\n            \"pol\": pol,\n            \"dm\": dm,\n            \"method\": method,\n            \"freq_ref_mhz\": freq_ref_mhz,\n            \"long_name\": f\"Dedispersed {var} (DM={dm:.2f} pc/cm\u00b3)\",\n            \"units\": \"Jy/beam\",\n        },\n    )\n\n    return result\n</code></pre>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.dynamic_spectrum_dedispersed--dedisperse-at-crab-pulsar-dm","title":"Dedisperse at Crab pulsar DM","text":"<p>dynspec = ds.radport.dynamic_spectrum_dedispersed( ...     l=0.0, m=0.0, dm=56.8, method=\"interpolate\" ... )</p>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.dynamic_spectrum_dedispersed--fast-approximate-dedispersion","title":"Fast approximate dedispersion","text":"<p>dynspec_fast = ds.radport.dynamic_spectrum_dedispersed( ...     l=0.0, m=0.0, dm=56.8, method=\"shift\", trim=True ... )</p>"},{"location":"api/radport-accessor/#ovro_lwa_portal.accessor.RadportAccessor.plot_dynamic_spectrum_dedispersed","title":"<code>plot_dynamic_spectrum_dedispersed(l, m, dm, var='SKY', pol=0, method='shift', trim=False, cmap='inferno', vmin=None, vmax=None, robust=True, figsize=(10, 5), add_colorbar=True, show_delay_curve=False, **kwargs)</code>","text":"<p>Plot a dedispersed dynamic spectrum for a single pixel.</p> <p>Creates a 2D visualization showing intensity variations across time and frequency after correcting for interstellar dispersion.</p> <p>Parameters:</p> Name Type Description Default <code>l</code> <code>float</code> <p>Target l coordinate for pixel selection.</p> required <code>m</code> <code>float</code> <p>Target m coordinate for pixel selection.</p> required <code>dm</code> <code>float</code> <p>Dispersion measure in pc cm^-3.</p> required <code>var</code> <code>('SKY', 'BEAM')</code> <p>Data variable to plot.</p> <code>'SKY'</code> <code>pol</code> <code>int</code> <p>Polarization index.</p> <code>0</code> <code>method</code> <code>('shift', 'interpolate')</code> <p>Dedispersion method ('shift' for fast, 'interpolate' for precise).</p> <code>'shift'</code> <code>trim</code> <code>bool</code> <p>If True, trim time axis to valid data only.</p> <code>False</code> <code>cmap</code> <code>str</code> <p>Matplotlib colormap.</p> <code>'inferno'</code> <code>vmin</code> <code>float</code> <p>Color scale limits.</p> <code>None</code> <code>vmax</code> <code>float</code> <p>Color scale limits.</p> <code>None</code> <code>robust</code> <code>bool</code> <p>Use percentile-based color scaling.</p> <code>True</code> <code>figsize</code> <code>tuple</code> <p>Figure size in inches.</p> <code>(10, 5)</code> <code>add_colorbar</code> <code>bool</code> <p>Whether to add a colorbar.</p> <code>True</code> <code>show_delay_curve</code> <code>bool</code> <p>If True, overlay the dispersion delay curve on the plot.</p> <code>False</code> <code>**kwargs</code> <code>dict</code> <p>Additional arguments passed to imshow.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Figure</code> <p>The figure containing the dedispersed dynamic spectrum plot.</p> Example <p>fig = ds.radport.plot_dynamic_spectrum_dedispersed( ...     l=0.0, m=0.0, dm=56.8, method=\"interpolate\" ... )</p> Source code in <code>src/ovro_lwa_portal/accessor.py</code> <pre><code>def plot_dynamic_spectrum_dedispersed(\n    self,\n    l: float,\n    m: float,\n    dm: float,\n    var: Literal[\"SKY\", \"BEAM\"] = \"SKY\",\n    pol: int = 0,\n    method: Literal[\"shift\", \"interpolate\"] = \"shift\",\n    trim: bool = False,\n    cmap: str = \"inferno\",\n    vmin: float | None = None,\n    vmax: float | None = None,\n    robust: bool = True,\n    figsize: tuple[float, float] = (10, 5),\n    add_colorbar: bool = True,\n    show_delay_curve: bool = False,\n    **kwargs: Any,\n) -&gt; \"Figure\":\n    \"\"\"Plot a dedispersed dynamic spectrum for a single pixel.\n\n    Creates a 2D visualization showing intensity variations across\n    time and frequency after correcting for interstellar dispersion.\n\n    Parameters\n    ----------\n    l : float\n        Target l coordinate for pixel selection.\n    m : float\n        Target m coordinate for pixel selection.\n    dm : float\n        Dispersion measure in pc cm^-3.\n    var : {'SKY', 'BEAM'}, default 'SKY'\n        Data variable to plot.\n    pol : int, default 0\n        Polarization index.\n    method : {'shift', 'interpolate'}, default 'shift'\n        Dedispersion method ('shift' for fast, 'interpolate' for precise).\n    trim : bool, default False\n        If True, trim time axis to valid data only.\n    cmap : str, default 'inferno'\n        Matplotlib colormap.\n    vmin, vmax : float, optional\n        Color scale limits.\n    robust : bool, default True\n        Use percentile-based color scaling.\n    figsize : tuple, default (10, 5)\n        Figure size in inches.\n    add_colorbar : bool, default True\n        Whether to add a colorbar.\n    show_delay_curve : bool, default False\n        If True, overlay the dispersion delay curve on the plot.\n    **kwargs : dict\n        Additional arguments passed to imshow.\n\n    Returns\n    -------\n    matplotlib.figure.Figure\n        The figure containing the dedispersed dynamic spectrum plot.\n\n    Example\n    -------\n    &gt;&gt;&gt; fig = ds.radport.plot_dynamic_spectrum_dedispersed(\n    ...     l=0.0, m=0.0, dm=56.8, method=\"interpolate\"\n    ... )\n    \"\"\"\n    # Get dedispersed dynamic spectrum\n    dynspec = self.dynamic_spectrum_dedispersed(\n        l=l, m=m, dm=dm, var=var, pol=pol, method=method, trim=trim\n    )\n\n    # Create figure\n    fig, ax = plt.subplots(figsize=figsize)\n\n    # Compute data\n    data = dynspec.values\n\n    # Handle robust scaling\n    if robust and vmin is None and vmax is None:\n        finite_data = data[np.isfinite(data)]\n        if finite_data.size &gt; 0:\n            vmin = float(np.percentile(finite_data, 2))\n            vmax = float(np.percentile(finite_data, 98))\n\n    # Get coordinate values\n    time_vals = dynspec.coords[\"time\"].values\n    freq_vals = dynspec.coords[\"frequency\"].values / 1e6  # Convert to MHz\n\n    # Compute extent for imshow\n    extent = [\n        float(time_vals.min()), float(time_vals.max()),\n        float(freq_vals.min()), float(freq_vals.max()),\n    ]\n\n    # Plot - transpose so time is x-axis and frequency is y-axis\n    im = ax.imshow(\n        data.T,\n        origin=\"lower\",\n        cmap=cmap,\n        vmin=vmin,\n        vmax=vmax,\n        extent=extent,\n        aspect=\"auto\",\n        **kwargs,\n    )\n\n    # Optionally show dispersion delay curve\n    if show_delay_curve and dm &gt; 0:\n        delays = self.dispersion_delay(dm=dm, freq_mhz=freq_vals)\n        # Convert delays to MJD offset from reference\n        delay_mjd = delays / 86400.0\n        # Plot as time offset from center of time range\n        t_center = (time_vals.min() + time_vals.max()) / 2\n        ax.plot(\n            t_center - delay_mjd,\n            freq_vals,\n            \"w--\",\n            linewidth=1.5,\n            alpha=0.7,\n            label=\"Dispersion curve\",\n        )\n        ax.legend(loc=\"upper right\")\n\n    if add_colorbar:\n        cbar = fig.colorbar(im, ax=ax)\n        cbar.set_label(\"Jy/beam\")\n\n    # Labels and title\n    pixel_l = dynspec.attrs[\"pixel_l\"]\n    pixel_m = dynspec.attrs[\"pixel_m\"]\n    ax.set_xlabel(\"Time (MJD)\")\n    ax.set_ylabel(\"Frequency (MHz)\")\n    ax.set_title(\n        f\"{var} Dedispersed Dynamic Spectrum\\n\"\n        f\"l={pixel_l:+.4f}, m={pixel_m:+.4f}, pol={pol}, \"\n        f\"DM={dm:.2f} pc/cm\u00b3 ({method})\"\n    )\n\n    fig.tight_layout()\n    return fig\n</code></pre>"},{"location":"contributing/contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to OVRO-LWA Portal! This guide covers how to set up the project locally, run tests, and submit changes.</p> <p>For the full contributing guidelines, see CONTRIBUTING.md on GitHub.</p> <p>Please review our Code of Conduct before contributing.</p>"},{"location":"contributing/contributing/#pull-requests","title":"Pull Requests","text":"<ul> <li>Fork the repository and create a branch for your changes</li> <li>Follow   Conventional Commits   for PR titles</li> <li>See this tutorial   for a general guide to open-source contributions</li> </ul>"},{"location":"contributing/contributing/#setting-up-your-environment","title":"Setting Up Your Environment","text":""},{"location":"contributing/contributing/#prerequisites","title":"Prerequisites","text":"<p>This project uses Pixi for dependency management.</p> macOS / LinuxWindows <pre><code>curl -fsSL https://pixi.sh/install.sh | sh\n</code></pre> <pre><code>powershell -ExecutionPolicy ByPass -c \"irm -useb https://pixi.sh/install.ps1 | iex\"\n</code></pre>"},{"location":"contributing/contributing/#clone-and-install","title":"Clone and Install","text":"Pixi (Recommended)pip <pre><code>git clone https://github.com/uw-ssec/ovro-lwa-portal.git\ncd ovro-lwa-portal\npixi install\npixi run pre-commit-install\n</code></pre> <pre><code>git clone https://github.com/uw-ssec/ovro-lwa-portal.git\ncd ovro-lwa-portal\npip install -e \".[dev]\"\n</code></pre>"},{"location":"contributing/contributing/#verify-installation","title":"Verify Installation","text":"<pre><code>python -c \"import ovro_lwa_portal; print(ovro_lwa_portal.__version__)\"\n</code></pre>"},{"location":"contributing/contributing/#running-tests","title":"Running Tests","text":"<pre><code># With Pixi\npixi run pytest tests/\n\n# Or directly\npytest tests/\n</code></pre>"},{"location":"contributing/contributing/#building-the-package","title":"Building the Package","text":"<pre><code>python -m build\n</code></pre> <p>This creates wheel and source distributions in the <code>dist/</code> directory.</p>"},{"location":"contributing/contributing/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>PRs are checked by pre-commit for style and formatting. Set up your local repository so checks run automatically on every commit:</p> <pre><code># Install hooks (run once)\npixi run pre-commit-install\n\n# Run manually on staged files\npixi run pre-commit\n\n# Run on all files\npixi run pre-commit-all\n</code></pre>"},{"location":"contributing/contributing/#building-documentation","title":"Building Documentation","text":"<p>The documentation site is built with MkDocs and the Material theme.</p> <pre><code># Serve locally with live reload\npixi run mkdocs serve\n\n# Build the static site\npixi run mkdocs build\n</code></pre> <p>The site will be available at <code>http://127.0.0.1:8000/ovro-lwa-portal/</code>.</p>"},{"location":"contributing/contributing/#code-style","title":"Code Style","text":"<ul> <li>Docstrings: Use   NumPy-style   docstrings for all public functions and classes</li> <li>PR titles: Follow   Conventional Commits</li> <li>Formatting: Enforced automatically by pre-commit hooks</li> </ul>"},{"location":"contributing/contributing/#working-with-radio-astronomy-data","title":"Working with Radio Astronomy Data","text":""},{"location":"contributing/contributing/#test-data","title":"Test Data","text":"<p>Use the provided test FITS files in <code>notebooks/test_fits_files/</code> for development and testing. These represent typical OVRO-LWA observations.</p>"},{"location":"contributing/contributing/#jupyter-notebooks","title":"Jupyter Notebooks","text":"<ul> <li>Notebooks in <code>notebooks/</code> are for data exploration and analysis</li> <li>Keep notebooks clean and well-documented</li> <li>Use <code>nbstripout</code> or similar tools to remove output before committing</li> </ul>"},{"location":"contributing/contributing/#performance","title":"Performance","text":"<ul> <li>Use <code>dask</code> for large array operations that don't fit in memory</li> <li>Consider chunking strategies for Zarr arrays based on access patterns</li> <li>Profile memory usage when working with large datasets</li> </ul>"},{"location":"contributing/contributing/#project-specific-notes","title":"Project-Specific Notes","text":""},{"location":"contributing/contributing/#image-plane-correction","title":"Image Plane Correction","text":"<ul> <li>The <code>image-plane-correction</code> package is an external dependency from the   OVRO-LWA team</li> <li>Currently using the <code>nikita/dev</code> branch</li> <li>Report issues to the upstream repository when appropriate</li> </ul>"},{"location":"contributing/contributing/#bdsf-integration","title":"BDSF Integration","text":"<p>For macOS ARM64 users:</p> <ul> <li>A pre-compiled wheel is provided to avoid compilation issues</li> <li>If you encounter problems, check the <code>pyproject.toml</code> configuration in the   <code>[tool.pixi]</code> section</li> <li>Linux users should use the standard PyPI package</li> </ul>"},{"location":"contributing/contributing/#ssec-cli","title":"ssec CLI","text":"<p>The <code>ssec</code> CLI provides convenience functions for working with this repository. See https://github.com/uw-ssec/ssec-cli for details.</p> <pre><code># Set up autocompletions\npixi run ssec-setup\n\n# Run ssec commands\npixi run ssec &lt;options&gt;\n</code></pre>"},{"location":"getting-started/basic-plotting/","title":"Basic Plotting","text":"<p>The <code>radport</code> accessor provides rich visualization capabilities for OVRO-LWA data.</p>"},{"location":"getting-started/basic-plotting/#quick-plot","title":"Quick Plot","text":"<p>The simplest way to visualize your data:</p> <pre><code>import ovro_lwa_portal as ovro\n\nds = ovro.open_dataset(\"path/to/data.zarr\")\n\n# Plot a single frame\nds.radport.plot()\n</code></pre> <p>This creates a 2D sky map with:</p> <ul> <li>Automatic colorbar scaling</li> <li>Coordinate labels (l, m or RA, Dec)</li> <li>Title with observation metadata</li> </ul>"},{"location":"getting-started/basic-plotting/#selecting-time-and-frequency","title":"Selecting Time and Frequency","text":"<pre><code># Plot specific time and frequency\nds.radport.plot(time_idx=0, freq_idx=10)\n\n# Use nearest value instead of index\nfreq_mhz = 40.0\ntime_idx = ds.radport.nearest_time_idx(mjd=59000.5)\nfreq_idx = ds.radport.nearest_freq_idx(freq_mhz)\n\nds.radport.plot(time_idx=time_idx, freq_idx=freq_idx)\n</code></pre>"},{"location":"getting-started/basic-plotting/#customizing-plots","title":"Customizing Plots","text":"<pre><code># Set colormap and normalization\nds.radport.plot(\n    time_idx=0,\n    freq_idx=0,\n    cmap='viridis',\n    norm='log'\n)\n\n# Add custom title\nds.radport.plot(\n    time_idx=0,\n    freq_idx=0,\n    title='OVRO-LWA Sky Map at 40 MHz'\n)\n</code></pre>"},{"location":"getting-started/basic-plotting/#saving-figures","title":"Saving Figures","text":"<pre><code>import matplotlib.pyplot as plt\n\nds.radport.plot()\nplt.savefig('ovro_skymap.png', dpi=300, bbox_inches='tight')\nplt.close()\n</code></pre>"},{"location":"getting-started/basic-plotting/#what-else-can-you-plot","title":"What Else Can You Plot?","text":"<p>The <code>radport</code> accessor supports many more visualization methods beyond basic sky maps. See the Visualization guide for:</p> <ul> <li>Cutout regions \u2014 extract and plot sub-regions of interest</li> <li>Dynamic spectra \u2014 time-frequency waterfalls at a pixel or spatial region</li> <li>Light curves and spectra \u2014 track intensity over time or frequency</li> <li>Grid plots \u2014 multi-panel layouts across time steps or frequencies</li> <li>Difference plots \u2014 visualize changes between frames</li> <li>Averaged visualizations \u2014 time or frequency averaged images</li> <li>Contour overlays and custom colormaps</li> </ul>"},{"location":"getting-started/basic-plotting/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about coordinate systems</li> <li>Explore the full Visualization guide</li> <li>Create animations</li> </ul>"},{"location":"getting-started/coordinate-systems/","title":"Coordinate Systems","text":"<p>OVRO-LWA data uses multiple coordinate systems. Understanding them is essential for analysis.</p>"},{"location":"getting-started/coordinate-systems/#pixel-coordinates-l-m","title":"Pixel Coordinates (l, m)","text":"<p>The primary coordinate system uses direction cosines:</p> <ul> <li>l: East-West direction cosine (dimensionless)</li> <li>m: North-South direction cosine (dimensionless)</li> <li>Range: typically -1 to +1</li> <li>Center: (l=0, m=0) is the phase center</li> </ul> <pre><code>import ovro_lwa_portal as ovro\n\nds = ovro.open_dataset(\"path/to/data.zarr\")\n\n# Access pixel data\nintensity = ds['SKY'].sel(l=0.1, m=0.2, method='nearest')\n</code></pre>"},{"location":"getting-started/coordinate-systems/#world-coordinate-system-wcs","title":"World Coordinate System (WCS)","text":"<p>If WCS information is present, you can work with celestial coordinates:</p>"},{"location":"getting-started/coordinate-systems/#check-for-wcs","title":"Check for WCS","text":"<pre><code># Check if dataset has WCS\nif ds.radport.has_wcs():\n    print(\"WCS available\")\nelse:\n    print(\"No WCS information\")\n</code></pre>"},{"location":"getting-started/coordinate-systems/#pixel-to-sky-coordinates","title":"Pixel to Sky Coordinates","text":"<p>Convert pixel coordinates to RA/Dec:</p> <pre><code># Convert (l, m) to (RA, Dec)\nra, dec = ds.radport.pixel_to_coords(l=0.1, m=0.2)\nprint(f\"RA: {ra:.3f}\u00b0, Dec: {dec:.3f}\u00b0\")\n</code></pre>"},{"location":"getting-started/coordinate-systems/#sky-to-pixel-coordinates","title":"Sky to Pixel Coordinates","text":"<p>Convert RA/Dec to pixel coordinates:</p> <pre><code># Convert (RA, Dec) to (l, m)\nl, m = ds.radport.coords_to_pixel(ra=180.0, dec=20.0)\nprint(f\"l: {l:.3f}, m: {m:.3f}\")\n</code></pre>"},{"location":"getting-started/coordinate-systems/#plotting-with-wcs","title":"Plotting with WCS","text":"<pre><code># Plot with WCS overlay\nds.radport.plot_wcs(\n    time_idx=0,\n    freq_idx=0,\n    projection='rectangular'  # or 'aitoff', 'mollweide'\n)\n</code></pre>"},{"location":"getting-started/coordinate-systems/#indexing-methods","title":"Indexing Methods","text":"<p>The accessor provides helper methods to find nearest indices:</p>"},{"location":"getting-started/coordinate-systems/#nearest-frequency","title":"Nearest Frequency","text":"<pre><code># Find index for frequency closest to 40 MHz\nfreq_idx = ds.radport.nearest_freq_idx(freq_mhz=40.0)\n\n# Use it\nds.radport.plot(freq_idx=freq_idx)\n</code></pre>"},{"location":"getting-started/coordinate-systems/#nearest-time","title":"Nearest Time","text":"<pre><code># Find index for time closest to MJD\ntime_idx = ds.radport.nearest_time_idx(mjd=59000.5)\n\n# Use it\nds.radport.plot(time_idx=time_idx)\n</code></pre>"},{"location":"getting-started/coordinate-systems/#nearest-pixel","title":"Nearest Pixel","text":"<pre><code># Find pixel indices closest to (l, m)\nl_idx, m_idx = ds.radport.nearest_lm_idx(l=0.1, m=0.2)\n\n# Extract light curve at that location\nlc = ds.radport.light_curve(l_idx=l_idx, m_idx=m_idx)\n</code></pre>"},{"location":"getting-started/coordinate-systems/#time-coordinates","title":"Time Coordinates","text":"<p>Time is stored as Modified Julian Date (MJD):</p> <pre><code># Access time coordinates\ntimes = ds.coords['time']\n\n# Convert to datetime if needed\nfrom astropy.time import Time\ntimes_dt = Time(times.values, format='mjd').datetime\n</code></pre>"},{"location":"getting-started/coordinate-systems/#frequency-coordinates","title":"Frequency Coordinates","text":"<p>Frequencies are in Hz:</p> <pre><code># Access frequency coordinates\nfreqs = ds.coords['frequency']\n\n# Convert to MHz for display\nfreqs_mhz = freqs.values / 1e6\n</code></pre>"},{"location":"getting-started/coordinate-systems/#beam-coordinates","title":"Beam Coordinates","text":"<p>Some datasets include beam information:</p> <pre><code># Check for beam\nif ds.radport.has_beam():\n    beam = ds['BEAM']\n    print(f\"Beam shape: {beam.shape}\")\n</code></pre>"},{"location":"getting-started/coordinate-systems/#example-multi-coordinate-analysis","title":"Example: Multi-Coordinate Analysis","text":"<pre><code>import ovro_lwa_portal as ovro\n\nds = ovro.open_dataset(\"path/to/data.zarr\")\n\n# Find indices\nfreq_idx = ds.radport.nearest_freq_idx(freq_mhz=40.0)\ntime_idx = ds.radport.nearest_time_idx(mjd=59000.5)\n\n# Convert sky position to pixels\nl, m = ds.radport.coords_to_pixel(ra=180.0, dec=20.0)\nl_idx, m_idx = ds.radport.nearest_lm_idx(l=l, m=m)\n\n# Extract data at that point\nvalue = ds['SKY'].isel(\n    time=time_idx,\n    frequency=freq_idx,\n    l=l_idx,\n    m=m_idx\n).values\n\nprint(f\"Intensity at RA=180\u00b0, Dec=20\u00b0, 40 MHz: {value:.2f}\")\n</code></pre>"},{"location":"getting-started/coordinate-systems/#next-steps","title":"Next Steps","text":"<ul> <li>Explore visualization methods</li> <li>Learn about WCS coordinates</li> <li>Try the transient analysis tutorial</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>This project uses Pixi for dependency management and task execution. Install Pixi by following the installation instructions.</p>"},{"location":"getting-started/installation/#for-users","title":"For Users","text":"<p>Install the package using pip:</p> <pre><code>pip install git+https://github.com/uw-ssec/ovro-lwa-portal.git\n</code></pre> <p>Or install from a local clone:</p> <pre><code>pip install .\n</code></pre>"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":"<p>For remote data access (S3, GCS, HTTP):</p> <pre><code>pip install 'ovro_lwa_portal[remote]'\n</code></pre> <p>For Prefect workflow orchestration:</p> <pre><code>pip install 'ovro_lwa_portal[prefect]'\n</code></pre>"},{"location":"getting-started/installation/#for-developers","title":"For Developers","text":"<p>For detailed developer setup and workflow instructions, see CONTRIBUTING.md on GitHub.</p>"},{"location":"getting-started/installation/#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/uw-ssec/ovro-lwa-portal.git\ncd ovro-lwa-portal\n</code></pre>"},{"location":"getting-started/installation/#2-install-dependencies","title":"2. Install Dependencies","text":"<p>Install dependencies using Pixi:</p> <pre><code>pixi install\n</code></pre> <p>Pixi will automatically create the environment and install all required dependencies.</p>"},{"location":"getting-started/installation/#3-onboarding","title":"3. Onboarding","text":"<p>For first-time setup, use the onboarding environment to configure your development environment:</p> <pre><code>pixi run -e onboard onboard\n</code></pre> <p>This will:</p> <ul> <li>Install pre-commit hooks in your git repository</li> <li>Set up shell completion for ssec-cli</li> <li>Run the SSEC onboarding process</li> </ul>"},{"location":"getting-started/installation/#4-available-environments","title":"4. Available Environments","text":"<ul> <li><code>default</code>: Standard development environment with pre-commit hooks and   GitHub CLI</li> <li><code>onboard</code>: Extended environment including onboarding tools</li> </ul> <p>Switch between environments as needed:</p> <pre><code># Use default environment\npixi shell\n\n# Use onboard environment\npixi shell -e onboard\n</code></pre>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>Test your installation:</p> <pre><code>import ovro_lwa_portal\nprint(ovro_lwa_portal.__version__)\n</code></pre> <p>Or from the command line:</p> <pre><code>ovro-ingest --help\n</code></pre>"},{"location":"getting-started/loading-data/","title":"Loading Data","text":"<p>The OVRO-LWA Portal provides the <code>open_dataset()</code> function for loading data from various sources.</p>"},{"location":"getting-started/loading-data/#basic-usage","title":"Basic Usage","text":"<pre><code>import ovro_lwa_portal as ovro\n\n# Load from local zarr store\nds = ovro.open_dataset(\"/path/to/observation.zarr\")\n</code></pre> <p>Once loaded, the dataset has a <code>radport</code> accessor providing over 40 analysis methods.</p>"},{"location":"getting-started/loading-data/#supported-data-sources","title":"Supported Data Sources","text":""},{"location":"getting-started/loading-data/#local-files","title":"Local Files","text":"<pre><code>ds = ovro.open_dataset(\"/path/to/observation.zarr\")\n</code></pre>"},{"location":"getting-started/loading-data/#remote-urls","title":"Remote URLs","text":""},{"location":"getting-started/loading-data/#s3-amazon-web-services","title":"S3 (Amazon Web Services)","text":"<pre><code>ds = ovro.open_dataset(\"s3://bucket-name/observation.zarr\")\n</code></pre>"},{"location":"getting-started/loading-data/#https","title":"HTTPS","text":"<pre><code>ds = ovro.open_dataset(\"https://example.com/data.zarr\")\n</code></pre>"},{"location":"getting-started/loading-data/#doi-based-access","title":"DOI-based Access","text":"<pre><code>ds = ovro.open_dataset(\"doi:10.5281/zenodo.1234567\")\n</code></pre>"},{"location":"getting-started/loading-data/#chunking","title":"Chunking","text":"<p>Control memory usage with chunking:</p> <pre><code># Automatic chunking (default)\nds = ovro.open_dataset(\"path/to/data.zarr\", chunks=\"auto\")\n\n# Custom chunking\nds = ovro.open_dataset(\n    \"path/to/data.zarr\",\n    chunks={\"time\": 100, \"frequency\": 50}\n)\n\n# No chunking (caution: loads all data into memory)\nds = ovro.open_dataset(\"path/to/data.zarr\", chunks=None)\n</code></pre>"},{"location":"getting-started/loading-data/#dataset-structure","title":"Dataset Structure","text":"<p>OVRO-LWA datasets typically contain:</p> <ul> <li>Dimensions: <code>time</code>, <code>frequency</code>, <code>l</code>, <code>m</code> (and optionally <code>beam</code>)</li> <li>Coordinates: Time stamps, frequency channels, sky coordinates</li> <li>Data Variables: <code>intensity</code>, <code>SKY</code>, <code>BEAM</code>, etc.</li> <li>Attributes: Observation metadata</li> </ul>"},{"location":"getting-started/loading-data/#accessing-the-radport-accessor","title":"Accessing the radport Accessor","text":"<p>After loading, use the <code>.radport</code> accessor for analysis:</p> <pre><code>ds = ovro.open_dataset(\"path/to/data.zarr\")\n\n# The radport accessor is now available\nds.radport.plot()\nds.radport.dynamic_spectrum()\nds.radport.find_peaks()\n</code></pre> <p>See the API Reference for all available methods.</p>"},{"location":"getting-started/loading-data/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about basic plotting</li> <li>Understand coordinate systems</li> <li>Explore visualization methods</li> </ul>"},{"location":"tutorials/pulsar-dedispersion/","title":"Pulsar Dedispersion Tutorial","text":"<p>This tutorial demonstrates how to detect and analyze pulsars in OVRO-LWA data using the Crab pulsar (B0531+21, DM \u2248 56.7 pc cm\u207b\u00b3) as the example target. You will learn how to apply incoherent dedispersion, optimize the dispersion measure, and fold the data at the pulsar period.</p>"},{"location":"tutorials/pulsar-dedispersion/#background","title":"Background","text":"<p>Radio pulses traveling through the ionized interstellar medium (ISM) experience a frequency-dependent delay described by:</p> \\[ \\Delta t = 4.15 \\times 10^{3} \\, \\text{ms} \\times \\text{DM} \\times \\left( f_{\\text{low}}^{-2} - f_{\\text{high}}^{-2} \\right) \\] <p>where DM (dispersion measure) is the integrated electron column density in pc cm\u207b\u00b3 and f is frequency in MHz. Lower frequencies arrive later, causing a characteristic diagonal sweep in the dynamic spectrum.</p>"},{"location":"tutorials/pulsar-dedispersion/#prerequisites","title":"Prerequisites","text":"<pre><code>import ovro_lwa_portal as ovro\nimport numpy as np\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"tutorials/pulsar-dedispersion/#step-1-load-data-and-locate-the-pulsar","title":"Step 1: Load Data and Locate the Pulsar","text":"<pre><code>ds = ovro.open_dataset(\"path/to/crab_data.zarr\")\n\n# Check available frequencies\nfreqs_mhz = ds.coords[\"frequency\"].values / 1e6\nprint(f\"Frequency range: {freqs_mhz.min():.1f} \u2013 {freqs_mhz.max():.1f} MHz\")\nprint(f\"Number of time steps: {ds.sizes['time']}\")\n</code></pre> <p>Locate the Crab pulsar. If WCS coordinates are available, use RA/Dec:</p> <pre><code>if ds.radport.has_wcs:\n    # Crab Nebula: RA = 83.633\u00b0, Dec = 22.014\u00b0\n    l_idx, m_idx = ds.radport.coords_to_pixel(ra=83.633, dec=22.014)\n    print(f\"Crab pulsar at pixel: l={l_idx}, m={m_idx}\")\nelse:\n    # Fall back to the image center or a known pixel position\n    l_idx = ds.sizes[\"l\"] // 2\n    m_idx = ds.sizes[\"m\"] // 2\n    print(f\"Using image center: l={l_idx}, m={m_idx}\")\n</code></pre>"},{"location":"tutorials/pulsar-dedispersion/#step-2-view-the-dispersed-dynamic-spectrum","title":"Step 2: View the Dispersed Dynamic Spectrum","text":"<p>Extract and plot the dynamic spectrum at the pulsar position:</p> <pre><code>l_val = float(ds.coords[\"l\"].values[l_idx])\nm_val = float(ds.coords[\"m\"].values[m_idx])\n\ndyn = ds.radport.dynamic_spectrum(l=l_val, m=m_val)\nds.radport.plot_dynamic_spectrum(dyn)\nplt.title(\"Before Dedispersion\")\nplt.show()\n</code></pre> <p>You should see the characteristic diagonal sweep: low-frequency emission arriving later than high-frequency emission.</p>"},{"location":"tutorials/pulsar-dedispersion/#step-3-incoherent-dedispersion","title":"Step 3: Incoherent Dedispersion","text":"<p>Incoherent dedispersion corrects the dispersion delay by shifting each frequency channel in time. Define the dedispersion function:</p> <pre><code>def dedisperse_incoherent(ds, dm, ref_freq_mhz=None):\n    \"\"\"Apply incoherent dedispersion to a dataset.\n\n    Parameters\n    ----------\n    ds : xarray.Dataset\n        Input dataset.\n    dm : float\n        Dispersion measure in pc cm\u207b\u00b3.\n    ref_freq_mhz : float, optional\n        Reference frequency in MHz. Defaults to the highest frequency.\n\n    Returns\n    -------\n    xarray.Dataset\n        Dedispersed dataset.\n    \"\"\"\n    freqs_hz = ds.coords[\"frequency\"].values\n    freqs_mhz = freqs_hz / 1e6\n\n    if ref_freq_mhz is None:\n        ref_freq_mhz = freqs_mhz.max()\n\n    # Time delay at each frequency relative to the reference\n    delays_ms = 4.15e3 * dm * (freqs_mhz**-2 - ref_freq_mhz**-2)\n\n    # Convert delays to integer sample shifts\n    time_vals = ds.coords[\"time\"].values\n    dt_days = np.median(np.diff(time_vals))\n    dt_ms = dt_days * 86400 * 1000\n    delays_samples = np.round(delays_ms / dt_ms).astype(int)\n\n    # Apply circular shifts per frequency channel\n    dedispersed = ds.copy()\n    for freq_idx, shift in enumerate(delays_samples):\n        if shift != 0:\n            dedispersed[\"SKY\"][:, freq_idx, :, :] = np.roll(\n                ds[\"SKY\"][:, freq_idx, :, :].values,\n                shift=-shift,\n                axis=0,\n            )\n\n    return dedispersed\n</code></pre>"},{"location":"tutorials/pulsar-dedispersion/#step-4-apply-known-dm","title":"Step 4: Apply Known DM","text":"<p>Apply the Crab pulsar's known DM:</p> <pre><code>ds_dd = dedisperse_incoherent(ds, dm=56.7)\n</code></pre> <p>Compare before and after:</p> <pre><code>fig, axes = plt.subplots(1, 2, figsize=(14, 5))\n\n# Before\ndyn_before = ds.radport.dynamic_spectrum(l=l_val, m=m_val)\nds.radport.plot_dynamic_spectrum(dyn_before, ax=axes[0])\naxes[0].set_title(\"Before Dedispersion\")\n\n# After\ndyn_after = ds_dd.radport.dynamic_spectrum(l=l_val, m=m_val)\nds_dd.radport.plot_dynamic_spectrum(dyn_after, ax=axes[1])\naxes[1].set_title(\"After Dedispersion (DM = 56.7)\")\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p>After dedispersion, pulses should align vertically across all frequencies.</p>"},{"location":"tutorials/pulsar-dedispersion/#step-5-dm-optimization","title":"Step 5: DM Optimization","text":"<p>When the DM is not known precisely, search for the value that maximizes the signal-to-noise ratio of the dedispersed pulse:</p> <pre><code>def optimize_dm(ds, l_idx, m_idx, dm_range):\n    \"\"\"Find the optimal DM by maximizing peak SNR.\n\n    Parameters\n    ----------\n    ds : xarray.Dataset\n        Input dataset.\n    l_idx, m_idx : int\n        Spatial pixel indices of the source.\n    dm_range : array-like\n        DM values to test in pc cm\u207b\u00b3.\n\n    Returns\n    -------\n    tuple\n        (best_dm, snr_array)\n    \"\"\"\n    l_val = float(ds.coords[\"l\"].values[l_idx])\n    m_val = float(ds.coords[\"m\"].values[m_idx])\n    snrs = []\n\n    for dm in dm_range:\n        ds_dd = dedisperse_incoherent(ds, dm=dm)\n        lc = ds_dd.radport.light_curve(l=l_val, m=m_val)\n\n        mean_val = float(lc.mean().values)\n        std_val = float(lc.std().values)\n        max_val = float(lc.max().values)\n\n        snr = (max_val - mean_val) / std_val if std_val &gt; 0 else 0\n        snrs.append(snr)\n\n    best_idx = np.argmax(snrs)\n    return dm_range[best_idx], np.array(snrs)\n</code></pre> <p>Run the optimization around the expected DM:</p> <pre><code>dm_range = np.linspace(50, 65, 30)\nbest_dm, snrs = optimize_dm(ds, l_idx, m_idx, dm_range)\n\nprint(f\"Optimal DM: {best_dm:.1f} pc cm\u207b\u00b3\")\n\nplt.figure(figsize=(10, 5))\nplt.plot(dm_range, snrs, \"o-\")\nplt.axvline(best_dm, color=\"red\", linestyle=\"--\", label=f\"Best DM = {best_dm:.1f}\")\nplt.xlabel(\"Dispersion Measure (pc cm\u207b\u00b3)\")\nplt.ylabel(\"Peak SNR\")\nplt.title(\"DM Optimization\")\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.show()\n</code></pre>"},{"location":"tutorials/pulsar-dedispersion/#step-6-pulse-profile-folding","title":"Step 6: Pulse Profile Folding","text":"<p>Fold the dedispersed light curve at the known pulsar period to build an averaged pulse profile. The Crab pulsar has a period of approximately 33 ms.</p> <pre><code>def fold_pulsar(ds, l_idx, m_idx, period_s, dm=None, n_bins=50):\n    \"\"\"Fold a light curve at a known pulsar period.\n\n    Parameters\n    ----------\n    ds : xarray.Dataset\n        Input dataset.\n    l_idx, m_idx : int\n        Spatial pixel indices.\n    period_s : float\n        Pulsar period in seconds.\n    dm : float, optional\n        If provided, dedisperse before folding.\n    n_bins : int\n        Number of phase bins.\n\n    Returns\n    -------\n    tuple\n        (phase_centers, profile)\n    \"\"\"\n    if dm is not None:\n        ds = dedisperse_incoherent(ds, dm=dm)\n\n    l_val = float(ds.coords[\"l\"].values[l_idx])\n    m_val = float(ds.coords[\"m\"].values[m_idx])\n    lc = ds.radport.light_curve(l=l_val, m=m_val)\n\n    # Convert MJD times to seconds\n    times_s = ds.coords[\"time\"].values * 86400\n\n    # Compute pulse phase\n    phase = (times_s % period_s) / period_s\n\n    # Bin by phase\n    phase_bins = np.linspace(0, 1, n_bins + 1)\n    profile = np.zeros(n_bins)\n    for i in range(n_bins):\n        mask = (phase &gt;= phase_bins[i]) &amp; (phase &lt; phase_bins[i + 1])\n        if mask.any():\n            profile[i] = float(lc.values[mask].mean())\n\n    phase_centers = 0.5 * (phase_bins[:-1] + phase_bins[1:])\n    return phase_centers, profile\n</code></pre> <p>Apply it to the Crab pulsar:</p> <pre><code>phase, profile = fold_pulsar(ds, l_idx, m_idx, period_s=0.033, dm=56.7)\n\nplt.figure(figsize=(10, 5))\nplt.plot(phase, profile, \"o-\")\nplt.xlabel(\"Pulse Phase\")\nplt.ylabel(\"Intensity\")\nplt.title(\"Folded Crab Pulse Profile (P \u2248 33 ms, DM \u2248 56.7)\")\nplt.grid(True, alpha=0.3)\nplt.show()\n</code></pre>"},{"location":"tutorials/pulsar-dedispersion/#step-7-publication-quality-summary-figure","title":"Step 7: Publication-Quality Summary Figure","text":"<p>Combine all results into a single multi-panel figure:</p> <pre><code>fig, axes = plt.subplots(2, 2, figsize=(14, 10))\n\n# Panel 1: Dispersed dynamic spectrum\ndyn_before = ds.radport.dynamic_spectrum(l=l_val, m=m_val)\nds.radport.plot_dynamic_spectrum(dyn_before, ax=axes[0, 0])\naxes[0, 0].set_title(\"(a) Dispersed\")\n\n# Panel 2: Dedispersed dynamic spectrum\nds_dd = dedisperse_incoherent(ds, dm=best_dm)\ndyn_after = ds_dd.radport.dynamic_spectrum(l=l_val, m=m_val)\nds_dd.radport.plot_dynamic_spectrum(dyn_after, ax=axes[0, 1])\naxes[0, 1].set_title(f\"(b) Dedispersed (DM = {best_dm:.1f})\")\n\n# Panel 3: DM optimization curve\naxes[1, 0].plot(dm_range, snrs, \"o-\")\naxes[1, 0].axvline(best_dm, color=\"red\", linestyle=\"--\")\naxes[1, 0].set_xlabel(\"DM (pc cm\u207b\u00b3)\")\naxes[1, 0].set_ylabel(\"Peak SNR\")\naxes[1, 0].set_title(\"(c) DM Optimization\")\naxes[1, 0].grid(True, alpha=0.3)\n\n# Panel 4: Folded pulse profile\nphase, profile = fold_pulsar(ds, l_idx, m_idx, period_s=0.033, dm=best_dm)\naxes[1, 1].plot(phase, profile, \"o-\")\naxes[1, 1].set_xlabel(\"Pulse Phase\")\naxes[1, 1].set_ylabel(\"Intensity\")\naxes[1, 1].set_title(\"(d) Folded Pulse Profile\")\naxes[1, 1].grid(True, alpha=0.3)\n\nplt.suptitle(\"Crab Pulsar Analysis\", fontsize=14, y=1.02)\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"tutorials/pulsar-dedispersion/#summary","title":"Summary","text":"<p>This tutorial covered:</p> <ol> <li>Locating a pulsar in the image (pixel or WCS coordinates)</li> <li>Viewing the dispersed dynamic spectrum</li> <li>Implementing incoherent dedispersion</li> <li>Applying a known DM and comparing before/after</li> <li>Optimizing DM by maximizing peak SNR</li> <li>Folding the dedispersed light curve at the pulsar period</li> </ol>"},{"location":"tutorials/pulsar-dedispersion/#next-steps","title":"Next Steps","text":"<ul> <li>Dispersion Measure Correction Guide --   FRB search and advanced DM techniques</li> <li>Transient Analysis Tutorial -- Detecting transient   sources</li> <li>Spectral Mapping Tutorial -- Spectral properties of   sources</li> <li>API Reference -- Full method documentation</li> </ul>"},{"location":"tutorials/spectral-mapping/","title":"Spectral Mapping Tutorial","text":"<p>This tutorial demonstrates how to create spectral index maps, build spectral energy distributions (SEDs), fit power laws, and classify radio sources by their spectral properties using the <code>radport</code> accessor.</p>"},{"location":"tutorials/spectral-mapping/#background","title":"Background","text":"<p>The spectral index \u03b1 describes how a source's flux density S varies with frequency \u03bd:</p> \\[ S \\propto \\nu^{\\alpha} \\] <p>Typical spectral index values at low radio frequencies:</p> \u03b1 Interpretation Examples \u2248 \u22120.7 Optically-thin synchrotron Most AGN, supernova remnants \u2248 0 Flat spectrum Compact quasar cores &gt; 0 Inverted / self-absorbed Gigahertz-peaked sources &lt; \u22121 Ultra-steep spectrum Aged electron populations, high-z radio galaxies"},{"location":"tutorials/spectral-mapping/#prerequisites","title":"Prerequisites","text":"<pre><code>import ovro_lwa_portal as ovro\nimport numpy as np\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"tutorials/spectral-mapping/#step-1-load-data-and-inspect-frequencies","title":"Step 1: Load Data and Inspect Frequencies","text":"<pre><code>ds = ovro.open_dataset(\"path/to/data.zarr\")\n\nfreqs_mhz = ds.coords[\"frequency\"].values / 1e6\nprint(f\"Frequency range: {freqs_mhz.min():.1f} \u2013 {freqs_mhz.max():.1f} MHz\")\nprint(f\"Number of channels: {len(freqs_mhz)}\")\n</code></pre> <p>Visualize the field at the lowest and highest frequencies:</p> <pre><code>fig, axes = plt.subplots(1, 2, figsize=(14, 6))\n\nds.radport.plot(time_idx=0, freq_idx=0, ax=axes[0])\naxes[0].set_title(f\"{freqs_mhz[0]:.1f} MHz\")\n\nds.radport.plot(time_idx=0, freq_idx=-1, ax=axes[1])\naxes[1].set_title(f\"{freqs_mhz[-1]:.1f} MHz\")\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"tutorials/spectral-mapping/#step-2-create-a-spectral-index-map","title":"Step 2: Create a Spectral Index Map","text":"<p>Compute \u03b1 between the lowest and highest frequency channels:</p> <pre><code>alpha_map = ds.radport.spectral_index_map(\n    freq_idx1=0,\n    freq_idx2=len(freqs_mhz) - 1,\n    time_idx=0,\n)\n\nds.radport.plot_spectral_index_map(\n    alpha_map,\n    vmin=-2,\n    vmax=2,\n    cmap=\"RdBu_r\",\n)\nplt.title(f\"Spectral Index ({freqs_mhz[0]:.0f}\u2013{freqs_mhz[-1]:.0f} MHz)\")\nplt.show()\n</code></pre> <p>Blue regions indicate steep-spectrum sources (\u03b1 &lt; 0) while red indicates flat or inverted spectra (\u03b1 \u2265 0).</p>"},{"location":"tutorials/spectral-mapping/#step-3-detect-sources-and-measure-spectral-indices","title":"Step 3: Detect Sources and Measure Spectral Indices","text":"<p>Combine source detection with spectral index measurement:</p> <pre><code># Detect sources at the lowest frequency\npeaks = ds.radport.find_peaks(time_idx=0, freq_idx=0, threshold=5.0)\nprint(f\"Detected {len(peaks)} sources\")\n\n# Measure spectral index at each peak\ncatalog = []\nfor l_idx, m_idx in peaks:\n    alpha = ds.radport.spectral_index(\n        freq_idx1=0,\n        freq_idx2=len(freqs_mhz) - 1,\n        l_idx=l_idx,\n        m_idx=m_idx,\n    )\n    catalog.append({\n        \"l_idx\": l_idx,\n        \"m_idx\": m_idx,\n        \"spectral_index\": alpha,\n    })\n\n# Print top results\ncatalog.sort(key=lambda x: x[\"spectral_index\"])\nprint(\"\\nSteepest-spectrum sources:\")\nfor src in catalog[:5]:\n    print(f\"  l={src['l_idx']}, m={src['m_idx']}: \u03b1 = {src['spectral_index']:.2f}\")\n</code></pre>"},{"location":"tutorials/spectral-mapping/#step-4-build-a-spectral-energy-distribution","title":"Step 4: Build a Spectral Energy Distribution","text":"<p>Extract flux density at every frequency channel for a single source:</p> <pre><code># Pick the brightest source\nsrc = catalog[0]\nl_idx, m_idx = src[\"l_idx\"], src[\"m_idx\"]\n\nflux_values = []\nfor fi in range(len(freqs_mhz)):\n    flux = ds.radport.integrated_flux(\n        time_idx=0,\n        freq_idx=fi,\n        l_min=l_idx - 2,\n        l_max=l_idx + 2,\n        m_min=m_idx - 2,\n        m_max=m_idx + 2,\n    )\n    flux_values.append(flux)\n\nflux_values = np.array(flux_values)\n\n# Plot the SED\nplt.figure(figsize=(10, 6))\nplt.loglog(freqs_mhz, flux_values, \"o-\", color=\"steelblue\")\nplt.xlabel(\"Frequency (MHz)\")\nplt.ylabel(\"Flux Density (Jy)\")\nplt.title(f\"SED for source at l={l_idx}, m={m_idx}\")\nplt.grid(True, alpha=0.3, which=\"both\")\nplt.show()\n</code></pre>"},{"location":"tutorials/spectral-mapping/#step-5-power-law-fitting","title":"Step 5: Power-Law Fitting","text":"<p>Fit a power law S = A (\u03bd / \u03bd\u2080)^\u03b1 to the SED:</p> <pre><code>from scipy.optimize import curve_fit\n\ndef power_law(freq, amplitude, alpha, freq0=40.0):\n    \"\"\"Power-law spectral model.\"\"\"\n    return amplitude * (freq / freq0) ** alpha\n\n# Filter out non-positive flux values for log fitting\nvalid = flux_values &gt; 0\nfreqs_valid = freqs_mhz[valid]\nflux_valid = flux_values[valid]\n\npopt, pcov = curve_fit(power_law, freqs_valid, flux_valid, p0=[1.0, -0.7])\namplitude, alpha_fit = popt\nalpha_err = np.sqrt(np.diag(pcov))[1]\n\nprint(f\"Fitted spectral index: \u03b1 = {alpha_fit:.2f} \u00b1 {alpha_err:.2f}\")\nprint(f\"Amplitude at 40 MHz:   A = {amplitude:.3e} Jy\")\n\n# Overlay fit on SED\nplt.figure(figsize=(10, 6))\nplt.loglog(freqs_valid, flux_valid, \"o\", label=\"Data\")\n\nfreq_fit = np.linspace(freqs_valid.min(), freqs_valid.max(), 100)\nplt.loglog(freq_fit, power_law(freq_fit, *popt), \"-\",\n           label=f\"Fit: \u03b1 = {alpha_fit:.2f}\")\n\nplt.xlabel(\"Frequency (MHz)\")\nplt.ylabel(\"Flux Density (Jy)\")\nplt.title(\"Power-Law Fit\")\nplt.legend()\nplt.grid(True, alpha=0.3, which=\"both\")\nplt.show()\n</code></pre>"},{"location":"tutorials/spectral-mapping/#step-6-multi-frequency-spectral-index-maps","title":"Step 6: Multi-Frequency Spectral Index Maps","text":"<p>Track how the spectral index varies across different frequency pairs:</p> <pre><code>n_freq = len(freqs_mhz)\npairs = [(0, n_freq // 3), (n_freq // 3, 2 * n_freq // 3), (2 * n_freq // 3, n_freq - 1)]\n\nfig, axes = plt.subplots(1, len(pairs), figsize=(5 * len(pairs), 5))\n\nfor ax, (f1, f2) in zip(axes, pairs):\n    alpha_map = ds.radport.spectral_index_map(\n        freq_idx1=f1,\n        freq_idx2=f2,\n        time_idx=0,\n    )\n    ds.radport.plot_spectral_index_map(alpha_map, ax=ax, vmin=-2, vmax=2, cmap=\"RdBu_r\")\n    ax.set_title(f\"{freqs_mhz[f1]:.0f}\u2013{freqs_mhz[f2]:.0f} MHz\")\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p>Differences between panels indicate spectral curvature \u2014 the spectral index is not constant across the band.</p>"},{"location":"tutorials/spectral-mapping/#step-7-source-classification","title":"Step 7: Source Classification","text":"<p>Classify detected sources by spectral index:</p> <pre><code>steep = [s for s in catalog if s[\"spectral_index\"] &lt; -1.0]\nnormal = [s for s in catalog if -1.0 &lt;= s[\"spectral_index\"] &lt; -0.3]\nflat = [s for s in catalog if -0.3 &lt;= s[\"spectral_index\"] &lt;= 0.3]\ninverted = [s for s in catalog if s[\"spectral_index\"] &gt; 0.3]\n\nprint(f\"Ultra-steep (\u03b1 &lt; -1.0):  {len(steep)}\")\nprint(f\"Normal (\u22121.0 \u2264 \u03b1 &lt; \u22120.3): {len(normal)}\")\nprint(f\"Flat (\u22120.3 \u2264 \u03b1 \u2264 0.3):   {len(flat)}\")\nprint(f\"Inverted (\u03b1 &gt; 0.3):      {len(inverted)}\")\n</code></pre> <p>Visualize the classification on the sky:</p> <pre><code>ds.radport.plot(time_idx=0, freq_idx=0)\nax = plt.gca()\n\ncolors = {\"steep\": \"blue\", \"normal\": \"green\", \"flat\": \"orange\", \"inverted\": \"red\"}\nfor label, sources, color in [\n    (\"steep\", steep, \"blue\"),\n    (\"normal\", normal, \"green\"),\n    (\"flat\", flat, \"orange\"),\n    (\"inverted\", inverted, \"red\"),\n]:\n    if sources:\n        ls, ms = zip(*[(s[\"l_idx\"], s[\"m_idx\"]) for s in sources])\n        ax.scatter(ls, ms, c=color, s=100, marker=\"o\", edgecolors=\"white\",\n                   linewidths=0.5, label=f\"{label} ({len(sources)})\")\n\nax.legend(loc=\"upper right\")\nplt.title(\"Source Classification by Spectral Index\")\nplt.show()\n</code></pre>"},{"location":"tutorials/spectral-mapping/#summary","title":"Summary","text":"<p>This tutorial covered:</p> <ol> <li>Creating spectral index maps between frequency pairs</li> <li>Detecting sources and measuring their spectral indices</li> <li>Building spectral energy distributions (SEDs)</li> <li>Fitting power-law models to SED data</li> <li>Examining spectral curvature across the band</li> <li>Classifying sources by spectral type</li> </ol>"},{"location":"tutorials/spectral-mapping/#next-steps","title":"Next Steps","text":"<ul> <li>Spectral Analysis Guide -- Frequency   averaging, spectral variability</li> <li>Source Detection Guide -- Advanced   detection methods</li> <li>Transient Analysis Tutorial -- Time-domain analysis</li> <li>API Reference -- Full method documentation</li> </ul>"},{"location":"tutorials/transient-analysis/","title":"Transient Analysis Tutorial","text":"<p>This tutorial walks through an end-to-end workflow for detecting and characterizing transient radio sources in OVRO-LWA data, covering data loading, reference image creation, difference imaging, source detection, and light curve analysis.</p>"},{"location":"tutorials/transient-analysis/#prerequisites","title":"Prerequisites","text":"<pre><code>import ovro_lwa_portal as ovro\nimport numpy as np\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"tutorials/transient-analysis/#step-1-load-and-inspect-the-data","title":"Step 1: Load and Inspect the Data","text":"<pre><code>ds = ovro.open_dataset(\"path/to/data.zarr\")\n\n# Check dimensions\nprint(ds)\nprint(f\"Time steps:  {ds.sizes['time']}\")\nprint(f\"Frequencies: {ds.sizes['frequency']}\")\nprint(f\"Image size:  {ds.sizes['l']} x {ds.sizes['m']}\")\n\n# Verify data quality at the first frame\nfraction = ds.radport.finite_fraction(time_idx=0, freq_idx=0)\nprint(f\"Valid data fraction: {fraction * 100:.1f}%\")\n</code></pre> <p>Pick a frequency to work with throughout the tutorial:</p> <pre><code>freqs_mhz = ds.coords[\"frequency\"].values / 1e6\nprint(f\"Available frequencies: {freqs_mhz} MHz\")\n\n# Choose a frequency\nfreq_idx = ds.radport.nearest_freq_idx(50.0)\nprint(f\"Using freq_idx={freq_idx} ({freqs_mhz[freq_idx]:.1f} MHz)\")\n</code></pre>"},{"location":"tutorials/transient-analysis/#step-2-create-a-reference-image","title":"Step 2: Create a Reference Image","text":"<p>A time-averaged image serves as the quiescent baseline. Sources that appear only in individual frames (but not in the average) are transient candidates.</p> <pre><code># Average over all time steps\nref = ds.radport.time_average()\n\n# Visualize the reference at our chosen frequency\nds.radport.plot_time_average(ref, freq_idx=freq_idx)\nplt.title(\"Time-Averaged Reference Image\")\nplt.show()\n</code></pre>"},{"location":"tutorials/transient-analysis/#step-3-browse-individual-frames","title":"Step 3: Browse Individual Frames","text":"<p>Scan through a few frames to see if anything stands out:</p> <pre><code>fig, axes = plt.subplots(1, 3, figsize=(15, 5))\n\nfor ax, t_idx in zip(axes, [0, 50, 100]):\n    ds.radport.plot(time_idx=t_idx, freq_idx=freq_idx, ax=ax)\n    ax.set_title(f\"t={t_idx}\")\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"tutorials/transient-analysis/#step-4-difference-imaging","title":"Step 4: Difference Imaging","text":"<p>Subtract the reference to isolate time-variable emission:</p> <pre><code># Use the built-in diff method\nfig = ds.radport.plot_diff(mode=\"time\", time_idx=50, freq_idx=freq_idx)\nplt.title(\"Difference Image (frame 50 \u2212 average)\")\nplt.show()\n</code></pre> <p>You can also compute the difference manually for more control:</p> <pre><code>current = ds[\"SKY\"].isel(time=50, frequency=freq_idx, polarization=0).values\nreference = ref.isel(frequency=freq_idx, polarization=0).values\n\ndiff = current - reference\n\nplt.figure(figsize=(8, 8))\nplt.imshow(diff, origin=\"lower\", cmap=\"RdBu_r\")\nplt.colorbar(label=\"Flux Difference (Jy)\")\nplt.title(\"Manual Difference Image\")\nplt.show()\n</code></pre> <p>Red/blue spots indicate brightening/fading relative to the mean.</p>"},{"location":"tutorials/transient-analysis/#step-5-source-detection-with-snr-maps","title":"Step 5: Source Detection with SNR Maps","text":"<p>Quantify significance using a signal-to-noise map:</p> <pre><code># SNR map at a specific frame\nsnr = ds.radport.snr_map(time_idx=50, freq_idx=freq_idx)\nds.radport.plot_snr_map(snr, vmin=0, vmax=10, cmap=\"hot\")\nplt.title(\"SNR Map\")\nplt.show()\n</code></pre> <p>Find peaks above a detection threshold:</p> <pre><code>peaks = ds.radport.find_peaks(\n    time_idx=50,\n    freq_idx=freq_idx,\n    threshold=5.0,\n)\nprint(f\"Detected {len(peaks)} sources above SNR=5\")\n</code></pre> <p>Overlay detections on the sky image:</p> <pre><code>ds.radport.plot(time_idx=50, freq_idx=freq_idx)\nax = plt.gca()\n\nif len(peaks) &gt; 0:\n    l_coords, m_coords = zip(*peaks)\n    ax.scatter(\n        l_coords, m_coords,\n        marker=\"o\", facecolors=\"none\", edgecolors=\"red\",\n        s=200, linewidths=2, label=f\"{len(peaks)} detections\",\n    )\n    ax.legend()\n\nplt.show()\n</code></pre>"},{"location":"tutorials/transient-analysis/#step-6-extract-light-curves","title":"Step 6: Extract Light Curves","text":"<p>For each candidate, extract a light curve to check for time variability:</p> <pre><code>fig, axes = plt.subplots(min(len(peaks), 3), 1, figsize=(10, 8), sharex=True)\nif not hasattr(axes, \"__iter__\"):\n    axes = [axes]\n\nfor ax, (l_idx, m_idx) in zip(axes, peaks[:3]):\n    l_val = float(ds.coords[\"l\"].values[l_idx])\n    m_val = float(ds.coords[\"m\"].values[m_idx])\n\n    lc = ds.radport.light_curve(l=l_val, m=m_val)\n    ds.radport.plot_light_curve(lc, ax=ax)\n    ax.set_title(f\"Source at l={l_val:.3f}, m={m_val:.3f}\")\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"tutorials/transient-analysis/#step-7-dynamic-spectrum-analysis","title":"Step 7: Dynamic Spectrum Analysis","text":"<p>Inspect the frequency-time structure of a candidate:</p> <pre><code>l_val = float(ds.coords[\"l\"].values[peaks[0][0]])\nm_val = float(ds.coords[\"m\"].values[peaks[0][1]])\n\ndyn = ds.radport.dynamic_spectrum(l=l_val, m=m_val)\nds.radport.plot_dynamic_spectrum(dyn)\nplt.title(\"Dynamic Spectrum of Candidate 0\")\nplt.show()\n</code></pre> <p>A broadband brightening across all frequencies suggests an astrophysical transient, while narrow-band features may indicate radio frequency interference (RFI).</p>"},{"location":"tutorials/transient-analysis/#step-8-variability-classification","title":"Step 8: Variability Classification","text":"<p>Compute a variability index (standard deviation / mean) to rank candidates:</p> <pre><code>variability = []\n\nfor l_idx, m_idx in peaks:\n    l_val = float(ds.coords[\"l\"].values[l_idx])\n    m_val = float(ds.coords[\"m\"].values[m_idx])\n\n    lc = ds.radport.light_curve(l=l_val, m=m_val)\n    mean_val = float(lc.mean().values)\n    std_val = float(lc.std().values)\n\n    v_idx = std_val / mean_val if mean_val &gt; 0 else 0.0\n    variability.append({\n        \"l_idx\": l_idx, \"m_idx\": m_idx,\n        \"mean_flux\": mean_val, \"variability\": v_idx,\n    })\n\n# Sort by variability\nvariability.sort(key=lambda x: x[\"variability\"], reverse=True)\n\nprint(\"Top variable sources:\")\nfor v in variability[:5]:\n    print(f\"  l={v['l_idx']}, m={v['m_idx']}: \"\n          f\"V={v['variability']:.2f}, mean={v['mean_flux']:.3e}\")\n</code></pre> <p>!!! tip A variability index above ~0.5 is a strong indicator of genuine time-variable emission, though the exact threshold depends on your noise level.</p>"},{"location":"tutorials/transient-analysis/#step-9-multi-frequency-confirmation","title":"Step 9: Multi-Frequency Confirmation","text":"<p>Confirm that candidates appear at multiple frequencies to rule out instrumental artifacts:</p> <pre><code>freq_indices = list(range(ds.sizes[\"frequency\"]))\n\nconfirmed = []\nfor src in variability[:5]:\n    detections = 0\n    for fi in freq_indices:\n        snr_map = ds.radport.snr_map(time_idx=50, freq_idx=fi)\n        if snr_map[src[\"m_idx\"], src[\"l_idx\"]] &gt; 5.0:\n            detections += 1\n\n    frac = detections / len(freq_indices)\n    print(f\"Source l={src['l_idx']}, m={src['m_idx']}: \"\n          f\"detected in {detections}/{len(freq_indices)} bands ({frac:.0%})\")\n\n    if frac &gt;= 0.5:\n        confirmed.append(src)\n\nprint(f\"\\n{len(confirmed)} sources confirmed across \u226550% of frequency bands\")\n</code></pre>"},{"location":"tutorials/transient-analysis/#summary","title":"Summary","text":"<p>This tutorial covered:</p> <ol> <li>Loading data and checking quality</li> <li>Creating a time-averaged reference image</li> <li>Difference imaging to isolate transients</li> <li>SNR-based source detection</li> <li>Light curve extraction and dynamic spectrum analysis</li> <li>Variability classification and multi-frequency confirmation</li> </ol>"},{"location":"tutorials/transient-analysis/#next-steps","title":"Next Steps","text":"<ul> <li>Pulsar Dedispersion Tutorial -- Analyze dispersed   pulsars</li> <li>Spectral Mapping Tutorial -- Map spectral properties</li> <li>Source Detection Guide -- Detailed   detection methods</li> <li>API Reference -- Full method documentation</li> </ul>"},{"location":"user-guide/animations/","title":"Animations","text":"<p>The <code>radport</code> accessor provides methods for creating animations of time-series and frequency data.</p>"},{"location":"user-guide/animations/#time-animation","title":"Time Animation","text":"<p>Animate data evolution over time:</p> <pre><code>import ovro_lwa_portal as ovro\n\nds = ovro.open_dataset(\"path/to/data.zarr\")\n\n# Create animation over time at a fixed frequency\nanim = ds.radport.animate_time(\n    freq_idx=10,\n    interval=100,  # milliseconds between frames\n    cmap='viridis',\n    norm='log'\n)\n\n# Display in Jupyter\nfrom IPython.display import HTML\nHTML(anim.to_jshtml())\n\n# Or save to file\nanim.save('time_evolution.mp4', writer='ffmpeg', fps=10)\n</code></pre>"},{"location":"user-guide/animations/#customizing-time-animations","title":"Customizing Time Animations","text":"<pre><code># Specify time range\nanim = ds.radport.animate_time(\n    freq_idx=10,\n    time_min=0,\n    time_max=100,\n    interval=50,\n    cmap='plasma',\n    figsize=(10, 8)\n)\n</code></pre>"},{"location":"user-guide/animations/#adding-markers","title":"Adding Markers","text":"<p>Overlay markers for tracked sources:</p> <pre><code>import matplotlib.pyplot as plt\n\n# Detect sources in first frame\npeaks = ds.radport.find_peaks(time_idx=0, freq_idx=10, threshold=5.0)\n\n# Create animation\nfig, ax = plt.subplots(figsize=(10, 8))\n\ndef animate_with_markers(time_idx):\n    ax.clear()\n\n    # Plot frame\n    frame = ds['SKY'].isel(time=time_idx, frequency=10)\n    im = ax.imshow(frame.values, origin='lower', cmap='viridis')\n\n    # Overlay markers\n    if len(peaks) &gt; 0:\n        l_coords, m_coords = zip(*peaks)\n        ax.scatter(l_coords, m_coords, marker='o',\n                  facecolors='none', edgecolors='red', s=200, linewidths=2)\n\n    ax.set_title(f'Time {time_idx}')\n    return im,\n\nfrom matplotlib.animation import FuncAnimation\nanim = FuncAnimation(fig, animate_with_markers, frames=range(100), interval=100)\n</code></pre>"},{"location":"user-guide/animations/#frequency-animation","title":"Frequency Animation","text":"<p>Animate across frequency channels:</p> <pre><code># Create animation over frequency at a fixed time\nanim = ds.radport.animate_frequency(\n    time_idx=0,\n    interval=100,\n    cmap='inferno'\n)\n\n# Save\nanim.save('frequency_sweep.mp4', writer='ffmpeg', fps=10)\n</code></pre>"},{"location":"user-guide/animations/#customizing-frequency-animations","title":"Customizing Frequency Animations","text":"<pre><code># Specify frequency range\nanim = ds.radport.animate_frequency(\n    time_idx=0,\n    freq_min=0,\n    freq_max=20,\n    interval=150,\n    figsize=(10, 8),\n    norm='log'\n)\n</code></pre>"},{"location":"user-guide/animations/#exporting-frame-sequences","title":"Exporting Frame Sequences","text":"<p>Export individual frames for external processing:</p> <pre><code># Export frames as PNG images\nds.radport.export_frames(\n    output_dir='frames/',\n    freq_idx=10,\n    time_min=0,\n    time_max=100,\n    format='png',\n    dpi=150,\n    cmap='viridis'\n)\n\n# Creates: frames/frame_0000.png, frame_0001.png, ...\n</code></pre>"},{"location":"user-guide/animations/#custom-frame-export","title":"Custom Frame Export","text":"<pre><code># Export with custom naming\nds.radport.export_frames(\n    output_dir='output/',\n    freq_idx=10,\n    format='png',\n    prefix='ovro_',\n    dpi=300,\n    cmap='plasma',\n    norm='log'\n)\n</code></pre>"},{"location":"user-guide/animations/#creating-video-from-frames","title":"Creating Video from Frames","text":"<p>Use ffmpeg externally to create video:</p> <pre><code>ffmpeg -framerate 10 -pattern_type glob -i 'frames/*.png' \\\n       -c:v libx264 -pix_fmt yuv420p output.mp4\n</code></pre>"},{"location":"user-guide/animations/#multi-panel-animations","title":"Multi-Panel Animations","text":"<p>Animate multiple views simultaneously:</p> <pre><code>import matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\n\nfig, axes = plt.subplots(2, 2, figsize=(12, 10))\n\ndef update(frame):\n    # Clear axes\n    for ax in axes.flat:\n        ax.clear()\n\n    # Different frequencies\n    for ax, freq_idx in zip(axes.flat, [0, 5, 10, 15]):\n        data = ds['SKY'].isel(time=frame, frequency=freq_idx)\n        ax.imshow(data.values, origin='lower', cmap='viridis')\n        freq_mhz = ds.coords['frequency'].values[freq_idx] / 1e6\n        ax.set_title(f'{freq_mhz:.1f} MHz')\n\n    fig.suptitle(f'Time frame {frame}')\n    plt.tight_layout()\n\nanim = FuncAnimation(fig, update, frames=range(100), interval=100)\nanim.save('multi_freq.mp4', writer='ffmpeg', fps=10)\n</code></pre>"},{"location":"user-guide/animations/#dynamic-spectrum-animation","title":"Dynamic Spectrum Animation","text":"<p>Animate a moving window through a dynamic spectrum:</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\n\n# Get full dynamic spectrum\nl_idx, m_idx = 512, 512\ndyn_spec = ds.radport.dynamic_spectrum(l_idx=l_idx, m_idx=m_idx)\n\n# Create sliding window animation\nfig, ax = plt.subplots(figsize=(10, 6))\nwindow_size = 20\n\ndef update(frame):\n    ax.clear()\n    start = frame\n    end = min(frame + window_size, len(dyn_spec.coords['time']))\n\n    ax.imshow(\n        dyn_spec[start:end].T,\n        aspect='auto',\n        origin='lower',\n        cmap='viridis'\n    )\n    ax.set_xlabel('Time')\n    ax.set_ylabel('Frequency')\n    ax.set_title(f'Dynamic Spectrum: frames {start}-{end}')\n\nframes = range(0, len(dyn_spec.coords['time']) - window_size, 5)\nanim = FuncAnimation(fig, update, frames=frames, interval=100)\n</code></pre>"},{"location":"user-guide/animations/#side-by-side-comparison","title":"Side-by-Side Comparison","text":"<p>Animate comparisons (e.g., before/after processing):</p> <pre><code>import matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\n\n# Create two versions (e.g., raw vs. processed)\nds_raw = ds\nds_processed = ds.radport.time_average()  # Or any processing\n\nfig, axes = plt.subplots(1, 2, figsize=(14, 6))\n\ndef update(frame):\n    for ax in axes:\n        ax.clear()\n\n    # Raw\n    axes[0].imshow(\n        ds_raw['SKY'].isel(time=frame, frequency=10).values,\n        origin='lower',\n        cmap='viridis'\n    )\n    axes[0].set_title('Raw')\n\n    # Processed (if time-independent, show same frame)\n    axes[1].imshow(\n        ds_processed.isel(frequency=10).values,\n        origin='lower',\n        cmap='viridis'\n    )\n    axes[1].set_title('Time Average')\n\n    fig.suptitle(f'Frame {frame}')\n\nanim = FuncAnimation(fig, update, frames=range(100), interval=100)\n</code></pre>"},{"location":"user-guide/animations/#animation-performance-tips","title":"Animation Performance Tips","text":""},{"location":"user-guide/animations/#1-use-appropriate-time-steps","title":"1. Use Appropriate Time Steps","text":"<pre><code># Animate every 5th frame for faster rendering\ntime_indices = range(0, 100, 5)\nanim = ds.radport.animate_time(\n    freq_idx=10,\n    time_min=0,\n    time_max=100,\n    interval=100\n)\n</code></pre>"},{"location":"user-guide/animations/#2-reduce-spatial-resolution","title":"2. Reduce Spatial Resolution","text":"<pre><code># Downsample before animating\nds_small = ds.coarsen(l=2, m=2, boundary='trim').mean()\nanim = ds_small.radport.animate_time(freq_idx=10)\n</code></pre>"},{"location":"user-guide/animations/#3-precompute-frames","title":"3. Precompute Frames","text":"<pre><code># Precompute frames for complex operations\nframes = []\nfor t in range(100):\n    frame = ds['SKY'].isel(time=t, frequency=10).values\n    # Apply any processing\n    frames.append(frame)\n\n# Now animate precomputed frames\n# (custom animation code)\n</code></pre>"},{"location":"user-guide/animations/#saving-options","title":"Saving Options","text":""},{"location":"user-guide/animations/#mp4-recommended","title":"MP4 (Recommended)","text":"<pre><code>anim.save('output.mp4', writer='ffmpeg', fps=10, bitrate=1800)\n</code></pre>"},{"location":"user-guide/animations/#gif","title":"GIF","text":"<pre><code>anim.save('output.gif', writer='pillow', fps=5)\n</code></pre>"},{"location":"user-guide/animations/#high-quality","title":"High Quality","text":"<pre><code>anim.save(\n    'output.mp4',\n    writer='ffmpeg',\n    fps=30,\n    dpi=300,\n    bitrate=5000,\n    extra_args=['-vcodec', 'libx264', '-crf', '15']\n)\n</code></pre>"},{"location":"user-guide/animations/#requirements","title":"Requirements","text":"<p>Animations require matplotlib and ffmpeg:</p> <pre><code># Install ffmpeg\n# macOS:\nbrew install ffmpeg\n\n# Ubuntu/Debian:\nsudo apt-get install ffmpeg\n\n# Or use pillow for GIF (already included)\npip install pillow\n</code></pre>"},{"location":"user-guide/animations/#example-full-pipeline","title":"Example: Full Pipeline","text":"<pre><code>import ovro_lwa_portal as ovro\nimport matplotlib.pyplot as plt\n\n# Load data\nds = ovro.open_dataset(\"path/to/data.zarr\")\n\n# Detect sources\npeaks = ds.radport.find_peaks(time_idx=0, freq_idx=10, threshold=5.0)\n\n# Create animation with overlays\nanim = ds.radport.animate_time(freq_idx=10, interval=100)\n\n# Save\nanim.save('ovro_animation.mp4', writer='ffmpeg', fps=10)\n\nprint(\"Animation saved!\")\n</code></pre>"},{"location":"user-guide/animations/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about visualization methods</li> <li>Try the transient analysis tutorial</li> <li>Explore the API reference</li> </ul>"},{"location":"user-guide/dispersion-measure/","title":"Dispersion Measure Correction","text":"<p>Dispersion measure (DM) correction is essential for pulsar and fast radio burst (FRB) observations.</p>"},{"location":"user-guide/dispersion-measure/#what-is-dispersion","title":"What is Dispersion?","text":"<p>Radio waves traveling through ionized plasma experience a frequency-dependent delay:</p> \\[ \\Delta t = 4.15 \\times 10^{3} \\, \\text{ms} \\times \\text{DM} \\times \\left( f_{\\text{low}}^{-2} - f_{\\text{high}}^{-2} \\right) \\] <p>where:</p> <ul> <li>DM is the dispersion measure in pc cm\u207b\u00b3</li> <li>f is frequency in MHz</li> </ul> <p>This causes pulses to arrive at different times across the frequency band, \"smearing\" the signal.</p>"},{"location":"user-guide/dispersion-measure/#dispersion-correction-methods","title":"Dispersion Correction Methods","text":""},{"location":"user-guide/dispersion-measure/#method-1-coherent-dedispersion","title":"Method 1: Coherent Dedispersion","text":"<p>!!! note \"Coming Soon\" Coherent dedispersion methods are planned for future releases. Track progress in GitHub Issue #85.</p>"},{"location":"user-guide/dispersion-measure/#method-2-incoherent-dedispersion","title":"Method 2: Incoherent Dedispersion","text":"<p>Apply time shifts to align frequencies:</p> <pre><code>import numpy as np\nimport ovro_lwa_portal as ovro\n\nds = ovro.open_dataset(\"path/to/data.zarr\")\n\ndef dedisperse_incoherent(ds, dm, ref_freq_mhz=None):\n    \"\"\"\n    Apply incoherent dedispersion.\n\n    Parameters\n    ----------\n    ds : xarray.Dataset\n        Input dataset\n    dm : float\n        Dispersion measure in pc cm^-3\n    ref_freq_mhz : float, optional\n        Reference frequency in MHz (default: highest frequency)\n\n    Returns\n    -------\n    xarray.Dataset\n        Dedispersed dataset\n    \"\"\"\n    freqs_hz = ds.coords['frequency'].values\n    freqs_mhz = freqs_hz / 1e6\n\n    if ref_freq_mhz is None:\n        ref_freq_mhz = freqs_mhz.max()\n\n    # Calculate delays\n    delays_ms = 4.15e3 * dm * (freqs_mhz**-2 - ref_freq_mhz**-2)\n\n    # Convert to time samples\n    time_vals = ds.coords['time'].values\n    dt = np.median(np.diff(time_vals))  # Time resolution in days\n    dt_ms = dt * 86400 * 1000  # Convert to milliseconds\n\n    delays_samples = np.round(delays_ms / dt_ms).astype(int)\n\n    # Apply shifts\n    dedispersed = ds.copy()\n    for freq_idx, shift in enumerate(delays_samples):\n        if shift != 0:\n            dedispersed['SKY'][:, freq_idx, :, :] = np.roll(\n                ds['SKY'][:, freq_idx, :, :].values,\n                shift=-shift,\n                axis=0\n            )\n\n    return dedispersed\n\n\n# Example: Dedisperse for Crab pulsar (DM \u2248 56.7)\nds_dedispersed = dedisperse_incoherent(ds, dm=56.7)\n</code></pre>"},{"location":"user-guide/dispersion-measure/#crab-pulsar-example","title":"Crab Pulsar Example","text":"<p>The Crab pulsar is an excellent test case with DM \u2248 56.7 pc cm\u207b\u00b3.</p>"},{"location":"user-guide/dispersion-measure/#before-dedispersion","title":"Before Dedispersion","text":"<pre><code>import matplotlib.pyplot as plt\n\n# Extract dynamic spectrum at pulsar location\nl_idx, m_idx = ds.radport.nearest_lm_idx(l=0.0, m=0.0)  # Adjust coordinates\ndyn_spec = ds.radport.dynamic_spectrum(l_idx=l_idx, m_idx=m_idx)\n\n# Plot\nds.radport.plot_dynamic_spectrum(dyn_spec)\nplt.title('Before Dedispersion')\nplt.show()\n</code></pre> <p>You should see diagonal features due to dispersion.</p>"},{"location":"user-guide/dispersion-measure/#after-dedispersion","title":"After Dedispersion","text":"<pre><code># Dedisperse\nds_dedispersed = dedisperse_incoherent(ds, dm=56.7)\n\n# Extract dynamic spectrum\ndyn_spec_dd = ds_dedispersed.radport.dynamic_spectrum(l_idx=l_idx, m_idx=m_idx)\n\n# Plot\nds_dedispersed.radport.plot_dynamic_spectrum(dyn_spec_dd)\nplt.title('After Dedispersion (DM=56.7)')\nplt.show()\n</code></pre> <p>Pulses should now align vertically across all frequencies.</p>"},{"location":"user-guide/dispersion-measure/#dm-optimization","title":"DM Optimization","text":"<p>Find the optimal DM by maximizing SNR:</p> <pre><code>def optimize_dm(ds, l_idx, m_idx, dm_range):\n    \"\"\"\n    Find optimal DM by maximizing peak SNR.\n\n    Parameters\n    ----------\n    ds : xarray.Dataset\n        Input dataset\n    l_idx, m_idx : int\n        Spatial location\n    dm_range : array-like\n        DM values to test (pc cm^-3)\n\n    Returns\n    -------\n    float\n        Optimal DM\n    \"\"\"\n    snrs = []\n\n    for dm in dm_range:\n        # Dedisperse\n        ds_dd = dedisperse_incoherent(ds, dm=dm)\n\n        # Get light curve (summed over frequency)\n        lc = ds_dd.radport.light_curve(l_idx=l_idx, m_idx=m_idx)\n\n        # Calculate SNR\n        mean_val = lc.mean().values\n        std_val = lc.std().values\n        max_val = lc.max().values\n\n        snr = (max_val - mean_val) / std_val if std_val &gt; 0 else 0\n        snrs.append(snr)\n\n    # Find maximum\n    best_idx = np.argmax(snrs)\n    best_dm = dm_range[best_idx]\n\n    return best_dm, np.array(snrs)\n\n\n# Test DM range around known value\ndm_range = np.linspace(50, 65, 30)\nbest_dm, snrs = optimize_dm(ds, l_idx, m_idx, dm_range)\n\n# Plot DM curve\nplt.figure(figsize=(10, 6))\nplt.plot(dm_range, snrs, 'o-')\nplt.axvline(best_dm, color='red', linestyle='--', label=f'Best DM={best_dm:.1f}')\nplt.xlabel('Dispersion Measure (pc cm\u207b\u00b3)')\nplt.ylabel('SNR')\nplt.title('DM Optimization')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.show()\n</code></pre>"},{"location":"user-guide/dispersion-measure/#fast-radio-bursts-frbs","title":"Fast Radio Bursts (FRBs)","text":"<p>For FRB detection and analysis:</p> <pre><code># High DM range for FRBs (typically 100-3000 pc cm^-3)\ndm_range_frb = np.linspace(100, 2000, 50)\n\n# Search for FRBs\ndef search_frbs(ds, dm_range, snr_threshold=8.0):\n    \"\"\"Search for FRB candidates.\"\"\"\n    candidates = []\n\n    for l_idx in range(0, ds.dims['l'], 50):  # Spatial search\n        for m_idx in range(0, ds.dims['m'], 50):\n            best_dm, snrs = optimize_dm(ds, l_idx, m_idx, dm_range)\n\n            if snrs.max() &gt; snr_threshold:\n                candidates.append({\n                    'l_idx': l_idx,\n                    'm_idx': m_idx,\n                    'dm': best_dm,\n                    'snr': snrs.max()\n                })\n\n    return candidates\n\n# Run search (may take time!)\n# candidates = search_frbs(ds, dm_range_frb)\n</code></pre>"},{"location":"user-guide/dispersion-measure/#visualization-tools","title":"Visualization Tools","text":""},{"location":"user-guide/dispersion-measure/#waterfall-plot","title":"Waterfall Plot","text":"<p>Classic pulsar visualization:</p> <pre><code>def plot_waterfall(ds, l_idx, m_idx, dm=None):\n    \"\"\"Create waterfall plot.\"\"\"\n    if dm is not None:\n        ds = dedisperse_incoherent(ds, dm=dm)\n\n    dyn_spec = ds.radport.dynamic_spectrum(l_idx=l_idx, m_idx=m_idx)\n\n    plt.figure(figsize=(12, 8))\n    plt.imshow(\n        dyn_spec.T,\n        aspect='auto',\n        origin='lower',\n        cmap='viridis',\n        interpolation='nearest'\n    )\n    plt.xlabel('Time')\n    plt.ylabel('Frequency Channel')\n    plt.colorbar(label='Intensity')\n    plt.title(f'Waterfall Plot (DM={dm if dm else 0})')\n    plt.show()\n\n# Plot\nplot_waterfall(ds, l_idx=512, m_idx=512, dm=56.7)\n</code></pre>"},{"location":"user-guide/dispersion-measure/#integrated-profile","title":"Integrated Profile","text":"<p>Fold the data at pulsar period:</p> <pre><code># For known pulsar period\ndef fold_pulsar(ds, l_idx, m_idx, period_s, dm=None):\n    \"\"\"Fold pulsar light curve at known period.\"\"\"\n    if dm is not None:\n        ds = dedisperse_incoherent(ds, dm=dm)\n\n    # Get light curve summed over frequency\n    lc = ds.radport.light_curve(l_idx=l_idx, m_idx=m_idx)\n\n    # Get time in seconds\n    times = ds.coords['time'].values * 86400  # MJD to seconds\n\n    # Calculate phase\n    phase = (times % period_s) / period_s\n\n    # Bin by phase\n    n_bins = 50\n    phase_bins = np.linspace(0, 1, n_bins + 1)\n    profile = np.zeros(n_bins)\n\n    for i in range(n_bins):\n        mask = (phase &gt;= phase_bins[i]) &amp; (phase &lt; phase_bins[i + 1])\n        profile[i] = lc.values[mask].mean()\n\n    return np.linspace(0, 1, n_bins), profile\n\n# Example for Crab (period \u2248 33 ms)\nphase, profile = fold_pulsar(ds, l_idx, m_idx, period_s=0.033, dm=56.7)\n\nplt.figure(figsize=(10, 6))\nplt.plot(phase, profile, 'o-')\nplt.xlabel('Pulse Phase')\nplt.ylabel('Intensity')\nplt.title('Folded Pulse Profile')\nplt.grid(True, alpha=0.3)\nplt.show()\n</code></pre>"},{"location":"user-guide/dispersion-measure/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Know Your Source: Start with published DM values when available</p> </li> <li> <p>Frequency Range: Wider bands increase dispersion sensitivity</p> </li> <li> <p>Time Resolution: Ensure adequate sampling for your science case</p> </li> <li> <p>SNR Optimization: Use DM optimization for unknown sources</p> </li> <li> <p>Validation: Visually inspect dedispersed dynamic spectra</p> </li> </ol>"},{"location":"user-guide/dispersion-measure/#next-steps","title":"Next Steps","text":"<ul> <li>Try the pulsar dedispersion tutorial</li> <li>Learn about transient analysis</li> <li>Explore the API reference</li> </ul>"},{"location":"user-guide/fits-to-zarr/","title":"FITS to Zarr Conversion","text":"<p>The OVRO-LWA Portal provides tools for converting FITS image files to cloud-optimized Zarr format.</p>"},{"location":"user-guide/fits-to-zarr/#why-zarr","title":"Why Zarr?","text":"<p>Zarr offers several advantages over FITS for large radio astronomy datasets:</p> <ul> <li>Cloud-optimized: Efficient access to data stored in cloud object stores</li> <li>Chunked storage: Read only the data you need</li> <li>Parallel I/O: Multiple processes can read simultaneously</li> <li>Compression: Reduce storage requirements</li> <li>Incremental updates: Append new observations to existing stores</li> </ul>"},{"location":"user-guide/fits-to-zarr/#command-line-interface","title":"Command-Line Interface","text":""},{"location":"user-guide/fits-to-zarr/#basic-conversion","title":"Basic Conversion","text":"<p>Convert a directory of FITS files to Zarr:</p> <pre><code>ovro-ingest convert /path/to/fits /path/to/output\n</code></pre> <p>This will:</p> <ol> <li>Scan the input directory for FITS files</li> <li>Convert each file to Zarr format</li> <li>Create a single consolidated Zarr store</li> <li>Display progress with a rich progress bar</li> </ol>"},{"location":"user-guide/fits-to-zarr/#advanced-options","title":"Advanced Options","text":"<pre><code>ovro-ingest convert /path/to/fits /path/to/output \\\n    --zarr-name custom_name.zarr \\\n    --chunk-lm 2048 \\\n    --rebuild\n</code></pre>"},{"location":"user-guide/fits-to-zarr/#options","title":"Options","text":"<ul> <li><code>--zarr-name</code>: Name of the output Zarr store (default: derived from input   path)</li> <li><code>--chunk-lm</code>: Chunk size for the l and m dimensions (default: 1024)</li> <li><code>--rebuild</code>: Remove existing Zarr store and rebuild from scratch</li> </ul>"},{"location":"user-guide/fits-to-zarr/#get-help","title":"Get Help","text":"<pre><code>ovro-ingest convert --help\n</code></pre>"},{"location":"user-guide/fits-to-zarr/#python-api","title":"Python API","text":"<p>For more control, use the Python API directly:</p>"},{"location":"user-guide/fits-to-zarr/#basic-usage","title":"Basic Usage","text":"<pre><code>from pathlib import Path\nfrom ovro_lwa_portal.ingest import FITSToZarrConverter\nfrom ovro_lwa_portal.ingest.core import ConversionConfig\n\n# Configure conversion\nconfig = ConversionConfig(\n    input_dir=Path(\"/path/to/fits\"),\n    output_dir=Path(\"/path/to/output\"),\n    zarr_name=\"ovro_lwa_data.zarr\",\n)\n\n# Execute conversion\nconverter = FITSToZarrConverter(config)\nresult = converter.convert()\nprint(f\"Created: {result}\")\n</code></pre>"},{"location":"user-guide/fits-to-zarr/#configuration-options","title":"Configuration Options","text":"<pre><code>config = ConversionConfig(\n    input_dir=Path(\"/path/to/fits\"),\n    output_dir=Path(\"/path/to/output\"),\n    zarr_name=\"ovro_lwa_data.zarr\",\n    chunk_lm=2048,              # Chunk size for l/m dimensions\n    rebuild=False,              # Whether to rebuild existing store\n    compressor=None,            # Custom compression (optional)\n)\n</code></pre>"},{"location":"user-guide/fits-to-zarr/#incremental-processing","title":"Incremental Processing","text":"<p>Append new observations to an existing Zarr store:</p> <pre><code># First conversion\nconfig1 = ConversionConfig(\n    input_dir=Path(\"/path/to/fits/batch1\"),\n    output_dir=Path(\"/path/to/output\"),\n    zarr_name=\"observations.zarr\",\n)\nconverter1 = FITSToZarrConverter(config1)\nconverter1.convert()\n\n# Append more data\nconfig2 = ConversionConfig(\n    input_dir=Path(\"/path/to/fits/batch2\"),\n    output_dir=Path(\"/path/to/output\"),\n    zarr_name=\"observations.zarr\",  # Same name\n    rebuild=False,                   # Don't rebuild\n)\nconverter2 = FITSToZarrConverter(config2)\nconverter2.convert()\n</code></pre>"},{"location":"user-guide/fits-to-zarr/#concurrent-write-protection","title":"Concurrent Write Protection","text":"<p>The converter uses file locking to prevent data corruption when multiple processes write to the same Zarr store:</p> <pre><code>from pathlib import Path\nfrom concurrent.futures import ProcessPoolExecutor\nfrom ovro_lwa_portal.ingest import FITSToZarrConverter\nfrom ovro_lwa_portal.ingest.core import ConversionConfig\n\ndef convert_batch(batch_dir):\n    config = ConversionConfig(\n        input_dir=batch_dir,\n        output_dir=Path(\"/path/to/output\"),\n        zarr_name=\"shared_observations.zarr\",\n    )\n    converter = FITSToZarrConverter(config)\n    return converter.convert()\n\n# Safe to run in parallel\nwith ProcessPoolExecutor(max_workers=4) as executor:\n    batches = [Path(f\"/path/to/batch{i}\") for i in range(4)]\n    results = executor.map(convert_batch, batches)\n</code></pre>"},{"location":"user-guide/fits-to-zarr/#preserving-wcs-coordinates","title":"Preserving WCS Coordinates","text":"<p>The converter automatically preserves World Coordinate System (WCS) information:</p> <ul> <li>Right Ascension (RA) and Declination (Dec)</li> <li>Frequency and time coordinates</li> <li>Observation metadata</li> </ul> <p>After conversion, you can work with celestial coordinates directly:</p> <pre><code>import ovro_lwa_portal\n\nds = ovro_lwa_portal.open_dataset(\"observations.zarr\")\n\n# Access WCS coordinates\nra = ds.coords['ra']\ndec = ds.coords['dec']\n\n# Select by celestial coordinates\nregion = ds.sel(ra=slice(10, 20), dec=slice(-5, 5))\n</code></pre>"},{"location":"user-guide/fits-to-zarr/#best-practices","title":"Best Practices","text":"<ol> <li>Chunk Size: Choose chunk sizes that match your access patterns</li> <li>For time series analysis: larger time chunks</li> <li> <p>For spatial analysis: larger l/m chunks</p> </li> <li> <p>Compression: Use compression for reduced storage (enabled by default)</p> </li> <li> <p>Incremental Updates: Use <code>rebuild=False</code> to append new data</p> </li> <li> <p>Parallel Processing: The converter is safe for concurrent writes</p> </li> <li> <p>Cloud Storage: Convert data once, then access efficiently from anywhere</p> </li> </ol>"},{"location":"user-guide/source-detection/","title":"Source Detection","text":"<p>The <code>radport</code> accessor provides methods for detecting and analyzing radio sources in OVRO-LWA data.</p>"},{"location":"user-guide/source-detection/#signal-to-noise-maps","title":"Signal-to-Noise Maps","text":""},{"location":"user-guide/source-detection/#rms-map","title":"RMS Map","text":"<p>Calculate the root-mean-square (noise) map:</p> <pre><code>import ovro_lwa_portal as ovro\n\nds = ovro.open_dataset(\"path/to/data.zarr\")\n\n# Calculate RMS over time\nrms = ds.radport.rms_map(freq_idx=10)\n\n# The result is a 2D map (l, m)\nprint(f\"RMS map shape: {rms.shape}\")\nprint(f\"Median RMS: {rms.median().values:.3e}\")\n</code></pre>"},{"location":"user-guide/source-detection/#snr-map","title":"SNR Map","text":"<p>Calculate signal-to-noise ratio map:</p> <pre><code># SNR map at a specific time and frequency\nsnr = ds.radport.snr_map(time_idx=0, freq_idx=10)\n\n# Plot it\nds.radport.plot_snr_map(\n    snr,\n    vmin=0,\n    vmax=10,\n    cmap='hot'\n)\n</code></pre> <p>Interpretation:</p> <ul> <li>SNR &lt; 3: Noise-dominated</li> <li>SNR 3-5: Marginal detections</li> <li>SNR &gt; 5: Significant detections</li> <li>SNR &gt; 10: Strong sources</li> </ul>"},{"location":"user-guide/source-detection/#peak-finding","title":"Peak Finding","text":""},{"location":"user-guide/source-detection/#basic-peak-detection","title":"Basic Peak Detection","text":"<p>Find local maxima in an image:</p> <pre><code># Find peaks with SNR &gt; 5\npeaks = ds.radport.find_peaks(\n    time_idx=0,\n    freq_idx=10,\n    threshold=5.0,\n    min_separation=10  # Minimum separation in pixels\n)\n\nprint(f\"Found {len(peaks)} peaks\")\nprint(f\"Peak locations (l, m): {peaks}\")\n</code></pre>"},{"location":"user-guide/source-detection/#peak-flux-map","title":"Peak Flux Map","text":"<p>Create a map showing only peak values:</p> <pre><code># Peak flux map\npeak_map = ds.radport.peak_flux_map(\n    time_idx=0,\n    freq_idx=10,\n    threshold=5.0\n)\n\n# Plot with base image\nimport matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(1, 2, figsize=(12, 5))\n\n# Original image\nds.radport.plot(time_idx=0, freq_idx=10, ax=axes[0])\naxes[0].set_title('Original')\n\n# Peak map\naxes[1].imshow(peak_map, origin='lower', cmap='hot')\naxes[1].set_title('Detected Peaks')\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"user-guide/source-detection/#visualizing-detections","title":"Visualizing Detections","text":"<p>Overlay detected sources on the image:</p> <pre><code>import matplotlib.pyplot as plt\n\n# Detect sources\npeaks = ds.radport.find_peaks(\n    time_idx=0,\n    freq_idx=10,\n    threshold=5.0\n)\n\n# Plot image\nds.radport.plot(time_idx=0, freq_idx=10)\n\n# Overlay detections\nax = plt.gca()\nif len(peaks) &gt; 0:\n    l_coords, m_coords = zip(*peaks)\n    ax.scatter(\n        l_coords, m_coords,\n        marker='o',\n        facecolors='none',\n        edgecolors='red',\n        s=200,\n        linewidths=2,\n        label=f'{len(peaks)} detections'\n    )\n    ax.legend()\n\nplt.show()\n</code></pre>"},{"location":"user-guide/source-detection/#multi-frequency-detection","title":"Multi-Frequency Detection","text":"<p>Detect sources across multiple frequencies:</p> <pre><code># Detection at multiple frequencies\nfreq_indices = [0, 5, 10, 15]\nall_peaks = {}\n\nfor freq_idx in freq_indices:\n    peaks = ds.radport.find_peaks(\n        time_idx=0,\n        freq_idx=freq_idx,\n        threshold=5.0\n    )\n    all_peaks[freq_idx] = peaks\n    print(f\"Frequency {freq_idx}: {len(peaks)} sources\")\n</code></pre>"},{"location":"user-guide/source-detection/#transient-detection","title":"Transient Detection","text":"<p>Identify sources that appear or vary significantly:</p>"},{"location":"user-guide/source-detection/#time-domain-variability","title":"Time-Domain Variability","text":"<pre><code>import numpy as np\n\n# Calculate variability for each pixel\ntime_indices = range(0, 100)\nl_idx, m_idx = 512, 512\n\n# Get light curve\nlc = ds.radport.light_curve(l_idx=l_idx, m_idx=m_idx)\n\n# Calculate variability metrics\nmean_flux = lc.mean().values\nstd_flux = lc.std().values\nvariability = std_flux / mean_flux if mean_flux &gt; 0 else 0\n\nprint(f\"Variability index: {variability:.2f}\")\n\n# High variability indicates transient or variable source\nif variability &gt; 0.5:\n    print(\"Potentially variable source detected!\")\n</code></pre>"},{"location":"user-guide/source-detection/#difference-imaging","title":"Difference Imaging","text":"<p>Detect transients using difference imaging:</p> <pre><code># Reference image (time-averaged)\nreference = ds.radport.time_average(time_min=0, time_max=50)\n\n# Current image\ncurrent = ds['SKY'].isel(time=100, frequency=10)\n\n# Difference\ndifference = current - reference.isel(frequency=10)\n\n# Find significant changes\nimport matplotlib.pyplot as plt\nplt.figure(figsize=(10, 8))\nplt.imshow(difference.values, origin='lower', cmap='RdBu_r')\nplt.colorbar(label='Flux Difference')\nplt.title('Transient Detection: Difference Image')\nplt.show()\n</code></pre>"},{"location":"user-guide/source-detection/#source-cataloging","title":"Source Cataloging","text":"<p>Build a source catalog from detections:</p> <pre><code>import pandas as pd\n\n# Detect sources\npeaks = ds.radport.find_peaks(\n    time_idx=0,\n    freq_idx=10,\n    threshold=5.0\n)\n\n# Extract properties for each source\ncatalog = []\nfor l_idx, m_idx in peaks:\n    # Get position\n    l_val = ds.coords['l'].values[l_idx]\n    m_val = ds.coords['m'].values[m_idx]\n\n    # Get peak flux\n    flux = ds['SKY'].isel(\n        time=0,\n        frequency=10,\n        l=l_idx,\n        m=m_idx\n    ).values\n\n    # Get spectral index if multiple frequencies available\n    if len(ds.coords['frequency']) &gt; 1:\n        alpha = ds.radport.spectral_index(\n            freq_idx1=0,\n            freq_idx2=10,\n            l_idx=l_idx,\n            m_idx=m_idx\n        )\n    else:\n        alpha = np.nan\n\n    catalog.append({\n        'l': l_val,\n        'm': m_val,\n        'l_idx': l_idx,\n        'm_idx': m_idx,\n        'flux': flux,\n        'spectral_index': alpha\n    })\n\n# Convert to DataFrame\ndf = pd.DataFrame(catalog)\ndf = df.sort_values('flux', ascending=False)\n\nprint(df.head())\n</code></pre>"},{"location":"user-guide/source-detection/#advanced-detection","title":"Advanced Detection","text":""},{"location":"user-guide/source-detection/#matched-filter","title":"Matched Filter","text":"<p>For detecting sources with known shapes:</p> <pre><code>from scipy.ndimage import gaussian_filter\n\n# Get image\nimage = ds['SKY'].isel(time=0, frequency=10).values\n\n# Apply matched filter (Gaussian)\nfiltered = gaussian_filter(image, sigma=2.0)\n\n# Find peaks in filtered image\nfrom scipy.signal import find_peaks_cwt\n# ... peak detection on filtered image\n</code></pre>"},{"location":"user-guide/source-detection/#blob-detection","title":"Blob Detection","text":"<p>For extended sources:</p> <pre><code>from skimage.feature import blob_log\n\n# Get image\nimage = ds['SKY'].isel(time=0, frequency=10).values\n\n# Detect blobs (extended sources)\nblobs = blob_log(\n    image,\n    min_sigma=1,\n    max_sigma=10,\n    num_sigma=10,\n    threshold=0.1\n)\n\nprint(f\"Detected {len(blobs)} extended sources\")\n\n# Visualize\nimport matplotlib.pyplot as plt\nds.radport.plot(time_idx=0, freq_idx=10)\nax = plt.gca()\n\nfor blob in blobs:\n    y, x, r = blob\n    circle = plt.Circle(\n        (x, y), r,\n        color='red',\n        fill=False,\n        linewidth=2\n    )\n    ax.add_patch(circle)\n\nplt.show()\n</code></pre>"},{"location":"user-guide/source-detection/#quality-filtering","title":"Quality Filtering","text":"<p>Filter detections based on quality criteria:</p> <pre><code># Get SNR map\nsnr = ds.radport.snr_map(time_idx=0, freq_idx=10)\n\n# Find peaks\npeaks = ds.radport.find_peaks(\n    time_idx=0,\n    freq_idx=10,\n    threshold=5.0\n)\n\n# Filter by additional criteria\nfiltered_peaks = []\nfor l_idx, m_idx in peaks:\n    snr_val = snr[m_idx, l_idx]  # Note: y, x order\n\n    # Check if SNR is high enough\n    if snr_val &gt; 7.0:\n        # Check if not at edge\n        margin = 10\n        if (margin &lt; l_idx &lt; snr.shape[1] - margin and\n            margin &lt; m_idx &lt; snr.shape[0] - margin):\n            filtered_peaks.append((l_idx, m_idx))\n\nprint(f\"Filtered: {len(peaks)} \u2192 {len(filtered_peaks)} sources\")\n</code></pre>"},{"location":"user-guide/source-detection/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Background Estimation: Ensure accurate background/noise estimation</p> </li> <li> <p>Edge Effects: Exclude detections near image edges</p> </li> <li> <p>False Positives: Use conservative thresholds (SNR &gt; 5-7)</p> </li> <li> <p>Validation: Visually inspect detections</p> </li> <li> <p>Multi-Frequency Confirmation: Confirm detections across multiple    frequencies</p> </li> </ol> <pre><code># Multi-frequency validation\ndef validate_source(ds, l_idx, m_idx, freq_indices, snr_threshold=5.0):\n    \"\"\"Check if source is detected at multiple frequencies.\"\"\"\n    detections = 0\n    for freq_idx in freq_indices:\n        snr = ds.radport.snr_map(time_idx=0, freq_idx=freq_idx)\n        if snr[m_idx, l_idx] &gt; snr_threshold:\n            detections += 1\n    return detections &gt;= len(freq_indices) * 0.5  # 50% criterion\n</code></pre>"},{"location":"user-guide/source-detection/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about spectral analysis of detected sources</li> <li>Try the transient analysis tutorial</li> <li>Explore the API reference</li> </ul>"},{"location":"user-guide/spectral-analysis/","title":"Spectral Analysis","text":"<p>The <code>radport</code> accessor provides methods for analyzing spectral properties of radio sources.</p>"},{"location":"user-guide/spectral-analysis/#frequency-spectra","title":"Frequency Spectra","text":""},{"location":"user-guide/spectral-analysis/#basic-spectrum","title":"Basic Spectrum","text":"<p>Extract frequency spectrum at a spatial location:</p> <pre><code>import ovro_lwa_portal as ovro\n\nds = ovro.open_dataset(\"path/to/data.zarr\")\n\n# Spectrum at a pixel\nspec = ds.radport.spectrum(l_idx=512, m_idx=512)\n\n# Plot it\nds.radport.plot_spectrum(spec)\n</code></pre>"},{"location":"user-guide/spectral-analysis/#spatially-averaged-spectrum","title":"Spatially Averaged Spectrum","text":"<pre><code># Average over entire field\nspec_avg = ds.radport.spectrum()\n\n# Average over a region\nspec_region = ds.radport.spectrum(\n    l_min=500, l_max=524,\n    m_min=500, m_max=524\n)\n\n# Average over time as well\nspec_full = ds.radport.spectrum(\n    l_min=500, l_max=524,\n    m_min=500, m_max=524,\n    time_min=0, time_max=100\n)\n</code></pre>"},{"location":"user-guide/spectral-analysis/#spectral-index","title":"Spectral Index","text":"<p>The spectral index (\u03b1) describes how flux density varies with frequency: S \u221d \u03bd^\u03b1</p>"},{"location":"user-guide/spectral-analysis/#point-spectral-index","title":"Point Spectral Index","text":"<p>Calculate spectral index at a location:</p> <pre><code># Spectral index between two frequencies\nalpha = ds.radport.spectral_index(\n    freq_idx1=0,\n    freq_idx2=10,\n    l_idx=512,\n    m_idx=512\n)\n\nprint(f\"Spectral index: {alpha:.2f}\")\n</code></pre>"},{"location":"user-guide/spectral-analysis/#spectral-index-map","title":"Spectral Index Map","text":"<p>Create a map of spectral indices across the field:</p> <pre><code># Calculate spectral index map\nalpha_map = ds.radport.spectral_index_map(\n    freq_idx1=0,\n    freq_idx2=10,\n    time_idx=0\n)\n\n# Plot it\nds.radport.plot_spectral_index_map(\n    alpha_map,\n    vmin=-2,\n    vmax=2,\n    cmap='RdBu_r'\n)\n</code></pre> <p>Interpretation:</p> <ul> <li>\u03b1 \u2248 -0.7: Typical synchrotron emission (many AGN)</li> <li>\u03b1 \u2248 0: Flat spectrum sources (some quasars)</li> <li>\u03b1 &gt; 0: Inverted spectrum (self-absorbed sources)</li> <li>\u03b1 &lt; -1: Steep spectrum sources</li> </ul>"},{"location":"user-guide/spectral-analysis/#multi-frequency-spectral-index","title":"Multi-Frequency Spectral Index","text":"<p>For more than two frequencies:</p> <pre><code># Use multiple frequency pairs\nfreq_pairs = [(0, 5), (5, 10), (10, 15)]\n\nimport matplotlib.pyplot as plt\nfig, axes = plt.subplots(1, 3, figsize=(15, 5))\n\nfor ax, (f1, f2) in zip(axes, freq_pairs):\n    alpha_map = ds.radport.spectral_index_map(\n        freq_idx1=f1,\n        freq_idx2=f2,\n        time_idx=0\n    )\n    ds.radport.plot_spectral_index_map(alpha_map, ax=ax)\n    ax.set_title(f'\u03b1 between freq {f1} and {f2}')\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"user-guide/spectral-analysis/#integrated-flux","title":"Integrated Flux","text":"<p>Calculate total flux density in a region:</p> <pre><code># Integrated flux at one frequency/time\nflux = ds.radport.integrated_flux(\n    time_idx=0,\n    freq_idx=10,\n    l_min=500, l_max=524,\n    m_min=500, m_max=524\n)\n\nprint(f\"Integrated flux: {flux:.3e} Jy\")\n</code></pre>"},{"location":"user-guide/spectral-analysis/#flux-evolution","title":"Flux Evolution","text":"<p>Track how flux changes with time:</p> <pre><code>import matplotlib.pyplot as plt\n\n# Calculate flux for each time step\nfluxes = []\ntimes = ds.coords['time'].values\n\nfor t_idx in range(len(times)):\n    flux = ds.radport.integrated_flux(\n        time_idx=t_idx,\n        freq_idx=10,\n        l_min=500, l_max=524,\n        m_min=500, m_max=524\n    )\n    fluxes.append(flux)\n\n# Plot flux evolution\nplt.figure(figsize=(10, 6))\nplt.plot(times, fluxes, 'o-')\nplt.xlabel('Time (MJD)')\nplt.ylabel('Integrated Flux (Jy)')\nplt.title('Flux Evolution')\nplt.grid(True, alpha=0.3)\nplt.show()\n</code></pre>"},{"location":"user-guide/spectral-analysis/#spectral-energy-distribution-sed","title":"Spectral Energy Distribution (SED)","text":"<pre><code># Calculate flux at each frequency\nfreqs = ds.coords['frequency'].values / 1e6  # Convert to MHz\nfluxes = []\n\nfor f_idx in range(len(freqs)):\n    flux = ds.radport.integrated_flux(\n        time_idx=0,\n        freq_idx=f_idx,\n        l_min=500, l_max=524,\n        m_min=500, m_max=524\n    )\n    fluxes.append(flux)\n\n# Plot SED\nplt.figure(figsize=(10, 6))\nplt.loglog(freqs, fluxes, 'o-')\nplt.xlabel('Frequency (MHz)')\nplt.ylabel('Flux Density (Jy)')\nplt.title('Spectral Energy Distribution')\nplt.grid(True, alpha=0.3, which='both')\nplt.show()\n</code></pre>"},{"location":"user-guide/spectral-analysis/#spectral-fitting","title":"Spectral Fitting","text":"<p>Fit power law to spectral data:</p> <pre><code>import numpy as np\nfrom scipy.optimize import curve_fit\n\n# Power law model: S = A * (\u03bd/\u03bd0)^\u03b1\ndef power_law(freq, amplitude, alpha, freq0=40.0):\n    return amplitude * (freq / freq0)**alpha\n\n# Get flux densities\nfreqs = ds.coords['frequency'].values / 1e6\nfluxes = [\n    ds.radport.integrated_flux(\n        time_idx=0, freq_idx=i,\n        l_min=500, l_max=524,\n        m_min=500, m_max=524\n    )\n    for i in range(len(freqs))\n]\n\n# Fit\npopt, pcov = curve_fit(power_law, freqs, fluxes)\namplitude, alpha = popt\n\nprint(f\"Amplitude: {amplitude:.3e} Jy\")\nprint(f\"Spectral index: {alpha:.2f}\")\n\n# Plot fit\nplt.figure(figsize=(10, 6))\nplt.loglog(freqs, fluxes, 'o', label='Data')\nfreq_fit = np.linspace(freqs.min(), freqs.max(), 100)\nplt.loglog(freq_fit, power_law(freq_fit, *popt), '-', label=f'Fit (\u03b1={alpha:.2f})')\nplt.xlabel('Frequency (MHz)')\nplt.ylabel('Flux Density (Jy)')\nplt.legend()\nplt.grid(True, alpha=0.3, which='both')\nplt.show()\n</code></pre>"},{"location":"user-guide/spectral-analysis/#spectral-variability","title":"Spectral Variability","text":"<p>Analyze how spectra change over time:</p> <pre><code># Spectrum at different times\ntimes_to_plot = [0, 50, 100]\nfreqs = ds.coords['frequency'].values / 1e6\n\nplt.figure(figsize=(10, 6))\n\nfor t_idx in times_to_plot:\n    spec = ds.radport.spectrum(\n        l_idx=512, m_idx=512,\n        time_min=t_idx, time_max=t_idx+1\n    )\n    plt.plot(freqs, spec.values, 'o-', label=f'Time {t_idx}')\n\nplt.xlabel('Frequency (MHz)')\nplt.ylabel('Intensity')\nplt.title('Spectral Evolution')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.show()\n</code></pre>"},{"location":"user-guide/spectral-analysis/#frequency-averaging","title":"Frequency Averaging","text":"<p>Average over frequency bands:</p> <pre><code># Average over low frequencies\nlow_freq = ds.radport.frequency_average(freq_min=0, freq_max=5)\n\n# Average over high frequencies\nhigh_freq = ds.radport.frequency_average(freq_min=10, freq_max=15)\n\n# Compare\nfig, axes = plt.subplots(1, 2, figsize=(12, 5))\nds.radport.plot_frequency_average(low_freq, time_idx=0, ax=axes[0])\naxes[0].set_title('Low Frequency')\nds.radport.plot_frequency_average(high_freq, time_idx=0, ax=axes[1])\naxes[1].set_title('High Frequency')\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"user-guide/spectral-analysis/#best-practices","title":"Best Practices","text":"<ol> <li>Quality Check: Always check for valid data before spectral analysis</li> </ol> <pre><code># Check data quality\nfraction = ds.radport.finite_fraction(time_idx=0, freq_idx=10)\nif fraction &lt; 0.9:\n    print(f\"Warning: Only {fraction*100:.1f}% valid data\")\n</code></pre> <ol> <li> <p>Background Subtraction: Consider subtracting background for accurate flux    measurements</p> </li> <li> <p>Beam Correction: Account for primary beam attenuation if analyzing    off-axis sources</p> </li> <li> <p>RFI Flagging: Identify and flag radio frequency interference before    spectral analysis</p> </li> </ol>"},{"location":"user-guide/spectral-analysis/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about source detection</li> <li>Try the spectral mapping tutorial</li> <li>Explore the API reference</li> </ul>"},{"location":"user-guide/visualization/","title":"Visualization","text":"<p>The <code>radport</code> accessor provides comprehensive visualization methods for OVRO-LWA data.</p> <p>For an introduction to plotting, refer to the Basic Plotting guide.</p>"},{"location":"user-guide/visualization/#cutout-visualization","title":"Cutout Visualization","text":"<p>Extract and visualize regions of interest:</p> <pre><code># Create cutout around a region\ncutout = ds.radport.cutout(\n    l_min=-0.3, l_max=0.3,\n    m_min=-0.3, m_max=0.3,\n    time_min=0, time_max=10,\n    freq_min=5, freq_max=15\n)\n\n# Plot the cutout\ncutout.radport.plot_cutout(\n    time_idx=0,\n    freq_idx=0,\n    show_box=True  # Show original region boundaries\n)\n</code></pre>"},{"location":"user-guide/visualization/#time-frequency-visualizations","title":"Time-Frequency Visualizations","text":""},{"location":"user-guide/visualization/#dynamic-spectrum","title":"Dynamic Spectrum","text":"<p>Visualize temporal evolution at a specific spatial location:</p> <pre><code># Extract dynamic spectrum\ndyn_spec = ds.radport.dynamic_spectrum(l_idx=512, m_idx=512)\n\n# Plot it\nds.radport.plot_dynamic_spectrum(\n    dyn_spec,\n    cmap='plasma',\n    aspect='auto',\n    interpolation='nearest'\n)\n</code></pre> <p>For spatial regions:</p> <pre><code># Average over a region\ndyn_spec_region = ds.radport.dynamic_spectrum(\n    l_min=500, l_max=524,\n    m_min=500, m_max=524\n)\n</code></pre>"},{"location":"user-guide/visualization/#difference-plots","title":"Difference Plots","text":"<p>Visualize changes between time steps or frequencies:</p> <pre><code># Time difference\ndiff_time = ds.radport.diff(dim='time', n=1)\nds.radport.plot_diff(diff_time, freq_idx=10)\n\n# Frequency difference\ndiff_freq = ds.radport.diff(dim='frequency', n=1)\nds.radport.plot_diff(diff_freq, time_idx=0)\n</code></pre>"},{"location":"user-guide/visualization/#light-curves-and-spectra","title":"Light Curves and Spectra","text":""},{"location":"user-guide/visualization/#light-curves","title":"Light Curves","text":"<p>Track intensity over time:</p> <pre><code># Single pixel\nlc = ds.radport.light_curve(l_idx=512, m_idx=512)\nds.radport.plot_light_curve(lc, label='Source A')\n\n# Multiple sources\nimport matplotlib.pyplot as plt\nfig, ax = plt.subplots(figsize=(10, 6))\n\nfor l, m, label in [(512, 512, 'Source A'), (600, 600, 'Source B')]:\n    lc = ds.radport.light_curve(l_idx=l, m_idx=m)\n    ds.radport.plot_light_curve(lc, label=label, ax=ax)\n\nax.legend()\nplt.show()\n</code></pre>"},{"location":"user-guide/visualization/#frequency-spectra","title":"Frequency Spectra","text":"<pre><code># Spectrum at a location\nspec = ds.radport.spectrum(l_idx=512, m_idx=512)\nds.radport.plot_spectrum(spec)\n\n# Spatially averaged spectrum\nspec_avg = ds.radport.spectrum()\nds.radport.plot_spectrum(spec_avg, label='Average')\n</code></pre>"},{"location":"user-guide/visualization/#grid-plots","title":"Grid Plots","text":""},{"location":"user-guide/visualization/#time-grid","title":"Time Grid","text":"<p>Plot multiple time steps side-by-side:</p> <pre><code># Grid of 4 time steps\nds.radport.plot_time_grid(\n    freq_idx=10,\n    time_indices=[0, 5, 10, 15],\n    ncols=2,\n    figsize=(12, 10),\n    cmap='inferno'\n)\n</code></pre>"},{"location":"user-guide/visualization/#frequency-grid","title":"Frequency Grid","text":"<p>Plot multiple frequencies:</p> <pre><code># Grid of 4 frequencies\nds.radport.plot_frequency_grid(\n    time_idx=0,\n    freq_indices=[0, 5, 10, 15],\n    ncols=2,\n    figsize=(12, 10)\n)\n</code></pre>"},{"location":"user-guide/visualization/#general-grid-plot","title":"General Grid Plot","text":"<p>Maximum flexibility:</p> <pre><code># Custom grid configuration\nds.radport.plot_grid(\n    time_indices=[0, 5, 10],\n    freq_indices=[0, 10],\n    nrows=2,\n    ncols=3,\n    figsize=(15, 10),\n    share_colorbar=True\n)\n</code></pre>"},{"location":"user-guide/visualization/#averaged-visualizations","title":"Averaged Visualizations","text":""},{"location":"user-guide/visualization/#time-average","title":"Time Average","text":"<pre><code># Average over all time\ntime_avg = ds.radport.time_average()\nds.radport.plot_time_average(time_avg, freq_idx=10)\n\n# Average over time range\ntime_avg = ds.radport.time_average(time_min=10, time_max=50)\n</code></pre>"},{"location":"user-guide/visualization/#frequency-average","title":"Frequency Average","text":"<pre><code># Average over all frequencies\nfreq_avg = ds.radport.frequency_average()\nds.radport.plot_frequency_average(freq_avg, time_idx=0)\n\n# Average over frequency range\nfreq_avg = ds.radport.frequency_average(freq_min=5, freq_max=15)\n</code></pre>"},{"location":"user-guide/visualization/#advanced-customization","title":"Advanced Customization","text":""},{"location":"user-guide/visualization/#custom-colormaps","title":"Custom Colormaps","text":"<pre><code>import matplotlib.pyplot as plt\nfrom matplotlib.colors import LogNorm\n\n# Log scale with custom colormap\nds.radport.plot(\n    time_idx=0,\n    freq_idx=10,\n    cmap='magma',\n    norm='log',\n    vmin=1e-3,\n    vmax=1e2\n)\n</code></pre>"},{"location":"user-guide/visualization/#multiple-panels","title":"Multiple Panels","text":"<pre><code>import matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(1, 3, figsize=(15, 5))\n\n# Plot different frequencies\nfor ax, freq_idx in zip(axes, [0, 5, 10]):\n    ds.radport.plot(time_idx=0, freq_idx=freq_idx, ax=ax)\n    ax.set_title(f'Frequency index: {freq_idx}')\n\nplt.tight_layout()\nplt.show()\n</code></pre>"},{"location":"user-guide/visualization/#overlaying-contours","title":"Overlaying Contours","text":"<pre><code>import matplotlib.pyplot as plt\n\n# Base image\nds.radport.plot(time_idx=0, freq_idx=10)\n\n# Overlay contours\nax = plt.gca()\ndata = ds['SKY'].isel(time=0, frequency=10).values\nax.contour(data, colors='white', alpha=0.5, levels=5)\nplt.show()\n</code></pre>"},{"location":"user-guide/visualization/#validation-tools","title":"Validation Tools","text":""},{"location":"user-guide/visualization/#finding-valid-frames","title":"Finding Valid Frames","text":"<p>Find frames without NaN values:</p> <pre><code># Find first valid frame\nvalid_idx = ds.radport.find_valid_frame(freq_idx=10)\nds.radport.plot(time_idx=valid_idx, freq_idx=10)\n</code></pre>"},{"location":"user-guide/visualization/#finite-fraction","title":"Finite Fraction","text":"<p>Check data quality:</p> <pre><code># Get fraction of finite values\nfraction = ds.radport.finite_fraction(time_idx=0, freq_idx=10)\nprint(f\"Valid data: {fraction*100:.1f}%\")\n</code></pre>"},{"location":"user-guide/visualization/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about animations</li> <li>Explore WCS coordinate plotting</li> <li>Try spectral analysis</li> <li>See the API reference</li> </ul>"},{"location":"user-guide/wcs-coordinates/","title":"WCS Coordinates","text":"<p>WCS (World Coordinate System) information is preserved during FITS-to-Zarr conversion, enabling celestial coordinate (RA/Dec) overlays on sky images. The <code>radport</code> accessor provides methods to check WCS availability, convert between pixel and sky coordinates, and create publication-quality WCS-projected plots.</p>"},{"location":"user-guide/wcs-coordinates/#checking-wcs-availability","title":"Checking WCS Availability","text":"<pre><code>import ovro_lwa_portal as ovro\n\nds = ovro.open_dataset(\"path/to/data.zarr\")\n\nif ds.radport.has_wcs:\n    print(\"WCS coordinates available\")\n</code></pre> <p>The WCS header is searched in three locations (in order):</p> <ol> <li>Variable attributes (<code>fits_wcs_header</code> on the <code>SKY</code> variable)</li> <li>Dataset attributes (<code>fits_wcs_header</code> on the dataset)</li> <li>A <code>wcs_header_str</code> data variable in the dataset</li> </ol> <p>!!! note WCS functionality requires astropy to be installed.</p>"},{"location":"user-guide/wcs-coordinates/#pixel-to-sky-conversion","title":"Pixel-to-Sky Conversion","text":"<p>Convert pixel indices along the <code>l</code> and <code>m</code> dimensions to celestial coordinates:</p> <pre><code>ra, dec = ds.radport.pixel_to_coords(l_idx=100, m_idx=100)\nprint(f\"RA: {ra:.4f} deg, Dec: {dec:.4f} deg\")\n</code></pre> <ul> <li>RA is returned in the range [0, 360) degrees</li> <li>Dec is returned in degrees</li> <li>Raises <code>ValueError</code> if indices are out of bounds</li> </ul>"},{"location":"user-guide/wcs-coordinates/#sky-to-pixel-conversion","title":"Sky-to-Pixel Conversion","text":"<p>Convert RA/Dec coordinates to pixel indices:</p> <pre><code>l_idx, m_idx = ds.radport.coords_to_pixel(ra=180.0, dec=45.0)\nprint(f\"Pixel: l={l_idx}, m={m_idx}\")\n</code></pre> <ul> <li>Returns rounded integer indices</li> <li>Raises <code>ValueError</code> if the coordinates fall outside the image bounds</li> <li>Uses the FK5 celestial frame</li> </ul>"},{"location":"user-guide/wcs-coordinates/#plotting-with-wcs-projection","title":"Plotting with WCS Projection","text":"<p>The <code>plot_wcs</code> method creates plots with RA/Dec coordinate axes and a grid overlay:</p> <pre><code># Basic WCS plot\nfig = ds.radport.plot_wcs(freq_mhz=50.0)\n</code></pre>"},{"location":"user-guide/wcs-coordinates/#customizing-the-plot","title":"Customizing the Plot","text":"<pre><code># Publication-quality dark-background plot\nfig = ds.radport.plot_wcs(\n    freq_mhz=50.0,\n    mask_radius=1800,\n    cmap=\"inferno\",\n    grid_color=\"white\",\n    grid_alpha=0.6,\n    grid_linestyle=\":\",\n    label_color=\"white\",\n    facecolor=\"black\",\n    figsize=(10, 10),\n)\n</code></pre>"},{"location":"user-guide/wcs-coordinates/#key-parameters","title":"Key Parameters","text":"Parameter Default Description <code>var</code> <code>\"SKY\"</code> Data variable to plot (<code>\"SKY\"</code> or <code>\"BEAM\"</code>) <code>time_idx</code> <code>0</code> Time index <code>freq_idx</code> <code>0</code> Frequency index (ignored if <code>freq_mhz</code> is set) <code>freq_mhz</code> <code>None</code> Select frequency by value in MHz <code>cmap</code> <code>\"inferno\"</code> Matplotlib colormap <code>robust</code> <code>True</code> Use 2nd/98th percentile for color scaling <code>mask_radius</code> <code>None</code> Circular mask radius in pixels <code>grid_color</code> <code>\"white\"</code> Color of the RA/Dec grid lines <code>grid_alpha</code> <code>0.6</code> Transparency of grid lines <code>facecolor</code> <code>\"black\"</code> Plot background color <code>add_colorbar</code> <code>True</code> Whether to include a colorbar <p>The plot automatically handles RA axis inversion (RA increases to the left on the sky) and uses robust percentile-based scaling by default.</p>"},{"location":"user-guide/wcs-coordinates/#example-workflows","title":"Example Workflows","text":""},{"location":"user-guide/wcs-coordinates/#locate-a-source-by-radec-and-extract-a-light-curve","title":"Locate a Source by RA/Dec and Extract a Light Curve","text":"<pre><code># Find the Crab Nebula (RA=83.633, Dec=22.014)\nl_idx, m_idx = ds.radport.coords_to_pixel(ra=83.633, dec=22.014)\n\n# Get the l, m coordinate values at those indices\nl_val = float(ds.coords[\"l\"].values[l_idx])\nm_val = float(ds.coords[\"m\"].values[m_idx])\n\n# Extract and plot the light curve\nlc = ds.radport.light_curve(l=l_val, m=m_val)\nfig = ds.radport.plot_light_curve(lc)\n</code></pre>"},{"location":"user-guide/wcs-coordinates/#create-a-cutout-around-a-known-position","title":"Create a Cutout Around a Known Position","text":"<pre><code># Convert RA/Dec to pixel coordinates\nl_idx, m_idx = ds.radport.coords_to_pixel(ra=83.633, dec=22.014)\nl_val = float(ds.coords[\"l\"].values[l_idx])\nm_val = float(ds.coords[\"m\"].values[m_idx])\n\n# Extract a cutout centered on the source\ncutout = ds.radport.cutout(l_center=l_val, m_center=m_val, dl=0.1, dm=0.1)\nfig = ds.radport.plot_cutout(cutout)\n</code></pre>"},{"location":"user-guide/wcs-coordinates/#wcs-plot-with-detected-sources","title":"WCS Plot with Detected Sources","text":"<pre><code>import matplotlib.pyplot as plt\n\n# Create WCS plot\nfig = ds.radport.plot_wcs(freq_mhz=50.0, mask_radius=1800)\nax = fig.axes[0]\n\n# Overlay detected sources\npeaks = ds.radport.find_peaks(time_idx=0, freq_idx=0, threshold=5.0)\nfor l_idx, m_idx in peaks:\n    ra, dec = ds.radport.pixel_to_coords(int(l_idx), int(m_idx))\n    ax.plot(ra, dec, \"r+\", markersize=10, transform=ax.get_transform(\"fk5\"))\n\nplt.show()\n</code></pre>"},{"location":"user-guide/wcs-coordinates/#how-wcs-is-preserved","title":"How WCS Is Preserved","text":"<p>The WCS pipeline works as follows:</p> <ol> <li>Original FITS files contain standard WCS headers (CRVAL, CRPIX, CDELT,    etc.)</li> <li>Header fixing (<code>fix_fits_headers</code>) corrects any non-standard headers</li> <li>Zarr conversion stores the complete WCS header as a string attribute    (<code>fits_wcs_header</code>) on the data variable or dataset</li> <li>At load time, the <code>radport</code> accessor parses the stored header string back    into an astropy <code>WCS</code> object on demand</li> </ol> <p>This means WCS information survives the FITS-to-Zarr conversion pipeline and is available whenever the original FITS files contained valid WCS headers.</p>"},{"location":"user-guide/wcs-coordinates/#see-also","title":"See Also","text":"<ul> <li>Coordinate Systems -- Introduction   to pixel (l, m) and celestial coordinate systems</li> <li>Visualization -- General plotting methods</li> <li>API Reference -- Full method documentation for   <code>pixel_to_coords</code>, <code>coords_to_pixel</code>, and <code>plot_wcs</code></li> </ul>"}]}